<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>parse prompt</name>
			<script>-- set prompt to this:

-- Prompt:
-- ?p' -- MORE -- '&lt;%f?f|@R%hhp@n @G%ee@n @B?m'[%mmv]'!m'%vmv'@n %gwm %xxp?l' %llhp' %d?b' %c'&gt;%\

-- need to have the group parsed aleady to have things to fill in
if ( not player.name ) then

    if (not player.pendingGroup) then
      
      send('group all')
      player.pendingGroup = true
  
    		echo('\nWaiting for leader/group before parsing prompt...\n')
        
    		if (not player.initPending) then
        player.pendingGroup = nil
    			player.initPending = true
    			common.initPlayer()
    		end
        
    end
  
else

	-- prompt flags:
	-- c - camouflaged
  -- h - hidden
  -- i - invisible
  -- P - player killing ok
  -- A - arena
  -- p - parry on
  -- S - sanctuary
  -- s - sneaking
  -- t - tracking
  -- x - searching
  -- B - burdened
  -- b - berserk skill active
  -- f - focus skill active
  -- M - you have new mudmail

	local promptFlags = matches[2]

	-- set parry state
	if string.find(promptFlags, 'p') then player.parry = true else player.parry = false end


	if string.find(promptFlags, '[chi]') then player.hidden = true else player.hidden = false end


-- gmcp is better source now

  -- group[player.name].hp = tonumber(matches[3])
  -- group[player.name].mp = tonumber(matches[4])
  -- group[player.name].moves = tonumber(matches[5])
-- 
  -- player.hp = tonumber(matches[3])
  -- player.mp = tonumber(matches[4])
  -- player.moves = tonumber(matches[5])

  group.lowest_moves = tonumber(matches[6])

	if (matches[7] and matches[7] ~= '') then
    
    -- using gmcp now...
		-- echo('\nsetting leader hp to ' .. tostring(matches[7]))
  	if (group.members[group.leader]) then
			
      -- group[group.leader].hp = tonumber(matches[7])
		else
			cecho('\n^^&lt;orange&gt;PROMPT &lt;white&gt; i spy leader hp but might not be grouped yet...\n')
		end

	end

	if (matches[9] == '-Dark-') then
		cecho('\n^^&lt;red&gt;\nIt\'s super dark yo! &lt;white&gt;-- make light\n')
	end

end

raiseEvent(common.events.PARSED_PROMPT)



-- examples...

-- &lt;209hp 94e 138mv 138wm 122617xp NESW&gt;
-- &lt;S|472hp 629e 150mv 150wm 12777631xp ??&gt;  &lt;-- sleeping prompt
-- &lt;304hp 28e [375mv] 152wm 1260782xp -Dark-&gt;

-- &lt;209hp 94e 138mv 138wm 122751xp NESW leaking guts&gt;
-- &lt;527hp 27e 181mv 161wm 7020514xp 500lhp EW&gt;
-- &lt;209hp 94e 138mv 138wm 122617xp NESW&gt;
-- &lt;527hp 27e 182mv 182wm 7020514xp ?? NESW&gt;
-- &lt;527hp 27e 181mv 161wm 7026324xp 500lhp EW covered in blood&gt;</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^&lt;(\w+\|)?(\d+)hp (\d+)e \[?(\d+)mv\]? (\d+)wm\s+[0-9-]+xp (\d+)?(lhp\s|\?\?\s)?([NESWneswUDud]+|-Dark-|none|\?\?)(\s.+)?&gt;</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>repeat stuff jammed in prompt</name>
			<script>-- deleting the line prevents any further triggers being executed on it?

if (matches[3] and matches[3] ~= '') then

  local prompt = matches[2]
  local stuff = matches[3]

  deleteLine() -- this will prevent any further triggers matching this line!?

  feedTriggers(prompt .. '\n')
  feedTriggers(stuff .. '\n')
  cecho('&lt;green&gt; ^^ was appended to prompt')

end
</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^(&lt;[^&gt;]*&gt;)\s*(.+)$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="yes" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>filter broken prompts</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^(?:&lt;[^&gt;]+&gt;\s*)?([^&lt;].*)$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>parsing stuff</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>parse score (position and condition)</name>
					<script>player.position = matches[2]
player.condition = string.split(matches[3], ' ')

if (common.tableHasValue(player.condition, 'delirious')) then
	cecho('\n&lt;green&gt;SCORE: &lt;white&gt;tripping with the fishes\n')
	player.tripping = true
else
	player.tripping = false
end

common.onNextEvent(common.events.PARSED_PROMPT, function (evt, args)
	raiseEvent(common.events.PARSED_SCORE)
end)
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\s+Position:\s+\[\s+(\w+)\s+]\s+Condition: \[\s+(\w+)\s+\]</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>parse group</name>
					<script>-- depricated, getting this stuff from gmcp now


-- Leader: Darion
--
-- [ 14 Pal Dwf   ] Darion                209/209     94/94   138/138       122869
-- [ 41 Pal Dwf L ] Darion                641/641   100/100   205/205     11787449

-- pretend these players aren't in our group
-- need to do this if they don't have the teamwork triggers
-- i.e wont respond to commands / queries
local playerIgnore = {
	-- Marsuvious = true,
	-- Bashukin = true,
}

-- group row
if (matches[3]) then

	if (matches[2] == player.name or not player.tripping) then

		if playerIgnore[matches[2]] then
			echo(' &lt;-- ignored')
			return
		end

    local status = group.data[matches[2]] or {}

    status.hp = tonumber(matches[3])
    status.hp_max = tonumber(matches[4])
    status.mp = tonumber(matches[5])
    status.mp_max = tonumber(matches[6])
    status.moves = tonumber(matches[7])
    status.moves_max = tonumber(matches[8])
    status.xp = matches[9]

    --
    selectString(matches[1],1)
    replace(matches[1]:gsub(matches[9], common.commaCase(matches[9])))
    -- cecho(' &lt;- &lt;green&gt;replaced some numbers\n')

		-- dupe into player info for conwenience
		if (matches[2] == player.name) then
			for key, val in pairs(status) do
				player[key] = val
			end
		end

		if (not player.tripping) then
			group.memberCount = group.memberCount + 1
			group.members[matches[2]] = true
      group.data[matches[2]] = status
		end

	else
		echo(' &lt;-- tripping')
	end

-- leader row
else

	if (matches[2] == player.name or not player.tripping) then
		group.leader = matches[2]
		if (not player.tripping) then
  		group.memberCount = 0
  		group.members = {}
      group.data = {}
		end
	else
		echo(' &lt;-- tripping')
	end

  common.onNextEvent(common.events.PARSED_PROMPT, function (evt, args)
		-- echo('\n ^^ raising parsed group event\n\n')
		player.initPending = false
  	raiseEvent(common.events.PARSED_GROUP)
  end)

end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\[\s+\d+\s+\w+\s+\w+\s+\w*\s*\]\s+(\S+)\s+(\d+)/(\d+)\s+(\d+)/(\d+)\s+(\d+)/(\d+)\s+(\d+)$</string>
						<string>^Leader:\s+(.*)$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>parse inventory</name>
					<script>
-- display(matches)

-- a stick of blue chalk           1  .10   a simple mug of water           1  .27
-- a fragment of burning red stone                                          1  .50

if (matches[2] == 'Coins') then

	-- start of inventory
	player.coins = tonumber(matches[3])
	player.coinWeight = tonumber(matches[4])
	player.parsingInventory = true
	player.inventory = {}


else

	if (matches[2] == 'Number') then
		-- this is the end of the inventory

		raiseEvent(common.events.PARSED_INVENTORY)
		player.parsingInventory = false

	else

		-- inventory line
		player.inventory[matches[2]] = tonumber(matches[3])

		if(matches[5]) then
			player.inventory[matches[5]] = tonumber(matches[6])
		end

	end

end


</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(Coins): (\d+) = \[ .* \] \s+ Weight: (\d+\.\d+) lbs</string>
						<string>^\s+(Number):\s+(\d+)\s+\( Max =\s+(\d+) \)</string>
						<string>^(an? .+?)\s+(\d+)\s+(\d*\.?\d+?)\s+(an? .+?)\s+(\d+)\s+(\d*\.?\d+?)</string>
						<string>^(an? .+?)\s+(\d+)\s+(\d*\.?\d+?)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>parse affects</name>
					<script>echo('^^ --- looking at affects...\n')
player.affects = {}

local affectWatcher = tempRegexTrigger([[^((?:A|Your?|Divinely) .+?)\s{3,}(\S.*)$]], function ()
	player.affects[matches[2]] = matches[3]
end)

common.onNextEvent(common.events.PARSED_PROMPT, function()

	killTrigger(affectWatcher)
	raiseEvent(common.events.PARSED_AFFECTS, player.affects)

end)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Affect\s+Source\s*$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>parse prepped</name>
					<script>player.prepped = {}

local prepTrig = tempRegexTrigger([[^\s*(\d+)\s*(.+?)\s*\d+\s*$]], function ()
	player.prepped[matches[3]] = tonumber(matches[2])
end)

common.onNextEvent(common.events.PARSED_PROMPT, function (evt, args)
  cecho('\n&lt;green&gt;PREP:&lt;white&gt; finished parsing prepped spells\n\n')
	killTrigger(prepTrig)
	raiseEvent(common.events.PARSED_PREPARED, player.prepped)
end)	</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You have no spells prepared.</string>
						<string>^Num\s+Spell\s+Mana\s*$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>parse equipment</name>
					<script>player = player or {}
player.gear = player.gear or {}
player.itemSlot = player.itemSlot or {}

if (matches[2] == 'Equipment') then
	-- start of parsing

	player.gear.parsing = true
	player.gear = {}
	-- cecho(' &lt;--- parsing start')

elseif (matches[2] == 'Weight') then

	-- end of parsing
	player.gear.parsing = nil
	player.gear.currentSlot = nil

	raiseEvent(common.events.PARSED_EQUIPMENT)
	-- cecho(' &lt; --- parsing end')
	-- display(player.gear)

else

 	-- if this line has a slot, get rid of the redundant part and set it to be the current slot
	if (matches[2] ~= '') then
		player.gear.currentSlot = rex.gsub(matches[2], [[^(floating|worn on|worn around|worn about) ]], "", 1)
	end

	local item = common.itemSanitize(matches[4])

	player.gear[player.gear.currentSlot] = player.gear[player.gear.currentSlot] or {}
	player.gear[player.gear.currentSlot][matches[3]] = {item = item, condition = matches[5] }

	player.itemSlot[item] = {slot=player.gear.currentSlot, layer=matches[3]}
	-- cecho(' &lt;--- its some gear ')

end



           </script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\s+ \+\+\+ (Equipment) \+\+\+</string>
						<string>^(Weight):</string>
						<string>^(.*?)\s+(bottom|under|base|over|top)\s+(.*?)\s+(worthless|damaged|very worn|worn|very scratch|scratched|reasonable|good|very good|excellent|perfect)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>parse skills</name>
					<script>-- replicate             unk        1920    8    minor enchantment [7] &amp; continual light [7]
-- riding                 10
-- ryoushi               unk          16    5

-- cecho('&lt;green&gt; &lt;--- incoming skills')

player.skills = player.skills or {}
local skillParser = tempRegexTrigger([[^(.+?)\s{2,}(\d+|unk)]], function()

  local skill = matches[2]
  local level
  if (matches[3] == 'unk') then
    level = 0
  else
    level = tonumber(matches[3])
  end
  player.skills[skill] = level
end)

common.onNextEvent(common.events.PARSED_PROMPT, function ()
  -- cecho('&lt;green&gt; &lt;--- incoming skills done')
  killTrigger(skillParser)
  -- display(player.skills)
  raiseEvent(common.events.PARSED_ABILITIES, player.skills)
end)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Skill\s+Level\s+Cost\s+Pracs\s+Prerequisites\s*$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>improve</name>
					<script>-- ** You improve at escape. **

local skill = matches[2]

if (player.skills and player.skills[skill] ~= nil and player.skills[skill] &gt; 0) then

  player.skills[skill] = player.skills[skill] + 1

else

  send('abil all')

end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\*\* You improve at (.*)\. \*\*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>parse who</name>
					<script>
-- cecho(' &lt;green&gt;&lt;- who starts\n')

local who = {
  Befriended = {},
  Known = {},
  Unknown = {},
  clan = {}
}

local playerType = multimatches[2][2]

local ptTrig = tempRegexTrigger([[^\s+(Befriended|Known|Unknown)\s*$]], function()
  playerType = matches[2]
  -- cecho(' &lt;green&gt;&lt;- pt: ' .. playerType .. '\n')
end)


local pTrig = tempRegexTrigger([[\[\s+(\d+)? (\w+|\?\?)\s+(\w\w\w)\s+(\w\w)?\s+\] (\w+)[,. ](.*?)\s+ (\w\w\w\w| -- )]], function()
  -- display(matches)
  -- cecho(' &lt;green&gt;&lt;- captured\n')
  local playa = {
    level = matches[2],
    class = matches[3],
    race = matches[4],
    flags = matches[5],
    name = matches[6],
    title = matches[7],
    clan = matches[8],
  }
  
  if (playa.level == '') then
    playa.level = 0
  else
    playa.level = tonumber(playa.level)
  end

  if (playa.clan ~= ' -- ') then
    who.clan[playa.clan] = who.clan[playa.clan] or {}
    who.clan[playa.clan][playa.name] = playa
  end
  
  who[playerType][playa.name] = playa
  
end)


tempRegexTrigger([[^\s+\[\s+\d+ players \|\s+\d+ high \|\s+\d+ record \]\s*$]], function()
  -- cecho(' &lt;green&gt;&lt;- who ends\n')
  killTrigger(ptTrig)
  killTrigger(pTrig)
  raiseEvent(common.events.PARSED_WHO, who)
end, 1)


-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
                                   -- Befriended
                                   -- ----------
-- [   ??   Vyn CL ] Chundrick is in Medienne for Shields                   BoTS
-- [ 88 Dru Ogr    ] Mojune is lost                                         BoTS
-- [   ??   Hum    ] Shopiere tell me report to find my location             -- 
-- 
                                     -- Known
                                     -- -----
-- [ 88 Mag Ogr    ] Bede is in Wastes                                      BoTS
-- [   ??   Ogr    ] Bimgore the ogre                                        -- 
-- [ 87 Thi Gob    ] Brazden is an Australian sex symbol. Rawr.             BoTS
-- [ 51 Brd Orc    ] Kathaar Werewolf bar mitzvah, spooky scary.            BoTS
-- [ 85 Mon Trl    ] Milthian following                                     BoTS
-- [ 87 Mon Liz    ] Shazzul Slens                                          BoTS
-- [ 90 Thi Vyn    ] Taldoran.                                              BoTS
-- [   ??   Ogr    ] Umarra follow-mode                                      -- 
-- [ 90 Dru Gob    ] Uni nil                                                 -- 
-- 
                                    -- Unknown
                                    -- -------
-- [   ??   Ogr    ] Affenaut incomprehensible at worst. afk at best.        -- 
-- [   ??   Hum    ] Anri is running Theatre in the Hills                    -- 
-- [ 30 Dru Ent    ] Ashera is running Rabbits                               -- 
-- [ 90 Thi Gob    ] Avlis is running: Castle Lag                            -- 
-- [   ??   Dwf    ] Calimar is running MBEARS                               -- 
-- [ 90 Cle Ogr    ] Corim the ogre cleric                                   -- 
-- [ 83 Pal Hum    ] Cyhi Fin.                                              SAGE
-- [ 40 Mon Hum    ] Drakondor the human                                     -- 
-- [ 49 War Hum    ] Euphe Jergaaaaaaaaaault!                                -- 
-- [ 49 Pal Ogr CL ] Gnoggh Citadull                                        BoTS
-- [   ??   Vyn    ] Katria is rather self-destructive.                      -- 
-- [ 90 Pal Vyn    ] Lafiel Celestine, has lost HOPE.                        -- 
-- [ 90 Mag Vyn    ] Mazren was inspiration for the vyan wizard doll         -- 
-- [   ??   Ogr    ] Nitia.                                                  -- 
-- [  5 Thi Gob    ] Paulus the goblin                                       -- 
-- [   ??   Hum    ] Seras now with major enchant                            -- 
-- [ 90 Mon Gob    ] Shingo the goblin                                       -- 
-- [ 90 Mon Liz    ] Straus the lizardman                                    -- 
-- [ 90 Brd Orc    ] Thalos the sonic blender                                -- 
-- [   ??   Hum    ] Thullkor I don't know where.                            -- 
-- [ 30 Thi Gob    ] Trea is in Stonies                                     BoTS
-- [ 72 Cle Ogr    ] Wahooka, PST if you need to smile.                      -- 
-- [ 21 Ran Elf    ] Xamdam the elf                                          -- 
-- [ 16 Mag Gob CL ] Yurvin Sphinxes                                        SAGE
-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
                      -- [ 36 players | 36 high | 46 record ]</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>1</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-</string>
						<string>^\s+(Befriended|Known|Unknown)\s*$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>sleep-murder</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>tank returned</name>
					<script>murder.tankState = 'here'
cecho(' &lt;- &lt;green&gt;MURDER: &lt;white&gt;tank has returned\n')
-- 
-- local combatStarted
-- local combatEnded
-- local roomChanged
-- local resumeTimer
-- 
-- -- kill countdown if combat ends in this time
-- local killResumeTimer = function ()
-- 
  -- if resumeTimer ~= nil then
		-- killTimer(resumeTimer)
		-- cecho('\n&lt;green&gt;MURDER: &lt;white&gt;killed waiting for tank action timer: ')
		-- resumeTimer = nil
     -- -- kill any remaining event watchers
    -- combatStarted()
    -- combatEnded()
    -- roomChanged()
	-- end
-- 
-- end
-- 
-- 
-- 
-- if (murder.resumeTimer) then
  -- killResumeTimer()
-- end
-- 
-- -- setup timer to resume in x secs if no action...
-- resumeTimer = tempTimer(90, function ()
  -- killResumeTimer()
	-- cecho('\n&lt;yellow&gt;MURDER: &lt;white&gt;tank returned and no action within 60s')
	-- send('gstat seems like a suspect pause....')
	-- send('gstat resume')
-- end, 'waitng for tank to do something after resuming (60s)')
-- 
-- 
-- 
-- 
-- -- the problematic one seems to be when we switch rooms right as
-- -- the tank returns because there is no mob to kill
-- roomChanged = common.onNextEvent(tfe.events.ROOM_CHANGED, function ()
  -- cecho('\n&lt;green&gt;MURDER:&lt;white&gt; cleared resume timer\n')
  -- killResumeTimer()
-- end)
-- 
-- combatEnded = common.onNextEvent(common.events.COMBAT_ENDED, killResumeTimer)
-- combatStarted = common.onNextEvent(common.events.COMBAT_STARTED, killResumeTimer)	</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\S+ reports group status[^:]*: "(back|still here|saw it die)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>mob state</name>
					<script>local damState = {
 ['perfect health'] = 1,
 ['slightly scratched'] = 0.95,
 ['few bruises'] = 0.85,
 ['some cuts'] = 0.75,
 ['several wounds'] = 0.65,
 ['badly wounded'] = 0.55,
 ['many nasty wounds'] = 0.45,
 ['bleeding freely'] = 0.35,
 ['covered in blood'] = 0.25,
 ['leaking guts'] = 0.15,
 ['mostly dead'] = 0.1,
 ['stunned'] = 0,
 ['incapacitated'] = 0,
 ['mortally wounded'] = 0,
 ['DEAD!'] = 0
}

player.dance_threshold = player.dance_threshold or damState['bleeding freely']



if (murder.pendingActionTimer) then
	killTimer(murder.pendingActionTimer)
	murder.pendingActionTimer = nil
end

if (murder.sleepMode == 'paused') then
	return
end


local health = damState[matches[3]] or 1

if (not damState[matches[3]]) then
	cecho('\n\n&lt;red&gt;MURDER: &lt;white&gt;Unknown health state' .. matches[3] .. '\n\n')
end




if health &lt;= player.dance_threshold then
-- if (matches[3] ~= 'DEAD!') then

	murder.sleepMode = 'dancing'

elseif (matches[3] == 'DEAD!') then

	-- back to the start
	murder.sleepMode = 'next'

else

	murder.sleepMode = 'chopping'

end

cecho(' &lt;-- &lt;white&gt;' .. health * 100 .. '% : ' .. murder.sleepMode .. '\n')
	</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff00ed</mFgColor>
					<mBgColor>#44433f</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Your ([a-z-]+) .*\[\s+(.*)\s+\]!?\.?$</string>
						<string>^The burst of flame (\S+) .*\[\s+(.*)\s+\]$</string>
						<string>^The blue arcs of energy (\S+) .*\[\s+(.*)\s+\]$</string>
						<string>^The touch of ice (\S+) .*\[\s+(.*)\s+\]$</string>
						<string>^The touch of acid (\S+) .*\[\s+(.*)\s+\]$</string>
						<string>^The brilliant bolt of lightning (\S+) .*\[\s+(.*)\s+\]$</string>
						<string>^The splatter of acid (\S+) .*\[\s+(.*)\s+\]$</string>
						<string>^The bifurcating lightning bolt (\S+) .*\[\s+(.*)\s+\]$</string>
						<string>^An incandescent spear of flame (\S+) .*\[\s+(.*)\s+\]$</string>
						<string>^The sphere of cold (\S+) .*\[\s+(.*)\s+\]$</string>
						<string>^The icy blast (\S+) .*\[\s+(.*)\s+\]$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>falls asleep - murder mode</name>
					<script>
-- nb: if mob is incapacitated mage will be unable to leave the room

local vic = common.dotCase(common.toMurderString(matches[3]))
murder.lastMob = vic


-- reminder to check murder.resume() clears a murder.pause() timer on moju
-- also that a second murder.pause doesn't start a second timer?


local setActionPending = function ()

 	-- setup timer to resume in x secs if no action...
	-- restart timer if one exists already
	if (murder.pendingActionTimer) then
		killTimer(murder.pendingActionTimer)
	end

	if (murder.sleepMoode ~= 'paused') then
  	murder.pendingActionTimer = tempTimer(10, function ()
  		cecho('\n\n&lt;yellow&gt;MURDER: &lt;White&gt;pending action didn\'t occur within 10s\n')
     	murder.sleepMode = 'next'
  		murder.pendingActionTimer = nil
  	end, 'pending action timer (chop/dance)')
	end


end

--
if (murder.sleepMode == 'next') then

	-- send('gstat pause')

	-- go straight to dance mode if our threshold is 100%
	-- looking at you charging warriors / assasinating thieves
	if (player.dance_threshold == 1) then
		murder.sleepMode = 'dancing'
	else
		murder.sleepMode = 'chopping'
	end

end

if (murder.sleepMode == 'paused') then

	cecho('&lt;white&gt; &lt;- ignoring (murdering paused)')

elseif (murder.sleepMode == 'chopping') then

	murder.sleepMode = 'chop-pending'
	setActionPending()

	common.setParryState(false, 'sleepmode: chopping', function ()

  	if (improves and improves.spellList and #improves.spellList &gt; 0 and player.mp &gt; 90 and murder.castingLocked == nil) then

      local spell = improves.getImproveSpell()


      if (spell ~= '') then

        cecho(' &lt;-- set casting lock')
  			murder.castingLocked = tempTimer(35, function ()
  				murder.castingLocked = nil
  			end, 'casting locked for 35s')

        tempTimer(2, function ()
          send(spell .. ' ' .. vic .. ' &amp; k ' .. vic)
        end, 'delay in case of tank queued sleep?')

      else
			  player.autoAttack(vic)
      end

  	else
			-- cecho('\n&lt;green&gt;MURDER: &lt;white&gt;didn\'t cast, mp: ' .. tostring(player.mp) .. ', cl: ' .. tostring(murder.castingLocked) .. '\n')
  		player.autoAttack(vic)
  	end
	end)

-- can be in dance-pending if we miss during the previous dance-pending
elseif (murder.sleepMode == 'dancing') then

	murder.sleepMode = 'dance-pending'
	setActionPending()

	common.setParryState(true, 'sleepmode: dancing', function ()

  	if (murder.tankState == 'here') then
			-- delay to allow queue to catch up
			tempTimer(1, function ()
        disableTrigger('sprawling')
  			send('dismount &amp; stand &amp; sit')
    		send('queue gstat leave')
        murder.tankState = 'out-pending'
			end, 'waiting for parry to kick in (queue delay)')

  		murder.tankState = 'leave-request-pending'
    	tempRegexTrigger([[^\S+ reports group status[^:]*: "(out|failed to leave)"]], function ()
        enableTrigger('sprawling')
        murder.tankState = 'out-confirmed'

    		if (matches[2] == 'out') then

          cecho('\n&lt;orange&gt;PARRY: &lt;white&gt;setting  - temp off (dance hit then reenable)')
          player.parryQueue = player.parryQueue + 2


          local returnModes = {before = true, after = true, with = true}
          if (not returnModes[player.danceReturnMode]) then
            player.danceReturnMode = 'after'
          end

          player.danceReturnMode = player.danceReturnMode or 'after'

          if (player.danceReturnMode == 'before') then
            send('queue gstat return ' .. vic)
          end

          send('queue opt parry &amp; queue stand &amp; queue mount')

          if (player.danceReturnMode == 'with') then
            send('queue gstat return ' .. vic)
          end

          player.autoAttack(vic)
          
          send('queue opt parry')


          if (player.danceReturnMode == 'after') then
            send('queue gstat return ' .. vic)
          end


    		else
  				cecho('\n&lt;orange&gt;PARRY: &lt;white&gt;setting  - temp off (dance hit then reenable)')
          send('opt parry &amp; stand &amp; mount')
          player.autoAttack(vic)
          send('queue opt parry')
          send('queue gstat wtf??? - stabbing it anyway')
					player.parryQueue = player.parryQueue + 2
  				murder.tankState = 'here'
    		end

    	end, 1)

    elseif (murder.tankState ~= 'leave-request-pending') then
      cecho('\n\n&lt;red&gt;MURDER: &lt;white&gt;wtf is the tank? (tank state: ' .. murder.tankState .. ')\n')
  	end

	end)

end


cecho(' &lt;-- &lt;white&gt;' .. murder.sleepMode .. '\n')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#42ff2d</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(A|An|The) (.*) drops .* asleep\.</string>
						<string>^(A|An|The) (.*) slips deeper into slumber\.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>resume murdering on mob kill</name>
					<script>if (murder.sleepMode ~= 'paused') then

	murder.sleepMode = 'next'

end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\s+(A|An|The) .*s DEAD!!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>reset state on move</name>
					<script>murder = murder or {}
if (murder.sleepMode ~= 'paused') then
  murder.sleepMode = 'next'
  murder.tankState = 'here'
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\[Exits:</string>
						<string>^\|\s+Exits:</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>A x is DEAD!!</name>
					<script>send('look')
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#41ff1f</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\s+(A|An|The) .*s DEAD!!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>missed mob</name>
					<script>-- this will fail if we are parrying
-- but mob should be reslept anyway

local target = common.dotCase(common.toMurderString(matches[3]))

if (murder.sleepMode == 'dance-pending' or murder.sleepMode == 'dancing') then

  -- try agian next sleep
  cecho('\n\n&lt;yellow&gt;MURDER: &lt;white&gt;missed mob during dancing phase\n\n')
  murder.sleepMode = 'dancing'

else

  player.autoAttack(target)

end

</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#38fbff</mFgColor>
					<mBgColor>#e000ff</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You miss (a|an|the) (.*)\.</string>
						<string>^You .+? (a|an|the) (.+?)('s.*)? inflicting no damage</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>mortal wound</name>
					<script>disableTrigger('mortal wound')
tempTimer(2, function()
  enableTrigger('mortal wound')
end)

local vic = common.dotCase(common.toMurderString(matches[3]))
cecho('\n&lt;yellow&gt;PARRY: &lt;white&gt;MORTAL WOUND')

if (murder.tankState == 'here') then
	-- can't do anything at this stage as mage is in combat and can't leave
	send('gstat you should not be ere (might o hit that one too hard)')
  common.setParryState(false, 'sleepmode: mortal wound (tank in room)', function ()
    -- player.autoAttack(vic)
  end)
else

  send('gstat abort abort, mortal wound detected!')

	-- send('opt parry &amp; stand &amp; k ' .. vic .. ' &amp; queue opt parry')
  common.onNextEvent(common.events.PARSED_PROMPT, function ()
    -- any queued parries will have been dequeued.
    -- player.parryQueue = 0
    common.setParryState(false, 'sleepmode: mortal wound', function ()
      -- player.autoAttack(vic)
      -- send('queue gstat return ' .. vic)
    end)
  end)
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(A|An|The) (.*) is mortally wounded, and will die soon, if not aided.</string>
						<string>^(A|An|The) (.*) is incapacitated and will slowly die, if not aided.</string>
						<string>^(A|An|The) (.*) is stunned, but will probably recover.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>tells the group to move</name>
					<script>if (murder.sleepMode ~= 'paused') then
	murder.sleepMode = 'next'
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(An? .+?|The .+?|\w+) reports group status[^:]*: "meet at (\d+)"</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>sleep failed</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Nothing happens.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Assist on Exits</name>
					<script>if (player.nextTarget) then
	player.autoAttack(player.nextTarget)
	player.nextTarget =  nil
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>[Exits:</string>
						<string>^\|\s+Exits:</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>mob isn't here?</name>
					<script>cecho('&lt;red&gt; &lt;-- mob missing?!\n')
if (murder.sleepMode ~= 'paused') then
	murder.sleepMode = 'next'
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>The room doesn't contain any beings matching</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>get full if under x%</name>
					<script>local amt =  tonumber(matches[3]) / 100


local getFull = false


local pFullTrig = tempRegexTrigger([[^\w+ reports group status[^:]*: "getting full"]], function ()
	getFull = true
	send('gstat righto')
end, 1)


tempTimer(3, function ()

	killTrigger(pFullTrig)

	if (getFull) then

  	send('sit couch &amp; sit chair &amp; sit pad &amp; sit boulder')
  	expandAlias('sl')
  	common.onFull( function ()
  		expandAlias('st')

  		tempTimer(3, function ()
  			player.gettingFull = false
  			expandAlias('gstat ready (' .. player.name .. ')')
  		end)

    end)

	else

		send('gstat ready (' .. player.name .. ')')

	end


end)

</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^.* tells? (your|the) group[^:]*: "get full if under (\d+)% mana"</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>get full</name>
					<script>player.gettingFull = player.gettingFull or false

if (not player.gettingFull) then
	player.gettingFull = true
  send('ef &amp; dw &amp; dismount')

  tempTimer(2, function ()
  	send('sit couch &amp; sit chair &amp; sit pad &amp; sit boulder')
  	expandAlias('sl')
  	common.onFull( function ()
			expandAlias('st')
      send('mount')
    	-- expandAlias('give all.coin batso &amp; drop all.food &amp; get 2*food')

  		tempTimer(3, function ()
				player.gettingFull = false
  			expandAlias('gstat ready (' .. player.name .. ')')
  		end)

    end)
  end)

else
	cecho('\n&lt;green&gt;PREP: &lt;white&gt;already getting full\n')
end

</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^.* reports group status[^:]*: "(pfull|get full)"</string>
						<string>^.* tells? (?:your|the) group[^:]*: "(pfull|get full)"</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>dead thing</name>
					<script>-- send('skin corpse &amp; eat corpse &amp; get all &amp; drop all.corpse')
-- hope you are a troll or orc!
send('eat corpse')
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You receive \d+ experience points.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>snack break</name>
					<script>local vessel = player.vessel or 'leather.waterskin'

send('drink ' .. vessel .. ' &amp; drink ' .. vessel .. ' &amp; drink ' .. vessel .. ' &amp; queue give empty.' .. vessel .. ' ' .. group.leader)
send('queue gstat fill my ' .. vessel)
send('gstat snack me')
send('eat food &amp; eat food &amp; eat food &amp; eat food')
send('drop all.food &amp; get 4*food')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^.* reports group status[^:]*:\s+"snack break"$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>common</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Your throat feels dry.</name>
					<script>send('dw')

timedTempTrigger(0.5, 1, '^You cannot do that while sleeping\.$', function ()
	send('stand &amp; dw &amp; ef')
	tempTimer(1, function () send('sleep') end)
end)
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Your throat feels dry.</string>
						<string>^You are thirsty.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>^You are mildly hungry.</name>
					<script>send('eat corpse &amp; ef')

timedTempTrigger(0.5, 1, '^You cannot do that while sleeping\.$', function ()
	send('stand &amp; dw &amp; ef')
	tempTimer(1, function () send('sleep') end)
end)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You are mildly hungry.</string>
						<string>Your stomach rumbles with pangs of unnatural hunger.</string>
						<string>You are hungry.</string>
						<string>You are no longer afflicted by the hunger of the undead.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
						<integer>2</integer>
						<integer>2</integer>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>out of food</name>
					<script>disableTrigger('out of food')
display(player.hasFoodBasket)


tempTimer(3, function()
  enableTrigger('out of food')
end)

if (player.hasFoodBasket) then

  send('search basket &amp; eat food')

  -- You reach your hand into the basket and root around, but come up empty-handed.

elseif (player.caster) then



   if (common and common.getManaAndCast) then

    common.getManaAndCast(15, 'create food', '', false, function ()
  		send('eat food')
  	end)

  else

    timedTempTrigger(2, 1, '^You cannot do that while sleeping\.$', function ()
  		send('stand &amp; cast create food &amp; eat food')
    end)

    send('cast create food &amp; eat food')

  end




else
	send('gt out of food')
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Nothing found matching "food".</string>
						<string>You aren't carrying any items matching "food".</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>empty juice</name>
					<script>
disableTrigger('empty juice')

tempTimer(3, function()
  enableTrigger('empty juice')
end)


local vessel = common.dotCase(matches[2])

if player.hasSoupBarrel then

  send('gl &amp; get barr.soup loot &amp; fill empty.' .. player.vessel .. ' soup.barrel')
  send('put soup.barr loot &amp; pl &amp; dw') 
    
elseif (player.caster and gmcp.Char.Score.class == 'druid') then
  
  local cmd = 'cast dowse &amp; cast dowse &amp; ' ..
    'queue fill empty.' .. vessel .. ' puddle.clear &amp; drink puddle.clear'
    
    send(cmd)
    
    timedTempTrigger(3, 1, 'You cannot do that while sleeping\.$', function ()
  		  send('stand &amp; ' .. cmd .. ' &amp; queue sleep')
    end)
    
    timedTempTrigger(3, 1, 'Perhaps you should stand first\.$', function ()
  		  send('stand &amp; ' .. cmd)
    end)    


elseif (player.caster) then

  send('stand &amp; remove blanket')
  caster.createWater(vessel, function()
    send('drink ' .. vessel .. '.water')
  end, function()
    send('gstat help! i fucked up making water in ' .. vessel)
  end)

else

	send('gt out of juice')
  send('give empty.' .. vessel .. ' to Mohoonay')

end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^An? (.*) you are carrying is already empty.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>intro back</name>
					<script>local vic = matches[3]

send('queue lang vya &amp; queue intro ' .. vic)
send('queue lang human &amp; queue intro ' .. vic)
send('queue lang ogris &amp; queue intro ' .. vic)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>introduces (him|her)self as '(.+)'\.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>created bad water</name>
					<script>local vessel = common.dotCase(matches[2])

if player.caster and matches[3] ~= 'water' then

  timedTempTrigger(2, 1, '^You cannot do that while sleeping\.$', function ()
		send('stand &amp; remove blanket &amp; empty ' .. vessel .. ' &amp; cast create water .. ' .. vessel .. ' &amp; wear blanket &amp; sleep')
  end)

	send('empty ' .. vessel)
  send('remove blanket &amp; cast create water ' .. vessel)

else

  timedTempTrigger(2, 1, '^You cannot do that while sleeping\.$', function ()
  	send('stand &amp; drink ' .. vessel .. '.water &amp; sleep')
  end)

	send('drink ' .. vessel .. '.water')

end


 -- Nothing found matching "dark crystal goblet".</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^An? (.*) fills to overflowing with (.*).</string>
						<string>^An? (.*) fills partially up with (.*).</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>awakened by pain</name>
					<script>send('sl')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You are suddenly awakened by the feeling of pain.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>dying of thirst etc</name>
					<script>
common.getAffects(function (affects) 

  if (affects["You feel the hunger of the undead."] == "temporary") then
    cecho('\n\n&lt;red&gt;HUNGRY: &lt;white&gt;suffering from hunger of the undead!!!\n\n')
    send('eat corpse &amp; ef')
  else
    send('ct poor management has led me to quit due to hunger or thirst.')
    send('quit')
  end

end)


</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You are dying</string>
						<string>^You are starving to death!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>level info</name>
					<script>
selectString(matches[1],1)
replace(matches[2] .. common.commaCase(matches[3]) .. matches[4])
-- cecho(' &lt;- &lt;green&gt;replaced some numbers\n')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(You have acquired )(\d+)( experience points so far this level\.)$</string>
						<string>^(You need )(\d+)( experience points to gain level \d+\.)$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>+++ You cast create food +++</name>
					<script>send('eat food')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>+++ You cast create food +++</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You happily follow x.</name>
					<script>-- depricated.. using gmcp

if (matches[2] ~= 'it') then
  send('group')
end
-- 
-- if (matches[2] ~= 'it') then
  -- group.leader = matches[2]
-- end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You .* follow (\w+).</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>magic sleep/silence wears off</name>
					<script>send('stand &amp; group')
murder.scan('woke up')
player.equippingSet = nil
if (healer and healer.clearQueued) then
  healer.clearQueued()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You no longer feel sleepy.</string>
						<string>You feel the cloak of silence enveloping you lift.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>sprawling</name>
					<script>disableTrigger('sprawling')
send('stand &amp; ord all stand')
tempTimer(2, function () enableTrigger('sprawling') end)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^A(n)? .* sends you sprawling on the ground!</string>
						<string>^A(n)? .* delivers a quick kick, knocking you down to the ground!</string>
						<string>^Perhaps you should stand first.</string>
						<string>^The fall .* you!</string>
						<string>^.* knocks you head over heels!$</string>
						<string>^You fall</string>
						<string>sending you sprawling!$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>teamwork</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>meet at x</name>
					<script>local rnum = matches[3]
send('look')

tempTimer(2, function ()

  tfe.gotoRoom(rnum, function ()
    	tempTimer(1, function ()
    		send('gstat ' .. player.name .. ' is now at ' .. tostring(tfe.roomInfo.vnum))
    	end)
  end)

end)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(An? .+?|The .+?|\w+) reports group status[^:]*: "meet at (\d+)"</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>set next assist mob</name>
					<script>local vic = matches[3]
player.nextTarget = vic
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(.*) reports? group status[^:]*: "next is (.*)"</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>set next room deets</name>
					<script>-- local vic = matches[3]
-- player.nextTarget = vic

-- You report group status: "next room has 7 targets, aoe-safe, destroy: gelatinous.cube"
-- You report group status: "next room has 2 targets, no-aoe, attack: wolf.flam, cc-order: 1.monstrou.glassy.ooze,1.wolf.flam"

local tank = matches[2]

if (tank == 'You') then 
  tank = player.name
end

local nextRoom = {
  targetCount = tonumber(matches[3]),
  aoe = matches[4] == 'aoe-safe',
  nasty = matches[5] == 'destroy',
  target = matches[6],
  ccMobs = matches[7],
}

if (group.leader == tank) then
  player.nextRoom = nextRoom
else
  cecho('\n\n&lt;red&gt;TEAMWORK:&lt;white&gt; next room command came from non tank\n\n')
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(.*) reports? group status[^:]*: "next room has (\d+) targets?, (aoe-safe|no-aoe), (attack|destroy): (.*?), cc-order: (.*)"$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>go to x</name>
					<script>local pname = matches[3]
local rnum = matches[4]

if (pname == player.name) then
	send('gt omw')

  tempTimer(2, function ()

    tfe.gotoRoom(rnum, function ()
    	tempTimer(1, function ()
    		send('gstat ' .. player.name .. ' is now at ' .. tostring(tfe.roomInfo.vnum))
    	end)
    end)

  end)
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(An? .+?|The .+?|\w+) reports group status[^:]*: "(\w+) go to (\d+)"</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>where are you</name>
					<script>local pname = matches[3]

if (pname == "" or pname == player.name) then
   send('gstat ' .. player.name .. ' is at ' .. tostring(tfe.roomInfo.vnum))
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(An? .+?|The .+?|\w+) reports group status[^:]*: "(\w*) ?where are you\?"</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>time for x</name>
					<script>expandAlias(matches[4])</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(An? .+?|The .+?|\w+) tells the group[^:]*: "time (for|to) (.*)"</string>
						<string>^(You) tell your group[^:]*: "time (for|to) (.*)"</string>
						<string>^(An? .+?|The .+?|\w+) reports? group status: "time (for|to) (.*)"</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>x time for y</name>
					<script>
if (matches[3] == player.name) then
	expandAlias(matches[4])
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(An? .+?|The .+?|\w+) tells the group[^:]*: "(\w+) can you (.*)"</string>
						<string>^(An? .+?|The .+?|\w+) reports group status[^:]*: "(\w+) can you (.*)"</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>someone joins a group</name>
					<script>send('group')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You join (.*)'s group.</string>
						<string>^(.*) joins (.*)'?s? group.</string>
						<string>^You remove (.*) from your group.</string>
						<string>^You leave (.*)'s group.</string>
						<string>^(.*) stops following you.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>pause/resume murder mode</name>
					<script>if (matches[2] == 'paused') then

	murder.sleepMode = 'paused'

	common.setParryState(true, 'murder mode paused', function ()
		send('gstat holding off on the murdering')
	end, true)

else
	common.setParryState(false, 'murder mode resumed', function ()
		send('gstat resuming the murdering')
	end, false)

	murder.sleepMode = 'next'
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\S+ reports group status[^:]*: "murder time (paused|resumed)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>command by leader or authority figure</name>
					<script>
local from = matches[2]
local cmd = matches[3]

if(from == group.leader or clan.acceptableMasters[from]) then

  cecho('\n&lt;green&gt;TEAMWORK: &lt;white&gt;command issued by ' .. from .. ': ' .. cmd)
  if (rex.find(cmd, [[^(t|te|tel|tell|jun|junk|ti|tit|titl|title) ]]) and not rex.find(cmd, [[^tell ]] .. from .. ' ')) then
    send('tell ' .. from .. ' 403 Forbidden')
  elseif (rex.find(cmd, [[;]])) then
    send('tell ' .. from .. ' 403 Forbidden')    
  else 
    send('tell ' .. from .. ' running command: ' .. matches[3], false)
    expandAlias(matches[3]) 
  end

else
	cecho('&lt;red&gt;TEAMWORK: &lt;white&gt;command issued by non leader')
  send('tell ' .. from .. ' 401 Not Authorized')
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^([A-Za-z]+) tells you:\s*"do (.+)"$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>condition report</name>
					<script>if (#gmcp.Char.Status.conditions == 1 and gmcp.Char.Status.conditions[1]) then
	send('gstatus healthy - ' .. player.name )
else
  for idx, state in pairs(gmcp.Char.Status.conditions) do
  	if (state ~= 'sober') then
  		send('gstatus ' .. state .. ' - ' .. player.name )
      if (state == 'hungry') then
        send('ef &amp; ef')
      end
  	end
  end
end

</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^.* reports? group status: "condition report"$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>conditional prep</name>
					<script>-- display(matches)

local mana = matches[2]
local heals = matches[3]
local storms = matches[4]



local healers = {
  cleric = true
}

local casters = {
  druid = true,
  paladin = true,
  mage = true,
}

local stormers = {
  druid = true,
}

local class = gmcp.Char.Score.class

if (healers[class] and heals ~= '') then
  if (healer.avg_heal * healer.getPrepped() &lt; tonumber(heals)) then
    send('gstat need prep')
  end
end

if (casters[class] and mana ~= '') then
  if (gmcp.Char.Vitals.en / gmcp.Char.Vitals.maxen &lt; tonumber(mana)/100) then
    send('gstat need prep')
  end
end

if (stormers[class] and storms ~= '') then
  if (not player.stormSpell or not player.prepped[player.stormSpell] or player.prepped[player.stormSpell] &lt; tonumber(storms)) then
    send('gstat need prep')
  end
end

</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^[^"]* reports? group status: "report if(?: mana &lt; (\d+)%)?,?(?: heals &lt; (\d+)hp)?,?(?: storms &lt; (\d+))?"</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>log messages</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>prac/imp</name>
					<script>-- ** You improve at escape. **
-- ** You gain a practice point from escape. **

common.chatConsole:cecho('Other', '&lt;yellow&gt;' .. getTime(true, "hh:mm:ss") .. ': &lt;white&gt;' .. matches[1] .. "\n")

if (matches[2] == 'improve at') then
	send('save')
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\*\* You (gain a practice point from|improve at) (.*)\. \*\*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>player status</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>not tripping anymore</name>
					<script>player.tripping = false</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>The world returns to normal color.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>tripping</name>
					<script>player.tripping = true</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You see colors.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>standing status</name>
					<script>player.position = 'standing'</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You wake and stand up.</string>
						<string>^You stand up.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>sleep status</name>
					<script>player.position = 'sleeping'</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You lie down and go to sleep</string>
						<string>^You go to sleep .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>resting status</name>
					<script>player.position =  'resting'</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You wake and sit up.</string>
						<string>^You sit down.*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Parry set to x.</name>
					<script>if (matches[2] == 'true') then
	player.parry = true
else
	player.parry = false
end

player.parryQueue = (player.parryQueue or 1) - 1
cecho('&lt;yellow&gt; &lt;-- parry queue -- (' .. player.parryQueue .. ')')

if player.parryQueue &lt; 0 then
  player.parryQueue = 0
  cecho('\n&lt;red&gt;PARRY: &lt;white&gt;attempted to reduce queue below zero\n')
end

raiseEvent(common.events.PARRY_STATE_CHANGE)
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Parry set to (true|false)\.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Combat</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>inc mobs fighting</name>
					<script>combat.add(matches[3])</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(An?|The) (.*) leaps to attack you!$</string>
						<string>^(An?|The) (.*) counterattacks you!</string>
						<string>^(An?|The) (.*) says (in primal): "Have at you, then!"</string>
						<string>^(An?|The) (.*) says (in primal): "Please....please...h-help me..."</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>dec mobs fighting</name>
					<script>combat.remove(matches[2])</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You receive \d+ experience points\.</string>
						<string>^An? (.*) blindly flees (north|east|south|west|up|down).</string>
						<string>^An? (.*) vanishes in the blink of an eye!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>blocked|arrival|slept - extend room check</name>
					<script>combat.extendRoomCheck()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#0900ff</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(A|An|The) (.*) is blocking the exit to the (north|east|south|west|up|down)\.$</string>
						<string>^(A|An|The) (.*) arrives from the (north|east|south|west|up|down)\.$</string>
						<string>^(A|An|The) (.*) drops .* asleep\.</string>
						<string>You begin casting sleep.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>disarmed</name>
					<script>echo('disarmed!!!')
send('wear ' .. common.dotCase(matches[3]))</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\+\+\+ .+ disarms your (enchanted )?([^!]+)!  \+\+\+</string>
						<string>thrusts (his|her|their) shield against your ([^,]*),</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>counterattack</name>
					<script>combat.counterattack(matches[2])</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You counterattack an? (.*)!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>slept a mob</name>
					<script>combat.sleeping(matches[3])</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(A|An|The) (.*) drops .* asleep\.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>combat_parsing</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Caster assignment</name>
					<script>
-- `echo Mojune casts conflagration.
-- `echo A raging inferno *** DISINTEGRATES *** [437] a blue-skinned demon!  [ bleeding freely ]

-- Gnoggh unleashes a dissonant assault at a gigantic spider!
-- The head-splitting dissonance * THUNDERS * [196] a gigantic spider!  [ badly wounded ]

local caster = matches[2]
local spell = matches[3]

if (caster == 'You') then
  caster = player.name
end

if not rex.find(spell, [[^(cure|heal|restoration|group|mists|purify|neutralize|fear|paralyze|group|slow|web|probe|silence)]]) then

  combat.dealer = caster
  combat.type = 'spell'
  combat.spell = spell
  combat.target = ''

else

  cecho('&lt;orange&gt; &lt;- non damage spell\n')
  combat.dealer = caster
  combat.type = ''
  combat.spell = ''
  combat.target = ''

end




</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>2</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#dee930</mFgColor>
					<mBgColor>#110092</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(\w+) casts (.*)\.</string>
						<string>^\+\+\+ (You) cast (.*) \+\+\+</string>
						<string>^(\w+) unleashes a (dissonant assault)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Melee assignmnet</name>
					<script>
-- You deflect a blue-skinned demon's obsidian claw rake and smash your shield into him!
-- Your shield strike SAVAGES [41] a blue-skinned demon!  [ covered in blood ] &lt;- proc Darion : 41

                                                                                        -- .
-- Darion deflects a blue-skinned demon's obsidian claw rake and smashes him with his shield!
-- Darion's shield strike SAVAGES [41] a blue-skinned demon!  [ covered in blood ]

local caster = matches[2]
local spell = matches[3]

if (caster == 'You') then
  caster = player.name
end

combat.dealer = caster
combat.type = 'melee'
combat.spell = ''
combat.target = ''

</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(You|[A-Z][a-z]+)'?s? [^[]+[!.]$   </string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>unassigned damage</name>
					<script>
-- removing things with 's in em due to tyrant's wife

-- ^((\S+).*?) (\** ?\w+ ?\**) \[(\d+)\]\s*((\S+).*)'s.*[!.]\s+\[\s+(.*?)\s+\]$


-- these should be legit:

-- The sword's thrust devastates [25] a beautiful witch!  [ slightly scratched ]
-- A raging inferno *** DISINTEGRATES *** [437] a blue-skinned demon!  [ bleeding freely ]
-- Your fire shield singes [1] a flying snake.  [ several wounds ]

-- A raging inferno ** INCINERATES ** [278] a tyrant's wife!



-- this is a problem after someone has cast a non damage spell:
-- A darkling's oily, musty secretion hits [3] a grasshopper mouse's small brown body.  [ several wounds ]

-- shoulld not match any of these:

-- Darion's blow MUTILATES [56] an orcish monk of the hidden order!  [ some cuts ]
-- The brilliant bolt of lightning ELECTRIFIES [78] Mojune!  [ few bruises ]

-- An orcish monk of the hidden order's spider kick DISEMBOWELS [81] your head!
-- A monk of the hidden order's serpent strike CRIPPLES [52] you!
-- The brilliant bolt of lightning ELECTRIFIES [78] Mojune!  [ few bruises ]

-- damage before mob
-- Darion's blow MUTILATES [56] an orcish monk of the hidden order!  [ some cuts ]
-- Darion's blow MUTILATES [56] an orcish monk of the hidden order's muscular arm!  [ some cuts ]

-- damage after mob
-- Your strike hits a red efreet's billowing flames [3].  [ slightly scratched ]
-- Your strike hits a red efreet [3].  [ slightly scratched ]


-- local caster = player.name
local spell = matches[2]
local spellFirstWord = matches[3]
local damageString = matches[4]
local damage = tonumber(matches[5])
local target = matches[6]
local targetFirstWord = matches[7]
local targetState = matches[8]



-- spell first word could be a group member!
if (spellFirstWord == 'You' or spellFirstWord == 'Your') then
  spellFirstWord = player.name
end
-- replace any 's i.e (Darion's) crushing blow -&gt; Darion
spellFirstWord = spellFirstWord:gsub("'?s?[.!]?$", "")

-- targetFirstWord could be a group member
if (targetFirstWord == 'you' or targetFirstWord == 'your') then
  targetFirstWord = player.name
end
-- replace any 's i.e (Darion's) crushing blow -&gt; Darion
targetFirstWord = targetFirstWord:gsub("'?s?[.!]?$", "")


if (group.members[spellFirstWord]) then
  -- cecho('\nGroup mmember attack, not unassigned...\n')
  combat.dealer = spellFirstWord
  combat.type = 'melee'
  combat.spell = ''
  combat.target = target

  if rex.match(damageString, [[^(scratches|grazes|hits|injures|wounds|mauls|decimates|devastates|maims|SAVAGES|CRIPPLES|MUTILATES|DISEMBOWELS|\* DISMEMBERS \*|\* EVISCERATES \*|\* MASSACRES \*|\* PULVERIZES \*|\*\* DEMOLISHES \*\*|\*\* EXTIRPATES \*\*|\*\*\* OBLITERATES \*\*\*|\*\*\* ERADICATES \*\*\*|\*\*\* ANNIHILATES \*\*\*)$]]) then
     -- this was melee damage and will be picked up elsewhere
     return
  else

    -- setting combat type to proc for any non melee damage done directly by a player.
    -- this should allow us to ignore ion/ice shield etc type damage when determining who a player is hitting
    combat.type = 'proc'

  end

end

if (group.members[targetFirstWord]) then
  -- cecho('\nmob attacking group member, not unassigned...\n')
  combat.type = ''
  return
end


if (combat.type and combat.type ~= '') then

  local attackData = {
    subject = combat.dealer,
    damageType = combat.type,
    move = spell,
    mob = target,
    damage = damage,
    mobState = targetState,
  }

  if (combat.type == 'spell') then
    attackData.move = combat.spell
    combat.type = ''
  else
    attackData.damageType = 'proc'
  end

  if (group.members[attackData.subject]) then
    raiseEvent(common.events.COMBAT_ATTACK, attackData)
  else
    cecho('&lt;orange&gt; &lt;- non party member fighting\n')
  end

else
  cecho('&lt;- &lt;red&gt;COMBAT: &lt;white&gt;unsure who to allocate this damage to\n')
end

</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>4</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#dee930</mFgColor>
					<mBgColor>#10341f</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^((\S+).*?) (\** ?\w+ ?\**) \[(\d+)\]\s*((\S+).*)[!.]\s+\[\s+(.*?)\s+\]$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>hit - non attack</name>
					<script>-- Mohoonay's attack misses an ogre miner.
-- Shazzul hits an imposing fire giant witch-doctor with a power strike!

-- ^(You|Your|[A-Z][a-z]+?) hits (.*) with a (great cleave|cleave|power strike|critical hit)[!.]$
-- Shazzul parries a large shaggy wolf's attack, leaving her vulnerable to a counterattack!

-- You attempt to charge a minotaur guardian, but miss and fall down.
-- Uduvrin attempts to charge an elven city guard, but he misses and falls down.

-- Taldoran smashes the stone, but reveals nothing.
-- Taldoran smashes the stone with all his might, revealing a small opening below it.

-- Moira kicks an ethereal blue stag, knocking him down to the ground.
-- With a well timed kick you knock an elvish field worker down to the ground!

-- Taldoran places his hand on the plaque and a bright light engulfs him!
-- ^(You|[A-Z][a-z]+) places his hand on the plaque and a bright (light engulfs) (.*)!

local subject = matches[2]
local move = matches[3]
local mob = matches[4]

local attacks = {
  ['great cleave'] = true,
  ['cleave'] = true,
  ['power strike'] = true,
  ['critical hit'] = true,
  ['counterattack'] = true,
  ['fall down'] = true,
  ['falls down'] = true,
  ['revealing'] = true,
  ['reveals nothing'] = true,
  ['knocking'] = true,
}

local swapMove = {
  ['knocking'] = 'trip',
  ['knock'] = 'trip'
}

-- swap mob and move if required
if (attacks[mob]) then
  local temp = mob
  mob = move
  move = temp
end

if (swapMove[move]) then
  move = swapMove[move]
end


if (subject == 'You' or subject == 'Your' or subject == 'With') then
  subject = player.name
end

-- replace any 's i.e (Darion's) crushing blow -&gt; Darion
subject = subject:gsub("'s$", "")


local attackData = {
  subject = subject,
  move = move,
  mob = mob,
  damage = 0,
  damageType = 'no-damage',
}

-- display(attackData)

if (group.members[attackData.subject]) then
  raiseEvent(common.events.COMBAT_ATTACK, attackData)
else
  cecho('&lt;orange&gt; &lt;- non party member fighting\n')
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#e13b95</mFgColor>
					<mBgColor>#1c1873</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(You|[A-Z][a-z]+) leaps? to (attack) (.*)[!.]$</string>
						<string>^(You|[A-Z][a-z]+) (miss)e?s? (.*)[!.]$</string>
						<string>^(You|[A-Z][a-z]+) (counterattack|critically hit|)s? (.*)[!.]$</string>
						<string>^(You|Your|[A-Z][a-z]+?)'?s? (great cleave|cleave|power strike) hits (.*)[!.]$</string>
						<string>^(Your|[A-Z][a-z]+)'s attack (miss)e?s? (.*)[!.]$</string>
						<string>^(You|Your|[A-Z][a-z]+?) hits (.*) with a (great cleave|cleave|power strike|critical hit)[!.]$</string>
						<string>^(You|[A-Z][a-z]+) (gouges) (.*) in the eye[!.]$</string>
						<string>^(You|[A-Z][a-z]+) calls upon the (shadows to deestroy) (.*)[!.]$</string>
						<string>^(You|[A-Z][a-z]+) parries (.+?)'?s? attack, leaving .* vulnerable to a (counterattack)[!.]$</string>
						<string>^(You|[A-Z][a-z]+) attempts? to charge (.*), but s?h?e? ?misse?s? and (falls? down)[!.]$</string>
						<string>^(You|[A-Z][a-z]+) (smash)e?s? the stone, but (reveals nothing).</string>
						<string>^(You|[A-Z][a-z]+) (smash)e?s? the stone with all his might, (revealing)</string>
						<string>^(You|[A-Z][a-z]+) kicks? (.*), (knocking) \w+ down</string>
						<string>^(With) a well timed kick you (knock) (.*) down</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>hit - damage first</name>
					<script>-- damage before mob

-- Darion's blow MUTILATES [56] an orcish monk of the hidden order!  [ some cuts ]
-- Darion's blow MUTILATES [56] an orcish monk of the hidden order's muscular arm!  [ some cuts ]



local subject = matches[2]

if (subject == 'You' or subject == 'Your') then
  subject = player.name
end

-- replace any 's i.e (Darion's) crushing blow -&gt; Darion
subject = subject:gsub("'s$", "")

combat.dealer = subject
combat.type = 'melee'
combat.spell = ''
combat.target = ''


local attackData = {
  subject = subject,
  move = matches[3],
  mob = matches[6],
  damage = tonumber(matches[5]),
  damageType = 'melee',
  mobState = matches[7],
}

if (group.members[attackData.subject]) then
  raiseEvent(common.events.COMBAT_ATTACK, attackData)
else
  cecho('&lt;orange&gt; &lt;- non party member fighting\n')
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#e13b95</mFgColor>
					<mBgColor>#1c1873</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(Your|[A-Z][a-z]+'s) (.+) (scratches|grazes|hits|injures|wounds|mauls|decimates|devastates|maims|SAVAGES|CRIPPLES|MUTILATES|DISEMBOWELS|\* DISMEMBERS \*|\* EVISCERATES \*|\* MASSACRES \*|\* PULVERIZES \*|\*\* DEMOLISHES \*\*|\*\* EXTIRPATES \*\*|\*\*\* OBLITERATES \*\*\*|\*\*\* ERADICATES \*\*\*|\*\*\* ANNIHILATES \*\*\*) \[(\d+)\] (.*)'s .*[!.]\s+\[\s*(.+?)\s*\]$</string>
						<string>^(Your|[A-Z][a-z]+'s) (.+) (scratches|grazes|hits|injures|wounds|mauls|decimates|devastates|maims|SAVAGES|CRIPPLES|MUTILATES|DISEMBOWELS|\* DISMEMBERS \*|\* EVISCERATES \*|\* MASSACRES \*|\* PULVERIZES \*|\*\* DEMOLISHES \*\*|\*\* EXTIRPATES \*\*|\*\*\* OBLITERATES \*\*\*|\*\*\* ERADICATES \*\*\*|\*\*\* ANNIHILATES \*\*\*) \[(\d+)\] (.+?)[!.]\s+\[\s*(.+?)\s*\]$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>hit - damage last</name>
					<script>
-- damage after mob
-- Your strike hits a red efreet's billowing flames [3].  [ slightly scratched ]
-- Your strike hits a red efreet [3].  [ slightly scratched ]

local subject = matches[2]

if (subject == 'You' or subject == 'Your') then
  subject = player.name
end

-- replace any 's i.e (Darion's) crushing blow -&gt; Darion
subject = subject:gsub("'s$", "")

combat.dealer = subject
combat.type = 'melee'
combat.spell = ''
combat.target = ''


local attackData = {
  subject = subject,
  move = matches[3],
  mob = matches[5],
  damage = tonumber(matches[6]),
  damageType = 'melee',
  mobState = matches[7],
}

if (group.members[attackData.subject]) then
  raiseEvent(common.events.COMBAT_ATTACK, attackData)
else
  cecho('&lt;orange&gt; &lt;- non party member fighting\n')
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#e13b95</mFgColor>
					<mBgColor>#1c1873</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(Your|[A-Z][a-z]+'s) (.+) (scratches|grazes|hits|injures|wounds|mauls|decimates|devastates|maims|SAVAGES|CRIPPLES|MUTILATES|DISEMBOWELS|\* DISMEMBERS \*|\* EVISCERATES \*|\* MASSACRES \*|\* PULVERIZES \*|\*\* DEMOLISHES \*\*|\*\* EXTIRPATES \*\*|\*\*\* OBLITERATES \*\*\*|\*\*\* ERADICATES \*\*\*|\*\*\* ANNIHILATES \*\*\*) (.+)'s .* \[(\d+)\][!.]\s+\[\s*(.+?)\s*\]$</string>
						<string>^(Your|[A-Z][a-z]+'s) (.+) (scratches|grazes|hits|injures|wounds|mauls|decimates|devastates|maims|SAVAGES|CRIPPLES|MUTILATES|DISEMBOWELS|\* DISMEMBERS \*|\* EVISCERATES \*|\* MASSACRES \*|\* PULVERIZES \*|\*\* DEMOLISHES \*\*|\*\* EXTIRPATES \*\*|\*\*\* OBLITERATES \*\*\*|\*\*\* ERADICATES \*\*\*|\*\*\* ANNIHILATES \*\*\*) (.+) \[(\d+)\][!.]\s+\[\s*(.+?)\s*\]$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>player hit</name>
					<script>-- The flying pages MUTILATE [64] Darion!  [ some cuts ]
-- A palace librarian's quick bite MUTILATES [66] Darion's body!  [ some cuts ]

-- An orcish palace servant's wild kick MUTILATES [57] your hand!

-- The boiling water * IMMOLATES * [116] you!


local subject = matches[3]
local amount = tonumber(matches[2])

if (subject == 'you' or subject == 'your') then
  subject = player.name
end

if (group.members and group.members[subject]) then

  local attackData = {
    subject = subject,
    amount = amount,
  }

  raiseEvent(common.events.COMBAT_PLAYER_HIT, attackData)
end



</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#133d0e</mFgColor>
					<mBgColor>#d9f413</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>\S+\s+\[(\d+)\]\s+(\w+?)['.! ]</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>sleep tracking</name>
					<script>-- Mohoonay casts sleep.
-- An ogre miner looks drowsy but quickly shrugs it off.

-- An ogre miner drops to the ground asleep.

-- A gnomish captain slips deeper into slumber.

-- Mohoonay casts sleep.
-- An ogre miner looks incredibly tired!
-- An ogre miner drops to the ground asleep.

if (combat.type and combat.type == 'spell' and combat.spell == 'sleep' and group.members[combat.dealer]) then

  local attackData = {
    subject = combat.dealer,
    damageType = combat.type,
    move = 'sleep - ' .. matches[3],
    mob = matches[2],
    damage = 0
  }

  combat.type = ''
    
  raiseEvent(common.events.COMBAT_ATTACK, attackData)

end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(.*) looks drowsy but quickly (shrugs) it off\.$</string>
						<string>^(.*) drops .* (asleep)\.$</string>
						<string>^(.*) slips (deeper) into slumber\.$</string>
						<string>^()(Nothing) happens\.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>improve-things</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>improve ice shie</name>
					<script>improves.improveLeech('ice shield')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>The ice crystals whirling around you stop and fall to the ground.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>improve displace</name>
					<script>improves.improveLeech('displace')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You are no longer displaced.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>improve ion shield</name>
					<script>improves.improveLeech('ion shield')
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Your shield of electricity sparks once and fades away.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>imp haste</name>
					<script>improves.improveLeech('haste')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Your movements slow and the world returns to normal speed.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>invulnerability</name>
					<script>improves.improveLeech('invulnerability')
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You feel more vulnerable to injury.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>mysic shield</name>
					<script>improves.improveLeech('mystic shield')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Your outline fades.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>hypermetabolism</name>
					<script>improves.improveLeech('hypermetabolism')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Your heart-rate decreases as your body loses energy.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>attacks (non casting)</name>
					<script>send(improves.getImproveSpell())</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Your (pierce|thrust|gore|stab|swipe|smash|swing|jab|kick)</string>
						<string>^You (miss|swing)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>ogre strength</name>
					<script>improves.improveLeech('ogre strength')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You feel yourself returning to normal strength.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>float</name>
					<script>improves.improveLeech('float')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You feel subject to gravity once more.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>xp calc</name>
				<script>xp_record = xp_record or {}

table.insert(xp_record, {dt = getEpoch(), val = tonumber(matches[2])})</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You receive (\d+) experience points\.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>You have been KILLED!!</name>
				<script>send('gstat I died in room #' .. tostring(gmcp.Room.Info.vnum))
if (group.leader == player.name) then
  murder.groupDo('recite recall')
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You have been KILLED!!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>puzzles</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>solve hanoi</name>
					<script>local json = common.json

cecho('&lt;green&gt; &lt;---&lt;white&gt; hello plates!!\n')

local plates = {
  {}, {}, {}
}

moveCursor(0, getLineNumber())

for  i=1, 5 do
  moveCursorUp(1)
  selectCurrentLine()
  local text = getSelection()
  -- table.insert(lines, text)
  
  for m in rex.gmatch(text, [[\s\*+\s]]) do
  
    local start, finish = text:find(m, nil, true)
    
    start = start + 1;
    finish = finish;
    length = finish - start
    center = start + ( (length - 1) / 2)
    
    if (center == 40) then
      table.insert(plates[3], length)
    elseif (center == 24) then
      table.insert(plates[2], length)
    elseif (center == 8) then
      table.insert(plates[1], length)
    end
    
  end 
  
end

if (#plates[3] == 5) then
  
  send('gstat puzzle solved')
  player.hanoi = nil
  
else

  local swap = function (x,y)
    -- tempTimer(0.1, function()
      if (#plates[x] == 0) then
        send('move ' .. y .. ' ' .. x)
        player.hanoi_lastmoved = x
      elseif (#plates[y] == 0) then
        send('move ' .. x .. ' ' .. y)
        player.hanoi_lastmoved = y
      elseif plates[x][#plates[x]] &lt; plates[y][#plates[y]] then
        send('move ' .. x .. ' ' .. y) 
        player.hanoi_lastmoved = y       
      elseif plates[x][#plates[x]] &gt; plates[y][#plates[y]] then
        send('move ' .. y .. ' ' .. x)
        player.hanoi_lastmoved = x
      else
        cecho('\n\nsomething is fucked\n\n')
      end
      -- display(common.json.encode(plates), 'swapping ' .. tostring(x) .. ' and ' .. tostring(y))
    -- end)
  end

-- make the legal move between pegs A and C (in either direction),
-- make the legal move between pegs A and B (in either direction),
-- make the legal move between pegs B and C (in either direction),
-- repeat until complete.


  -- player.hanoi = player.hanoi or -1
  -- player.hanoi = (player.hanoi + 1) % 3

  -- if (player.hanoi == 0) then
   -- swap(1, 3)
  -- elseif (player.hanoi == 1) then
    -- swap(1, 2)
  -- elseif (player.hanoi == 2) then
    -- swap(2,3)
  -- else
    -- cecho('fail time!')
  -- end
  
  -- if all are on plate 1, move first bit to plate 3
  player.hanoi_lastmoved = player.hanoi_lastmoved or -1
  
  local isEven = function (x)
    if (((x+1)/2) % 2 == 0) then
      return true
    end
    return false
  end
 
   
  local getVal = function(x) 
    if #plates[x] == 0 then return 0 end
    return plates[x][#plates[x]]
  end
  
  
  local swapValue = function(x, y)
    
    if (x == player.hanoi_lastmoved) then return -1 end
    
    if (x == y) then return -1 end
    
    local valx = getVal(x)
    local valy = getVal(y)
    
    if valx == 0 then return -1 end
    
    if valy == 0 then return 0 end

    if valx &gt; valy then return -1 end
    
    if isEven(valx) and isEven(valy) then return -1 end
    
    if (not isEven(valx)) and (not isEven(valy)) then return -1 end
    
    return valy
  
  end

  
  if (#plates[1] == 5) then
    
    send('move 1 3')
    player.hanoi_lastmoved = 3
  
  elseif (#plates[2] == 5) then
    
    send('move 2 3')
    player.hanoi_lastmoved = 3
    
  else
    
    
    local bestVal = -1
    local bestX, bestY
    
    for i=1,3 do 
      for j=1,3 do
        local thisSwapVal = swapValue(i,j)
        if (thisSwapVal &gt; bestVal) then
          bestVal = thisSwapVal
          bestX = i
          bestY = j
          -- display(bestVal,getVal(bestX),getVal(bestY))
        end
      end
    end
    -- 
    -- display(common.json.encode(plates), 'swapping bestval:' .. tostring(bestVal) .. ' -&gt; ' .. tostring(bestX) .. ' and ' .. tostring(bestY))
    -- display(swapValue(bestX, bestY))
    
    if (bestVal ~= -1) then
      send('move ' .. tostring(bestX) .. ' ' .. tostring(bestY))
      player.hanoi_lastmoved = bestY
    else
      cecho('\nNo valid moves!!! - moving at random\n\n')
      for i=1,3 do 
        for j=1,3 do
          if (i ~= j and i ~= player.hanoi_lastmoved and getVal(i) &lt; getVal(j)) then
            send('move ' .. tostring(i) .. ' ' .. tostring(j))
            player.hanoi_lastmoved = j
            return
          end
        end
      end
    end
  end

end






-- "   *********          ***              *       "</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>\_____________/ \_____________/ \_____________/</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>solve sliding tile puzzle - js</name>
					<script>tp = tp or {}

tp.nodes = tp.nodes or { {}, {}, {}, {} }


tp.y = tp.y or 0
tp.y = tp.y + 1


if (tp.y == 1) then
  
  cecho('&lt;green&gt; &lt;-- start tile puzzle\n')
  
  -- setup trig to parse lines
  tp.parseLines = tempRegexTrigger([[\|\s+(\d*)\s+\|\s+(\d*)\s+\|\s+(\d*)\s+\|\s+(\d*)\s+\|]], function()
  
    for idx=1, 4 do
      
      -- display(idx)
      local thisVal = matches[idx+1]
      
      
      if (thisVal ~= '') then
        thisVal = tonumber(thisVal)
      end

      
      table.insert(tp.nodes[tp.y], thisVal);
      
      
      
      
    end

    
  end)  
end



if (tp.y == 5) then


  cecho('&lt;green&gt; &lt;-- end tile puzzle\n')
  
  killTrigger(tp.parseLines)
  
  display(tp)
  
  local url = catalog.serverUrl .. "/puzzle/tile"
  -- local url = 'http://localhost:3000' .. "/puzzle/tile"


  -- first we create something to handle the success, and tell us what we got
  registerAnonymousEventHandler('sysPostHttpDone', function(event, rurl, response)
    
    if rurl == url then 

      local solution = common.json.decode(response)
      
      if (#solution == 0) then
      
        send('shake puzzle &amp; look puzzle')
        
      else
        
        disableTrigger('solve sliding tile puzzle - js')
        
        tempBeginOfLineTrigger('Success!', function()
          enableTrigger('solve sliding tile puzzle - js')
        end, 1)
        
        for idx, piece in ipairs(solution) do
          send('shift ' .. tostring(piece))
        end
     
      end
      
      
    else 
      return true 
    end -- this will show us the response body, or if it's not the right url, then do not delete the handler
    
  end, true) -- this sets it to delete itself after it fires 
    
  postHTTP(common.json.encode(tp.nodes), url, {["Content-type"] = "application/json"})

    
  tp = nil
  
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>=====================</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
		</TriggerGroup>
	</TriggerPackage>
	<TimerPackage>
		<Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>dont' time out!</name>
			<script>send('\n', false)</script>
			<command></command>
			<packageName></packageName>
			<time>00:01:00.000</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>stay hydrated</name>
			<script>send('drink soup')</script>
			<command></command>
			<packageName></packageName>
			<time>00:02:15.000</time>
		</Timer>
		<Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>stay hydrated</name>
			<script>if (gmcp.Room.Info.vnum == 5117) then
  send('drink chunky')
end

if (gmcp.Room.Info.vnum == 170) then
  send('drink soup')
end

if (gmcp.Room.Info.vnum == 107) then
  send('drink fountain')
end


if (gmcp.Room.Info.vnum == 3817) then
  send('drink cauldron')
end</script>
			<command></command>
			<packageName></packageName>
			<time>00:01:15.000</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>improve ticker</name>
			<script>cecho('\n&lt;white&gt;Improve - halftick\n')

-- send('stand &amp; drink cauld &amp; inventory')
improves.castSpell()
-- send('queue sit couch &amp; queue sleep')lua </script>
			<command></command>
			<packageName></packageName>
			<time>00:00:40.000</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>improve spells w/ non combat improve filler</name>
			<script>cecho('\n&lt;white&gt;Improve - halftick\n')

improves.setFiller(player.improveNonCombat)

send('stand')
improves.castSpell(function()
  send('|drink trough &amp; |sit couch &amp; |sleep')
end)

improves.resetFiller()</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:35.000</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>kick/swim while no improve casts queued</name>
			<script>-- local cmd = 'queue dive pool &amp; queue climb chain'
local cmd = 'climb chain &amp; climb chain &amp; climb chain'
if (#improves.castQueue == 0) then
  send(cmd)
else
  
  if (improves.castFillerLastTick ~= false) then
    improves.castFillerLastTick = false
    tempTimer(65, function()
      send('+')
      murder.smokeUp('imps-no-wis','imps', 22, function()
        improves.castSpell()
        send('wait 3')
      end)
    end, 'casting buff delay')
  end
end</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:01.100</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>check last kill time and alert</name>
			<script>local alertPeriod = 300

if (murder.lastKillTime and murder.enabled) then

  local lk = getEpoch() - murder.lastKillTime
  local msg = 'Last mob was killed ' .. common.formatElapsedTime(lk) .. ' ago'

  if (lk &gt; alertPeriod) then
    common.sendSlack(msg)
    cecho('\n&lt;red&gt;MURDER&lt;white&gt;: ' .. msg .. '\n')
  end

end</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:30.000</time>
		</Timer>
		<Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>map backup</name>
			<script>mapper = mapper or {}
mapper.backupVersion = mapper.backupVersion or 0
mapper.backupVersion = (mapper.backupVersion + 1) % 5

local fileName = getMudletHomeDir() .. "/map/backup" .. mapper.backupVersion .. ".dat"
saveMap(fileName)
echo("Map has been saved as " .. fileName)</script>
			<command></command>
			<packageName></packageName>
			<time>00:10:00.000</time>
		</Timer>
		<Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>xp</name>
			<script>-- run this every so often to clear out data older than 1hr

expandAlias('xp')</script>
			<command></command>
			<packageName></packageName>
			<time>00:20:00.000</time>
		</Timer>
		<Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>check who is online (grants bitches to clannies)</name>
			<script>send('who')</script>
			<command></command>
			<packageName></packageName>
			<time>00:15:00.000</time>
		</Timer>
	</TimerPackage>
	<AliasPackage>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>power leveling</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>plev install</name>
				<script>-- backup your profile before we destroy it...
saveProfile()

-- uninstall the generic mapper
uninstallPackage("generic_mapper")

njs50plev = njs50plev or {}

njs50plev.finishInstall = function()

  common.initPlayer()

  tempTimer(2, function()

		saveGearSet('default')

    send('color columns 300')
    send('color lines 150')
    expandAlias("setOption Auto.Assist true")
    expandAlias("setOption Numeric true")
    expandAlias("setOption Numerical.Damage true")
    expandAlias("setOption Auto.Assist true")
    expandAlias("setOption Join.Fight true")
    expandAlias("setOption Show.Language false")
    send('opt autoscan 3')
    send('opt autoloot 3')
    send('opt room.info 1')


    -- set prompt

    send("prompt ?p' -- MORE -- '&lt;%f?f|@R%hhp@n @G%ee@n @B?m'[%mmv]'!m'%vmv'@n %gwm %xxp?l' %llhp' %d?b' %c'&gt;%\\")

    -- setup aliases
    send('alias *ef eat food &amp; eat food &amp; drop all.food &amp; get 4*food')
    send('alias *dw drink ' .. player.vessel)
  end)

  tempTimer(5, function()
    cecho("\n\n&lt;green&gt;INSTALL: &lt;white&gt;Install complete?! - it might be a good idea to restart mudlet\n\n\n")
  end)

 end


-- download and install latest tfe mapper
local URL = "https://raw.githubusercontent.com/njs50/tfe-mapper/master/tfe-mapper.xml"
common.onNextEvent("sysDownloadDone", function (_, f)
  if not f:find("tfe-mapper", 1, true) then
    return
  end
  uninstallPackage("tfe-mapper")
  tempTimer(2, function()
    installPackage(f)
    os.remove(f)
    cecho("&lt;lime_green&gt;Package installed!\n")

    -- install map
    -- download and install latest tfe mapper
      local URL = "https://raw.githubusercontent.com/njs50/njs50-plev/master/njs50-map.dat"
      common.onNextEvent("sysDownloadDone", function (_, f)
        if not f:find("njs50-map", 1, true) then
          return
        end
        local loadOK = loadMap(f)
        if not loadOK then
         cecho("&lt;red&gt;INSTALL: &lt;white&gt;Couldn't load - was the mapper open? :(\n")
        else
          cecho("&lt;green&gt;INSTALL: &lt;white&gt;Loaded fine!\n")
        end
        os.remove(f)

        -- install dark theme
        local downloaded_package = function(a,b)
          if not b:find("DarkTheme",1,true)then return end
          installPackage(b)
          os.remove(b)

          njs50plev.finishInstall()

        end

        common.onNextEvent("sysDownloadDone", downloaded_package)
    
        downloadFile(getMudletHomeDir().."/DarkTheme.mpackage","https://raw.githubusercontent.com/njs50/njs50-plev/master/DarkTheme.mpackage")

      end)
      downloadFile(getMudletHomeDir()..(URL:ends("dat") and "/njs50-map.dat"), URL)
  end)

end)
downloadFile(getMudletHomeDir()..(URL:ends("xml") and "/tfe-mapper.xml" or "/tfe-mapper.zip"), URL)


</script>
				<command></command>
				<packageName></packageName>
				<regex>^plev install$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>plev update</name>
				<script>-- backup your profile before we destroy it...
saveProfile()

-- reinstall njs50-plev package
local URL = "https://raw.githubusercontent.com/njs50/njs50-plev/master/njs50-plev.xml"

common.onNextEvent("sysDownloadDone", function (_, f)
  if not f:find("njs50-plev", 1, true) then return end
  uninstallPackage("njs50-plev")
  tempTimer(2, function()
    installPackage(f)
    os.remove(f)
    cecho("&lt;lime_green&gt;njs50-plev updated!\n")
  end)
end)

downloadFile(getMudletHomeDir()..(URL:ends("xml") and "/njs50-plev.xml" or "/njs50-plev.zip"), URL)</script>
				<command></command>
				<packageName></packageName>
				<regex>^plev update$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>set optiion</name>
				<script>local option = matches[2]
local desiredVal = matches[3]


local kilTempTimedTrig = common.timedTempTrigger(1, 2, '^' .. option .. [[ set to (\S+)\.$]] , function()

  if (matches[2] ~= desiredVal) then
    cecho(' &lt;orange&gt;&lt;--- incorrect option value\n')
    send('opt ' .. option)
  else
    cecho(' &lt;green&gt;&lt;--- correct option value\n')
  end

end)

send('opt ' .. option)</script>
				<command></command>
				<packageName></packageName>
				<regex>^setOption (\S+) (true|false)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>plev commands</name>
				<script>
local returnModes = {before = true, after = true, with = true}

local damState = {
 ['perfect health'] = 1,
 ['slightly scratched'] = 0.95,
 ['few bruises'] = 0.85,
 ['some cuts'] = 0.75,
 ['several wounds'] = 0.65,
 ['badly wounded'] = 0.55,
 ['many nasty wounds'] = 0.45,
 ['bleeding freely'] = 0.35,
 ['covered in blood'] = 0.25,
 ['leaking guts'] = 0.15,
 ['mostly dead'] = 0.1,
 ['stunned'] = 0,
 ['incapacitated'] = 0,
 ['mortally wounded'] = 0,
 ['DEAD!'] = 0
}


local commands = {

  stop = function ()
    disableTrigger('sleep-murder')
    enableScript('auto assist')
    send('gt powerleveling is disabled')
  end,

  start = function ()
    enableTrigger('sleep-murder')
    disableScript('auto assist')
    send('gt powerleveling is enabled')
  end,

  ['dance-threshold'] = function ()

    player.dance_threshold = player.dance_threshold or damState['bleeding freely']

    local newState

    if (matches[3]:match([[^%d+$]])) then
      newState = tonumber(matches[3]) / 100
    elseif(damState[matches[3]] ~= nil) then
      newState = damState[matches[3]]
    else
      cecho('\n&lt;red&gt;njs50-plev: &lt;white&gt;unknwon damage state, use 0-100 or a string from help damage\n')
      return
    end

    player.dance_threshold = newState

    send('gt will now start the dance when a mob reaches ' .. tostring(player.dance_threshold * 100) .. '% hp')
    cecho('\n&lt;green&gt;njs50-plev: &lt;white&gt;current dancing once mob health reaches ' .. tostring(player.dance_threshold * 100) .. '%\n')

  end,

  ['dance-return'] = function ()

    if ( returnModes[matches[3]] ) then
      player.danceReturnMode = matches[3]
      cecho('\n&lt;green&gt;njs50-plev: &lt;white&gt;will send tank return command ' .. player.danceReturnMode .. ' kill command\n')
    else
      cecho('\n&lt;red&gt;njs50-plev: &lt;white&gt;unknwon return mode, valid modes are: before, with and after\n')
    end

  end,

}


commands[matches[2]]()</script>
				<command></command>
				<packageName></packageName>
				<regex>^plev (start|stop|dance-threshold|dance-return) ?(.*)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>put leveling gear</name>
				<script>send('put levWeap,levArmor leveling &amp; gs &amp; put leveling ' .. player.bag .. ' &amp; ps')</script>
				<command></command>
				<packageName></packageName>
				<regex>^pll$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>get leveling gear</name>
				<script>send('gs &amp; get leveling ' .. player.bag .. ' &amp; ps &amp; get levWeap,levArmor leveling')</script>
				<command></command>
				<packageName></packageName>
				<regex>^gll$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>drop junk</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>sort halfling junk</name>
				<script>send('drop all.brown.pants, all.studd.leather, all.homespun.blue, all.bron.ham, all.steel.short, all.ragg.pant, all.simp.mug' ..
	 	'leath.journ, all.wood.shield, all.high.hard, all.wood.shield, all.leather.armor, all.wood.spear, all.wolf.skin')

send('drop all.banded.armor, all.cloth.robe, all.maple.staff, all.bronze.scale, all.meat.cleaver, all.iron.two-, all.bron.two-,' ..
		 'all.decrep.armor, all.steel.two-, all.hatchet, all.mug.simple, all.old.boot, all.leather.journal, short.ash.staff')

send('label saddleb as deadHalfies &amp; open deadH &amp; get all deadH &amp; drop deadH &amp; get all.leather.cord')

send('give all.silver.coin, all.copper.coin to mojune')</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort halfling junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>sort yeti junk</name>
				<script>send('drop all.yeti.foot')
		</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort yeti junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>^sort stonies junk$</name>
				<script>send('give all.thimb, all.rag, all.coin, all.yeti.pillow to ' .. group.leader)
send('drop all.thick.deer.skin &amp; drop all.frying &amp; drop all.apron &amp; drop all.dress &amp; drop all.slab &amp; drop all.berries')</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort stonies junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>drop yeti junk</name>
				<script>send('drop all.yeti.foot,all.thick.yeti.hide,all.food &amp; get 5*food')

local dropJunk = "drop all.ringm,all.furred.steel.shield,all.hard leather,"..
	'all.low.boot,all.steel.scim,all.great.scim,all.furr.cloak,' ..
	"all.jag.longs,all.wide.belt,all.spik.helm,all.yeti.foot,all.studded.leather," ..
  "all.iron.longs"

send(dropJunk)</script>
				<command></command>
				<packageName></packageName>
				<regex>^drop yeti junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>drop durkang junk</name>
				<script>send('drop all.stud.leath,all.low.boot,all.horn.bronze,all.steel.ringm,' .. 
     'all.bronze.shorts,all.iron.shorts, all.steel.shorts,all.shatt.bottle,' ..
     'all.hard.leather,all.torch,all.silver.wristband,all.pickaxe, black.robe,' ..
     'dusty.ledger,all.huge.cleaver,ringed,all.troll.flesh')
</script>
				<command></command>
				<packageName></packageName>
				<regex>^drop durkang junk$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>Debug</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>show triggers</name>
				<script>displayTempTriggers()</script>
				<command></command>
				<packageName></packageName>
				<regex>^triggers$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>show timers</name>
				<script>displayTempTimers()</script>
				<command></command>
				<packageName></packageName>
				<regex>^timers$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>show event handlers</name>
				<script>displayEventHandlers()</script>
				<command></command>
				<packageName></packageName>
				<regex>^events$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>killAll</name>
				<script>display(tempTimers)
display(tempTriggers)

for id, val in pairs(tempTimers) do
	killTimer(id)
end

for id, val in pairs(tempTriggers) do
	killTrigger(id)
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^killAll$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>kill event</name>
				<script>killAnonymousEventHandler(tonumber(matches[2]))</script>
				<command></command>
				<packageName></packageName>
				<regex>^killEvent (\d+)$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>damage meter</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>dm</name>
				<script>local cmd = matches[2]
local param = matches[3]


local commands = {
	
	start = damageMeter.start,
	
	stop = damageMeter.stop,

    
	show = function (target)
   damageMeter.report(target)
	end,
  

}

local fn = commands[cmd]

if (fn) then
	fn(param)
else
  cecho('\n\n&lt;red&gt;DM: &lt;white&gt;error - unknown command ' .. cmd .. '\n')
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^dm (\S+) ?(.*)$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>gear swap</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>gear</name>
				<script>gearSets()</script>
				<command></command>
				<packageName></packageName>
				<regex>^gear$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>gear</name>
				<script>equipSet(matches[2])
</script>
				<command></command>
				<packageName></packageName>
				<regex>^gear (.*)</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>gear-partial</name>
				<script>equipPartial(matches[3])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(gear-partial|equip your) (.*)</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>gear-reset</name>
				<script>resetGear()</script>
				<command></command>
				<packageName></packageName>
				<regex>^(gear-reset|put your usual gear back on)</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>gear-save</name>
				<script>saveGearSet(matches[2])
</script>
				<command></command>
				<packageName></packageName>
				<regex>^gear-save (.*)</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>gear-delete</name>
				<script>deleteGearSet(matches[2])
</script>
				<command></command>
				<packageName></packageName>
				<regex>^gear-delete (.*)</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>misc</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>repair something</name>
				<script>local o = matches[2]

send('remove ' .. o)
o = o:gsub('2.','')
send('queue dip ' .. o .. ' youth')
send('queue repair ' .. o)
send('queue wear ' .. o)
send('queue eq')</script>
				<command></command>
				<packageName></packageName>
				<regex>^rep (.*)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>grep</name>
				<script>local pattern = matches[3]
local cmd = matches[2]

cecho('\n&lt;green&gt;GREP:&lt;white&gt; searching "' .. cmd .. '" for: ' .. pattern .. '\n')

local killLineTrig = tempRegexTrigger([[^.*$]], function()
  if (not rex.match(matches[1], [[(?i)]] .. pattern)) then
    display(matches[1])
    deleteLine()
  end
end)


common.onNextEvent(common.events.PARSED_PROMPT, function()
  killTrigger(killLineTrig)
  tempTimer(0, function()
    send('\n', false) -- get a new prompt since we killed the last one
    cecho('\n&lt;green&gt;GREP:&lt;white&gt; search done\n')
  end)
end)

send(cmd, false)</script>
				<command></command>
				<packageName></packageName>
				<regex>(.+?) ?\| grep (.+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>display gates</name>
				<script>cecho('\n&lt;green&gt;Brithbarad &lt;white&gt;&gt; Outback')
cecho('\n&lt;green&gt;Chiiron &lt;white&gt;&gt; Wayward')
cecho('\n&lt;green&gt;Medienne &lt;white&gt;&gt; Knight')
cecho('\n&lt;green&gt;Kha-da &lt;white&gt;&gt; Cairn')
cecho('\n&lt;green&gt;Voaleth &lt;white&gt;&gt; Whisper')
cecho('\n&lt;green&gt;Vaasa &lt;white&gt;&gt; Blade')
cecho('\n&lt;green&gt;Pennan &lt;white&gt;&gt; Hollow')
cecho('\n&lt;green&gt;Narak &lt;white&gt;&gt; Corsair')
cecho('\n&lt;green&gt;Sos-kul &lt;white&gt;&gt; Fire')
cecho('\n&lt;green&gt;Orlumber &lt;white&gt;&gt; Midnight')
cecho('\n&lt;green&gt;Brembledon &lt;white&gt;&gt; Amber')</script>
				<command></command>
				<packageName></packageName>
				<regex>^gates$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>xp report</name>
				<script>xp_record = xp_record or {}

local getSlice = function(arr, dt_min)

  local ret = {}
    
  for idx, val in pairs(arr) do
    
    if val.dt &gt;= dt_min then
      table.insert(ret, val)
    end
    
  end

  return ret

end


local sumVals = function(arr)
  
  local ret = 0
    
  for idx, val in pairs(arr) do
    ret = ret + val.val
  end

  return ret

end

local last_hour = getSlice(xp_record, getEpoch() - (60*60))

-- discard any records older than one hour
xp_record = last_hour

local xpt = sumVals(last_hour)
local timeToLevel = gmcp.Char.Score.xp_needed / xpt
local entireLevelTime = gmcp.Char.Score.xp_level / xpt

cecho('\n' .. tostring(#last_hour) .. ' kills in previous hour is: &lt;purple&gt;' .. njs50.commaCase(tostring(xpt)) .. 'xp\n')



local last_five_mins = getSlice(xp_record, getEpoch() - (60*10))
xpt = sumVals(last_five_mins)
cecho(tostring(#last_five_mins) .. ' kills in previous ten minutes is: &lt;purple&gt;' .. njs50.commaCase(tostring(xpt)) .. '\n')




cecho('\nTime to level is: &lt;purple&gt;' .. common.formatElapsedTime(timeToLevel*3600) .. '\n')

cecho('Entire level would take: &lt;purple&gt;' .. common.formatElapsedTime(entireLevelTime*3600) .. '\n\n')



</script>
				<command></command>
				<packageName></packageName>
				<regex>^xp$</regex>
			</Alias>
		</AliasGroup>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<Script isActive="yes" isFolder="no">
			<name>debug helpers</name>
			<packageName></packageName>
			<script>-- preserve functions we are about to decorate
oKillTimer = oKillTimer or killTimer
oTempTimer = oTempTimer or tempTimer
oTempRegexTrigger = oTempRegexTrigger or tempRegexTrigger
oTempTrigger = oTempTrigger or tempTrigger

oRaiseEvent = oRaiseEvent or raiseEvent
oRegisterAnonymousEventHandler = oRegisterAnonymousEventHandler or registerAnonymousEventHandler
oKillAnonymousEventHandler = oKillAnonymousEventHandler or killAnonymousEventHandler


eventHandlers = eventHandlers or {}

function registerAnonymousEventHandler(evt, fn, selfDestruct)

	local thisData = {
		handlerId = 0,
		thisEvt = evt,
		lcb = fn,
	}

  local callback

	if (type(thisData.lcb) == 'string') then
  		callback =thisData.lcb
			cecho('\n&lt;red&gt;EVENT: &lt;white&gt;event handler defined as string - ' .. thisData.lcb .. ' : ' .. '\n')
	else
		callback = function (...)
    		local cb = thisData.lcb
    		-- cecho('\n&lt;green&gt;EVENT: &lt;white&gt;event handler triggered - ' .. tostring(thisData.handlerId) .. ' : ' .. thisData.thisEvt .. '\n')
				-- display(arg)
    		return cb(unpack(arg))
    	end
	end

	thisData.handlerId = oRegisterAnonymousEventHandler(evt, callback, selfDestruct)
	eventHandlers[thisData.handlerId] = evt

	return thisData.handlerId

end

function killAnonymousEventHandler(id)

	if (eventHandlers[id] ~= nil) then
		-- cecho('\n&lt;green&gt;EVENT: &lt;white&gt;killed handler - ' .. tostring(id) .. ' : ' .. eventHandlers[id] .. '\n')
		eventHandlers[id] = nil
	else
		-- cecho('\n&lt;red&gt;TIMER: &lt;white&gt;attempted to kill missing event handler - ' .. id .. '\n')
	end

	return oKillAnonymousEventHandler(id)

end

function killAnonymousEventHandlerByName(name)
  for i, k in pairs(eventHandlers) do 
    if (k == name) then
      cecho('\n&lt;green&gt;EVENT: &lt;white&gt;killed handler - ' .. tostring(i) .. ' : ' .. k .. '\n')
      killAnonymousEventHandler(i)
    end
  end
end


-- allow us to track raised events
function raiseEvent(...)
	-- cecho('\n&lt;green&gt;EVENT: &lt;white&gt;raised - ' .. arg[1] .. '\n')
	return oRaiseEvent(unpack(arg))
end

function displayEventHandlers()
	display(eventHandlers)
end


-- triggers

local oKillTrigger = oKillTrigger or killTrigger
tempTriggers = tempTriggers or {}



local wrapTrigger = function (triggerCommand)

	local oCommand = triggerCommand

	return function (regex, code, expireAfter)

  	local trigId = nil
  	local oCode = code
  	local expires = expireAfter

  	local newCode = function (...)

			if (tempTriggers[trigId]) then
      		tempTriggers[trigId].calls = tempTriggers[trigId].calls + 1
      		if (tempTriggers[trigId].calls == expires) then
    	  			tempTriggers[trigId] = nil
      			-- cecho('\n&lt;orange&gt;trigger died of natural causes - ' .. trigId .. ' : ' .. regex .. '\n')
      		end
			end

  		return oCode(...)
  	end

  	trigId = oCommand(regex, newCode, expires)

  	tempTriggers[trigId] = tempTriggers[trigId] or { calls = 0, regex = regex }

  	return trigId
  end


end



tempRegexTrigger = wrapTrigger(oTempRegexTrigger)
tempTrigger = wrapTrigger(oTempTrigger)

killTrigger = function(id)
	if (tempTriggers[id] ) then
		tempTriggers[id] = nil
	end
	return oKillTrigger(id)
end

displayTempTriggers = function()
	display(tempTriggers)
end


-- timers



tempTimers = tempTimers or {}

tempTimer = function(seconds, code, repeating, description)
  
  if (type(repeating) == 'string') then
    description = repeating
    repeating = false
  end

  -- repeating being nil breaks mudlet :-[
  if (not repeating) then
    repeating = false
  end


	local timerId

	local oCode = code

	local decoratedCode = function (...)
		-- cecho('\n&lt;green&gt;TIMER: &lt;white&gt;timer ran - ' .. tostring(timerId)  .. ' : ' .. (tempTimers[timerId] or '???') .. '\n')
		-- display(tempTimers)
    -- rabies. next to check if oCode is a string and eval it or something lke that. bleh
		
    if (not repeating) then
      tempTimers[timerId] = nil
    end
    
    if (type(oCode) == 'string') then
      cecho('\n\nERROR in timer code, not a function: ' .. oCode .. '\n\n')
    end

		oCode(...)
	end

	timerId = oTempTimer(seconds, decoratedCode, repeating)

	tempTimers[timerId] = (description or 'mystery timer') .. ' - ' .. tostring(seconds) .. ' seconds'

	-- cecho('\n&lt;green&gt;TIMER: &lt;white&gt;timer setup - ' .. tostring(timerId) .. ' : ' .. tempTimers[timerId] .. '\n')

	return timerId

end


killTimer = function(timerId)

	if (tempTimers[timerId] ) then
  	-- cecho('\n&lt;orange&gt;TIMER: &lt;white&gt;killed with fire - ' .. timerId .. ' : ' .. tempTimers[timerId] .. '\n')
  	tempTimers[timerId] = nil
  	oKillTimer(timerId)
	else
		cecho('\n&lt;red&gt;TIMER: &lt;white&gt;attempted to kill missing timer - ' .. timerId .. '\n')
    oKillTimer(timerId)
	end
end

displayTempTimers = function()
	display(tempTimers)
end




</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>queue</name>
			<packageName></packageName>
			<script>njs50 = njs50 or {}


njs50.queue = function(options)

  local queue = {}
  
  options = options or {}  
  
  options.name = options.name or 'queue'
  
  queue.queue = {}
  
  queue.add = function(cmd, description)

    if not (type(cmd) == 'table') then
      cmd = { cmd }
    end
    
    for idx, cmd in ipairs(cmd) do
      local stage = {cmd = cmd, description = description or '', complete = false}
      table.insert(queue.queue, stage)
      if (queue.startedAsync) then
        queue.execAync(stage)
      end
    end

  end
  
  local start = function()
    queue.startTime = getEpoch()
    cecho('\n&lt;green&gt;QUEUE:&lt;white&gt; starting ' .. options.name .. '!\n')
  end
  
  local stop = function()
    queue.endTime = getEpoch()
    cecho('\n&lt;green&gt;QUEUE:&lt;white&gt; ' .. options.name .. ' completed after ' .. common.formatElapsedTime(math.ceil(queue.endTime - queue.startTime)))
    if (options.callback) then
      options.callback()
    end
  end
  
  local stopFail = function()
    queue.endTime = getEpoch()
    cecho('\n&lt;red&gt;QUEUE:&lt;white&gt; ' .. options.name .. ' failed after ' .. common.formatElapsedTime(math.ceil(queue.endTime - queue.startTime)))
    if (options.failCallback) then
      options.failCallback()
    end
  end

  
  
  local advanceSyncQueue = function()
    local ok, errorMsg = coroutine.resume(queue.coroutine)
    if not ok then
      queue.coroutine = nil
      stopFail()
      error("Error in " .. options.name .. ": " .. errorMsg)
    end    
  end   
  
  queue.startSync = function()
    
    start()    
        -- 
        
    local addMinTimeCheck
    
    addMinTimeCheck = function()
      
      queue.add(function(cb)   
        local elapsed = getEpoch() - queue.startTime
        local remaining = options.minTime - elapsed
        if elapsed &gt;= options.minTime then
          cb()
        elseif remaining &lt;= 2 then
          tempTimer(remaining, cb)
        else
          addMinTimeCheck()
          tempTimer(2, cb)
        end
      end, 'check min time has elapsed')

    end    
    
        
    if (options.minTime and options.minTime &gt; 0) then
      addMinTimeCheck()
    end       
        -- 
        
    queue.coroutine = coroutine.create(function()
      
      for idx, stage in ipairs(queue.queue) do
        cecho('\n&lt;green&gt;QUEUE:&lt;white&gt; ' .. options.name .. ' starting stage ' .. tostring(idx) .. ' : ' .. stage.description .. '\n')   
        stage.cmd(function()
          -- can't advance from within this thread for some reason?
          tempTimer(0,advanceSyncQueue)
        end)
        coroutine.yield()
      end 

      stop()
      
    end)
  
    advanceSyncQueue()
    
  end
  
  
  queue.execAync = function(stage)
    
    queue.startedAsync = true
    cecho('\n&lt;green&gt;QUEUE:&lt;white&gt; ' .. options.name .. ' starting : ' .. stage.description .. '\n')   
    tempTimer(0, function()
      local ok, errorMsg = pcall(function() 
        stage.cmd(function()
          
          stage.completed = true
          for idx, stage in ipairs(queue.queue) do
            if (not stage.completed) then
              return
            end
          end
          
          stop() 
          -- cecho('\n&lt;green&gt;QUEUE:&lt;white&gt; completed!\n')
          if (options.callback) then
            options.callback()
          end     
        
        end)
      end)
      
      if (not ok) then
        stopFail()
        error("Error in queue: " .. errorMsg)    
      end
    end)
      
  end
  
  queue.startAsync = function()
    
    start() 
    
    if (options.minTime and options.minTime &gt; 0) then
      queue.add(function(cb)
        tempTimer(options.minTime, cb)
      end, 'queue minimum time')
    end

    queue.startedAsync = true
    for idx, stage in ipairs(queue.queue) do
      queue.execAync(stage) 
    end 

  end

  
  return queue

end

-- 
-- njs50.queueTestAsync = function()
-- 
-- 
  -- local q = njs50.queue({ 
    -- callback = function() 
      -- cecho('\ndone done\n')
    -- end,
    -- failCallback = function()
      -- cecho('\ndone failed\n')
    -- end,
    -- minTime = 10,
    -- name = 'async test'
  -- })
  -- 
  -- q.add(function(cb)
    -- send('dance')
    -- tempTimer(2, function()
      -- error('fucked out')
      -- -- 
        -- -- q.add(function(cb)
          -- -- send('cheer')
          -- -- tempTimer(5, function()
            -- -- cecho('\ndynamic add completed\n')
            -- -- cb()
          -- -- end)
        -- -- end, 'blep 3 async')
        -- 
    -- end)
    -- tempTimer(5, cb)
  -- end, 'blep 1 async')
  -- 
  -- q.add(function(cb)
    -- send('cry')
    -- tempTimer(3, cb)
  -- end, 'blep 2 async')
  -- 
-- 
-- 
  -- q.startAsync()
-- 
-- 
-- end
-- 
-- njs50.queueTestSync = function()
-- 
-- 
  -- local q = njs50.queue({ 
    -- callback = function() 
      -- cecho('\ndone done done\n')
    -- end,
    -- failCallback = function()
      -- cecho('\ndone failed\n')
    -- end,
    -- minTime = 15,
    -- name = 'sync test'
  -- })
  -- 
  -- q.add(
    -- {
      -- function(cb)
        -- send('dance')
        -- tempTimer(3, cb)
      -- end,
      -- function(cb)
        -- send('cry')
        -- cb()
      -- end
    -- }, 
    -- 'blep 1 - bulk add'
  -- )
  -- 
  -- q.add(function(cb)
    -- send('laugh')
    -- 
    -- q.add(function(cb)
      -- send('cheer')
      -- tempTimer(2, cb)
    -- end, 'blep 4 - dynamically added')    
    -- 
    -- tempTimer(3, cb)
  -- end, 'blep 3')
-- 
  -- q.startSync()
-- 
-- end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>make-food-drink</name>
			<packageName></packageName>
			<script>caster = caster or {}

  
caster.createWater = function(vessel, cb, fcb)
    
  local notWaterTrig
  local createdWaterTrig
  local createdWaterTimer
  
  local clearTrigs = function()
    
    if (notWaterTrig) then
      killTrigger(notWaterTrig)
      notWaterTrig = nil
    end
    
    if (createdWaterTrig) then
      killTrigger(createdWaterTrig)
      createdWaterTrig = nil
    end  
  end
  
  
  createdWaterTrig = tempRegexTrigger([[^An? ]] .. vessel ..  [[ fills to overflowing with (.*)\.$]], function()
    if (matches[2]) == 'water' then
      clearTrigs()
      cb()
    else
      send('empty all.' .. common.dotCase(vessel))
      send('cast create water ' .. common.dotCase(vessel))     
    end
  end)
  
  
  notWaterTrig = tempRegexTrigger([[^(&lt;[^&gt;]+&gt;)?You can only cast create water on a drink container\.$]], function()
    clearTrigs()
    fcb()
  end)

  send('cast create water ' .. common.dotCase(vessel))  
  
end
  


caster.snackBreak = function(cb)

  caster.snackBreakTime = true

  local foodTrig, q, drinkTrig

  q = njs50.queue({ 
    callback = function() 
      killTrigger(foodTrig)
      killTrigger(drinkTrig)
      send('gstat snack time is over')
      caster.snackBreakTime = nil
      if (cb) then cb() end
    end,
    minTime = 10,
    name = 'snack break'
  })

  q.startSync()
  

  foodTrig = tempRegexTrigger([[^(\w+) reports group status: "snack me"$]], function()
    local vic = matches[2]
    q.add(function(cb)
      cecho('\n\n&lt;white&gt;make food for ' .. vic .. '\n')
      njs50.cast(
        'create food', { 
        callback = function()
          -- don't want to trigger on same cast twice
          tempTimer(0, function()
            njs50.cast(
              'create food', { 
              callback = function()
                send('give 2*food ' .. vic)
                cb()
              end
            })  
          end)    
        end
      })
    end, 'snacks for ' .. vic)
  end)
  
  
  -- A dark crystal goblet fills to overflowing with slime mold juice.
  -- A dark crystal goblet fills to overflowing with water.

  
  drinkTrig = tempRegexTrigger([[^(\w+) gives an empty (.*) to you\.$]], function()
     
    local playa = matches[2]
    local vessel = matches[3]
    
    q.add(function(cb)
        
      caster.createWater(vessel, function()
        send('give ' .. common.dotCase(vessel) .. '.water ' .. playa)
        cb()
      end, function()
        clearTrigs()
        send('tell ' .. playa .. ' Thanks for the ' .. vessel .. ' I\'m not going to fill it with water.')
        cb()
      end)

    end, 'creating water for ' .. playa)
  
  end)
  
  
  send('gstat snack break')
  send('gstat tell me snack me for food or pass me an empty vessel for a refil, you have 10 seconds to comply.')
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>common</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

common = common or {}
player = player or {}
roomInfo = roomInfo or {}
group = group or {
	combat = false
}

common.damState = {
 ['perfect health'] = 1,
 ['perfect'] = 1,
 ['slightly scratched'] = 0.95,
 ['scratched'] = 0.95,
 ['few bruises'] = 0.85,
 ['bruised'] = 0.85,
 ['some cuts'] = 0.75,
 ['cut'] = 0.75,
 ['several wounds'] = 0.65,
 ['badly wounded'] = 0.55,
 ['wounded'] = 0.55,
 ['many nasty wounds'] = 0.45,
 ['nastily wounded'] = 0.45,
 ['bleeding freely'] = 0.35,
 ['covered in blood'] = 0.25,
 ['leaking guts'] = 0.15,
 ['mostly dead'] = 0.1,
 ['stunned'] = 0,
 ['incapacitated'] = 0,
 ['mortally wounded'] = 0,
 ['dying'] = 0,
 ['DEAD!'] = 0
}

common.damStateInverse = {
 ['1']    = 'perfect health',
 ['0.95'] = 'scratched',
 ['0.85'] = 'bruised',
 ['0.75'] = 'cut',
 ['0.65'] = 'several wounds',
 ['0.55'] = 'wounded',
 ['0.45'] = 'nastily wounded',
 ['0.35'] = 'bleeding freely',
 ['0.25'] = 'covered in blood',
 ['0.15'] = 'leaking guts',
 ['0.10'] = 'mostly dead',
 ['0']    = 'fucked'
}



common.events = {
	PARSED_PROMPT = 'COMMON::parsed_prompt',
	PARSED_EXITS = 'COMMON::parsed_room_exits',
	PARSED_SCORE = 'COMMON::parsed_score_page',
	PARSED_GROUP = 'COMMON::parsed_group_status',
	PARSED_ABILITIES = 'COMMON::parsed_player_abilities',
  PARSED_AFFECTS = 'COMMON::parsed_player_affects',
	PARSED_INVENTORY = 'COMMON:parsed_inventory_contents',
	PARSED_PREPARED = 'COMMON:parsed_prepared_spells',
	PARSED_EQUIPMENT = 'COMMON:parsed_equipment',
  PARSED_WHO = 'COMMON::parsed_who',
	CHANGED_EQUIPMENT = 'COMMON:changed_equipment',
	MOVE_DETECTED = 'COMMON::move_detected',
	ROOM_CHANGED = 'COMMON::room_changed',
	COMBAT_ENDED = 'COMMON::combat_ended',
	COMBAT_STARTED = 'COMMON::combat_started',
  COMBAT_ATTACK = 'COMMON::combat_attack',
  COMBAT_PLAYER_HIT = 'COMMON::combat_player_hit',
	WALK_DONE = 'COMMON::speedwalk_completed',
	ROOM_CLEAR = 'COMMON::current_room_is_clear',
	PARRY_STATE_CHANGE = 'COMMON::parry_state_change',
  SCAN_PROCESSED = 'COMMON::scan_data_processed',
}

common.tableHasValue =  function (tab, val)
  for index, value in ipairs(tab) do
    if tab[index] == val then
    	return true
    end
  end
  return false
end


common.sendToChan = function(chan, msg)

  if (not chan or chan == 'cecho') then   
    cecho(msg .. '\n')
  else
    msg = rex.gsub(msg, [[(&lt;[^&gt;]+&gt;)]], '')
    
    msgs = msg:split('\n')
    for idx, m in ipairs(msgs) do
      if (m == '') then
        m = '.'
      end
      send(chan .. ' ' .. m)
    end
  end

end

common.tfeItemListAdd = function (list, item)

	local idx = 0
	local match = nil

	-- see if this value is already in the list
	for index, value in ipairs(list) do
		match = rex.match(value, '^(\\d+)?\\*?' .. item .. '$')
    if match ~= nil then
    	idx = index
			break
    end
  end

	--  if we found a match, see how many of this item are already in the list
	if (idx &gt; 0) then
		local count = 1
		if (match ~= false) then
			count = tonumber(match)
		end
		count = count + 1
		list[idx] = tostring(count) .. '*' .. item
	else -- this is a new item
		table.insert(list, item)
	end

	return list
end

common.reverseList = function(list)

	local i = 1
	local j = #list

	while i &lt; j do
		list[i], list[j] = list[j], list[i]
		i = i + 1
		j = j - 1
	end

	return list

end


common.setParryState = function (state, reason, callback, permanent)

	local cb = callback

	player.parryQueue = player.parryQueue or 0

  -- if we have queued parry changes defer until they have all happened
  if (player.parryQueue &gt; 0) then
    common.onNextEvent(common.events.PARRY_STATE_CHANGE, function (evt, args)
  		  common.setParryState(state, reason, callback, permanent)
    end)
    return
  end

	local currentState = player.parry

	if (player.parryRevertTimer) then
		killTimer(player.parryRevertTimer)
		player.parryRevertTimer = nil
	end


	-- if we need to swap opt parry
	if (currentState ~= state) then

  	-- if we are turning parry on, make sure we have a plan to turn it off again
  	if (not permanent and state) then
  		player.parryRevertTimer = tempTimer(15, function ()
  			if (player.parry) then
  				common.setParryState(false, 'opt parry has been on too long!')
  			end
  		end)
  	end

  	cecho('\n&lt;green&gt;PARRY: &lt;white&gt;setting  - ' .. tostring(state) .. ' - ' .. reason or '?' .. '\n')
  	send('opt parry')
		player.parryQueue = player.parryQueue + 1
    cecho('&lt;yellow&gt; &lt;-- parry queue -- (' .. player.parryQueue .. ')')

  	common.onNextEvent(common.events.PARRY_STATE_CHANGE, function (evt, args)
      cecho('\n&lt;green&gt;PARRY: &lt;white&gt;state change happened!\n')
  		if (cb) then cb() end
    end)

	else
		cecho('\n&lt;green&gt;PARRY: &lt;white&gt;setting  - ' .. tostring(state) .. ' - skipping as no change needed\n')
		if (cb) then cb() end
	end

end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>player.config</name>
			<packageName></packageName>
			<script>common = common or {}
player = player or {}
player.scripts = player.scripts or {}


player.defaultConfig = function ()

	player.bag = 'backpack.holding'
	player.pack = 'black.silk.bag'
  player.vessel = 'leather.waterskin'
  player.hasFoodBasket = false
	player.caster = false
	player.gearSet = 'default'
  
  player.getAttackCommand = function(target)
    return 'kill ' .. target
  end
  
  player.autoAttack = function(target)
    send(player.getAttackCommand(target))
  end  

end

common.fullEnough = function()
  
  if ((group.data[player.name].hp / group.data[player.name].hp_max) &gt; 0.9) and
     ((group.data[player.name].mp / group.data[player.name].mp_max) &gt; 0.9) and
     ((group.data[player.name].moves / group.data[player.name].moves_max) &gt; 0.8) then
     
    return true
  end
  
  return false

end


common.wm = common.wm or {}
common.wm.gridEntries = common.wm.gridEntries or {};

common.resetWindows = function(event, x, y)

  if (common.topContainer) then
    local tch = common.topContainer.get_height()

    if (tch ~= common.wm.tc_height) then
          -- setBorderTop(tch)
      common.wm.tc_height = tch

      if (common.resizeTimer) then killTimer(common.resizeTimer) end

      common.resizeTimer = tempTimer(0.1, function()
        setBorderTop(common.wm.tc_height)
        setBorderLeft(200)
        common.resizeTimer = nil
      end)

    end
  else

    -- player is not yet init. resize once windows are setup
    tempTimer(1, function()
      common.resetWindows(event, x, y);
    end)
  end

end


if (common.resizeEventWatcher) then
  killAnonymousEventHandler(common.resizeEventWatcher)
  common.resizeEventWatcher = nil
end

common.resizeEventWatcher = registerAnonymousEventHandler("sysWindowResizeEvent", common.resetWindows)



common.addGridEntry = function()

  local idx = tostring(#common.wm.gridEntries)

	local thisGrid = Geyser.Container:new({
    name = "grid_entry_" .. idx,    -- give it a unique name here
		x=0,
		y= #common.wm.gridEntries * 100,
    width = "100%",
		height=100,
  }, common.leftContainer)


  local hpbar = Geyser.Gauge:new({
    name="hpbar-" .. idx,
    x=5, y=10,
    width=190, height=40,
  }, thisGrid)

  hpbar.front:setStyleSheet([[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #f04141, stop: 0.1 #ef2929, stop: 0.49 #cc0000, stop: 0.75 #a40000, stop: 1 #cc0000);
    border-top: 1px black solid;
    border-left: 1px black solid;
    border-bottom: 1px black solid;
    border-radius: 3;
    padding: 3px;
  ]])
  hpbar.back:setStyleSheet([[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #bd3333, stop: 0.1 #bd2020, stop: 0.49 #990000, stop: 0.75 #700000, stop: 1 #990000);
    border-radius: 3;
    padding: 3px;
  ]])

  hpbar.text:setStyleSheet([[
   qproperty-alignment: 'AlignCenter';
  ]])

  hpbar.text:setFontSize(20)

  local manabar = Geyser.Gauge:new({
    name="mpbar-" .. idx,
    x=5, y=50,
    width=190, height=30,
  }, thisGrid)


  manabar.front:setStyleSheet([[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #4141f0, stop: 0.1 #2929ef, stop: 0.49 #0000cc, stop: 0.75 #0000a4, stop: 1 #0000cc);
    border-top: 1px black solid;
    border-left: 1px black solid;
    border-bottom: 1px black solid;
    border-radius: 3;
    padding: 3px;
  ]])
  manabar.back:setStyleSheet([[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #3333bd, stop: 0.1 #2020bd, stop: 0.49 #000099, stop: 0.75 #000070, stop: 1 #000099);
    border-radius: 3;
    padding: 3px;
  ]])
  manabar.text:setStyleSheet([[
   qproperty-alignment: 'AlignCenter';
  ]])

  manabar.text:setFontSize(20)

  local movebar = Geyser.Gauge:new({
    name="mbbar-" .. idx,
    x=5, y=80,
    width=190, height=20,
  }, thisGrid)


  movebar.front:setStyleSheet([[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #41f041, stop: 0.1 #29ef29, stop: 0.49 #00cc00, stop: 0.75 #00a400, stop: 1 #00cc00);
    border-top: 1px black solid;
    border-left: 1px black solid;
    border-bottom: 1px black solid;
    border-radius: 3;
    padding: 3px;
  ]])
  movebar.back:setStyleSheet([[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #33bd33, stop: 0.1 #20bd20, stop: 0.49 #009900, stop: 0.75 #007000, stop: 1 #009900);
    border-radius: 3;
    padding: 3px;
  ]])
  movebar.text:setStyleSheet([[
   qproperty-alignment: 'AlignCenter';
  ]])

  movebar.text:setFontSize(14)

  table.insert(common.wm.gridEntries, {
    container = thisGrid,
    hpbar = hpbar,
    manabar = manabar,
    movebar = movebar
  })

end


common.updateGrid = function ()
 
 if (common.topContainer) then
    -- make sure we have one grid item per group member at least
    if (#common.wm.gridEntries &lt; group.memberCount) then
      for i = #common.wm.gridEntries, group.memberCount -1 do
        common.addGridEntry();
      end
    end
  
    -- hide any extra grid items
    if (#common.wm.gridEntries &gt; group.memberCount) then
      for i = group.memberCount + 1, #common.wm.gridEntries do
        common.wm.gridEntries[i].container:hide()
      end
    end  
      
    for idx, name in pairs(table.keys(group.members)) do
      -- display(idx,val)
      local data = group.data[name]
      local grid = common.wm.gridEntries[idx]
      
      grid.container:show()
      
      -- display(data)
      
      grid.hpbar:setValue(data.hp, math.max(data.hp_max, 1), name .. ' : ' .. tostring(data.hp) .. 'hp')
      grid.manabar:setValue(data.mp, math.max(data.mp_max, 1), tostring(data.mp) .. '/' .. tostring(data.mp_max))
      grid.movebar:setValue(math.min(data.moves, data.moves_max), math.max(data.moves_max, 1))
    end 
  end
end



if (common.wm.groupWatcher) then
  killAnonymousEventHandler(common.wm.groupWatcher)
  common.wm.groupWatcher = nil
end


common.wm.groupWatcher = registerAnonymousEventHandler(common.events.PARSED_GROUP, common.updateGrid)




common.initPlayer = function ()

	echo('\n\nINITIAL STATUS CHECK\n\n')
  
  -- rest to defaults for init
  
  common.onNextEvent(common.events.PARSED_ABILITIES, function()
    
    if (not gmcp.Char.Score.name) then
      cecho('\ngmcp not init, trying again in 2 seconds\n\n')
      tempTimer(2, function()
        common.initPlayer()
      end)
      return
    end
    
  	player.name = gmcp.Char.Score.name
  
  
  	if not (player.scripts and player.scripts[player.name]) then
      echo('\nSetting  default player script for ' .. player.name .. '!\n')
      player.scripts[player.name] = player.defaultConfig
  	end
  
  		echo('\nRunning player script for ' .. player.name .. '!\n')
      player.defaultConfig()
  		player.scripts[player.name]()
  
  	if (not common.topContainer) then
  
  		-- init windows
      common.topContainer = Geyser.Container:new({
        name = "top_container",    -- give it a unique name here
  			x=0,
  			y=0,
        width = "100%",
  			height="25%",
      })
  
      common.leftContainer = Geyser.Container:new({
        name = "left_container",    -- give it a unique name here
  			x=0,
  			y="25%",
        width = 200,
  			height="75%",
      })
  
  		common.mapContainer = Geyser.Container:new({
        name = "map_container",    -- give it a unique name here
  			x=0,
  			y=0,
        width = "40%",
  			height="100%",
      }, common.topContainer) --
  
  		common.chatContainer = Geyser.Container:new({
        name = "chat_container",    -- give it a unique name here
  			x = "40%",
  			y = 0,
        width = "60%",
  			height = "100%",
        padding = 10,
      }, common.topContainer)
  
  				-- init windows
      common.mapper = Geyser.Mapper:new({
        name = "geyser_map",    -- give it a unique name here
  			x=0,
  			y=0,
        width = "100%",
  			height="100%",
      }, common.mapContainer)
  
      common.chatConsole = EMCO:new({
        x = 0,
        y = 0,
        width = "100%",
        height = "100%",
        allTab = true,
        allTabName = "All",
        fontSize = 14,
        gap = 10,
        consoles = {
          "All",
          "Clan",
          "Group",
          "Tell",
          "Public", 
          "Other",
          "Log",
        },
        -- mapTabName = "Map",
        mapTab = false,
        -- activeTabCSS = stylesheet,
        -- inactiveTabCSS = istylesheet,
      }, common.chatContainer)
        
      
  
  	end
  
    echo('\n\nloading gear sets. if it fails you should do luaSaveGearSet("default") to save a default set\n\n')
    loadSavedGearSets()
  
  end)
  
  send('score &amp; eq &amp; group &amp; inv &amp; typo &amp; prep &amp; abil all')

end

    </script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>player.config.example.template</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

player = player or {}
player.scripts = player.scripts or {}

-- nb: must match exactly. i.e don't forget the capital letter
player.scripts.YOUR_NAME_HERE = function ()

	player.bag = 'bag.holding'
	player.pack = 'backpack.holding'
	player.reagentBag = 'bag.reagents'
	player.gearSet = 'default'
	player.vessel = 'leather.waterskin'
	player.caster = false
	player.hasFoodBasket = false
  player.hasSoupBarrel = false
  player.language = 'ogrish'
  
  player.getAttackCommand = function(target)
    return 'kill ' .. target
  end
  
  player.autoAttack = function(target)
    send(player.getAttackCommand(target))
  end  

end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>swap</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

player = player or {}

player.swapItems = player.swapItems or {}
player.gearSets = player.gearSets or {}

common.conditions = {
  worthless = 0,
  damaged = 1,
  ["very worn"] = 2,
  worn = 3,
  ["very scratched"] = 4,
  ["very scratch"] = 4,
  scratched = 5,
  reasonable = 6,
  good = 7,
  ["very good"] = 8,
  excellent = 9,
  perfect = 10
}



common.slots = {
  "right hand",
  "left hand",
  "left hand finger",
  "right hand finger",
  "right wrist",
  "left wrist",
  "head",
  "body",
  "nearby",
  "arms",
  "hands",
  "feet",
  "legs",
  "waist",
  "neck"
}

common.layers = { 'bottom', 'under', 'base', 'over', 'top' }

common.lowestGearIgnore = {
  ["powdered wig"] = true,
  ["golden ball of light"] = true,
}


common.getWeaponCondition = function(cb)
  common.onNextEvent(common.events.PARSED_EQUIPMENT, function()
    if not (player.gear["right hand"] and player.gear["right hand"].base) then
      cb(common.conditions['perfect'])
    else
      cb(common.conditions[player.gear["right hand"].base.condition])
    end
    
  end)
  send('eq')

end

function getLowestGearCondition (cb)
  common.onNextEvent(common.events.PARSED_EQUIPMENT, function()
    -- lua player.gear["right hand"].base.condition
    local lowestCondition = 11
    local lowestItem
    
    for slot, layers in pairs(player.gear) do
      for layer, item in pairs(layers) do
        if (common.conditions[item.condition] == nil) then
          cecho('\n\n&lt;red&gt;[GEAR]: &lt;white&gt; unknown gear condition: ' .. item.condition .. '\n\n')
        else
          if (not common.lowestGearIgnore[item.item] and common.conditions[item.condition] &lt; lowestCondition) then
            lowestCondition = common.conditions[item.condition]
            lowestItem = item
          end
        end
      end
    end
    -- display(lowestItem)
    -- display(player.gear)
    cb(lowestCondition)
  end)
  send('eq')
end


function gearSets()
  cecho('\n&lt;green&gt;GEAR:&lt;white&gt; saved sets:\n\n')
  for set, deets in pairs(player.gearSets) do
    cecho(set .. '\n')
  end
end


function equipSet(set, callback)
  if (player.gearSets[set]) then

  	player.gearSet = set
  	send('gs', true)
  	equipGearSet(set, function()
  		send('ps', false)
			if callback then callback() end
    end)

  else
  	cecho('\n&lt;red&gt;GEAR: &lt;white&gt;No set found matching: "' .. set .. '"\n')
  end
end

function equipPartial(set, callback)
  if (player.gearSets[set]) then
  	cecho('\n&lt;green&gt;GEAR: &lt;white&gt;Equip partial set: "' .. set .. '"\n')
  	send('gs', true)
  	equipGearSet(set, function()
  		send('ps', true)
			if callback then callback() end
    end, true)

  else
  	cecho('\n&lt;red&gt;GEAR: &lt;white&gt;No set found matching: "' .. set .. '"\n')
  end
end

function resetGear(callback)


  if (player.gearSets[player.gearSet]) then

  	cecho('\n&lt;green&gt;GEAR: &lt;white&gt;resetting gear to set: "' .. player.gearSet .. '"\n')
  	send('gs', true)

		equipGearSet(player.gearSet, function()
  		send('ps', true)
			if callback then callback() end
    end)

  else
  	cecho('\n&lt;red&gt;GEAR: &lt;white&gt;No set found matching: "' .. player.gearSet .. '"\n')
  end
end


function deleteGearSet (name)
  table.save(getMudletHomeDir() .. "/gearsets.backup.dat", player.gearSets)
  player.gearSets[name] = nil
  table.save(getMudletHomeDir() .. "/gearsets.dat", player.gearSets)
end


function saveGearSet (name)

	common.onNextEvent(common.events.PARSED_EQUIPMENT, function()
  	table.save(getMudletHomeDir() .. "/gearsets.backup.dat", player.gearSets)
  	player.gearSets[name] = player.gear
  	table.save(getMudletHomeDir() .. "/gearsets.dat", player.gearSets)
	end)
	send('eq', false)

end

function loadSavedGearSets ()
	player.gearSets = {}

	local gearFile = getMudletHomeDir() .. "/gearsets.dat"

	local is_file = io.open(gearFile)

	if (is_file ~= nil) then
		table.load(gearFile, player.gearSets)
	end

end


function loadGearSetBackup ()
	player.gearSets = {}
	table.load(getMudletHomeDir() .. "/gearsets.backup.dat", player.gearSets)
end

-- functions below here are probably internal...

function equipGearSet (name, callback, partial)


	cecho('\n&lt;green&gt;Outfit: &lt;white&gt;equip gear set: ' .. name)

  if(player.equippingSet) then
		cecho('\n&lt;red&gt;Outfit: &lt;white&gt;waiting for prev gear change to complete before equiping ' .. name)

  	common.onNextEvent(common.events.CHANGED_EQUIPMENT, function()
			equipGearSet(name, callback, partial)
  	end)

    send('eq')

    timedTempTrigger(0.5, 1, '^You cannot do that while sleeping\.$', function ()
    	send('stand &amp; eq')
    end)

		return
	end


	player.equippingSet = true


	common.onNextEvent(common.events.PARSED_EQUIPMENT, function()

  	-- echo('\ncurrent gear established...\n')

		local newSet = player.gearSets[name]

		if (newSet == nil) then

			cecho('&lt;red&gt;Outfit Error: &lt;white&gt;set does not exist')
			if callback then callback() end

		else

			-- reset current swap list
			player.swapItems = {}

  		-- remove any items that have empty slots in new set
			if (not partial) then
    	  for slot, layers in pairs(player.gear) do
          for layer, item in pairs(layers) do
    				if (not (newSet[slot] and newSet[slot][layer])) then
  						-- echo('\nneed to remove ' .. item.item)
  						swapItems(item.item, '', slot, layer)
  					end
    			end
        end
			end

			-- swap any items different in the new set
			for slot, layers in pairs(newSet) do
				if (type(layers) == 'table') then -- in case junk like parsed gets in the data again
          for layer, item in pairs(layers) do
  					-- add any items in a layer that doesn't exist in current set
    				if (not (player.gear[slot] and player.gear[slot][layer])) then
  						-- echo('\nneed to add new slot ' .. item.item)
  						swapItems('', item.item, slot, layer)
  					elseif (player.gear[slot][layer].item ~= item.item)then
  						swapItems(player.gear[slot][layer].item, item.item, slot, layer)
  					end
    			end
				else
					-- not sure how parsing is still in there (too lazy to investigate atm)
					if (slot ~= 'parsing') then

						cecho('\n&lt;red&gt;GEAR ERROR: &lt;white&gt;invalid data!!! slot: ' .. slot)
					end
				end
      end


			-- make sure we aren't just switching left/right things
      
			local removeRedundantSwap = function (slot, layer)
					if (player.swapItems["left " .. slot] and player.swapItems["left " .. slot][layer] and
						player.swapItems["right " .. slot] and player.swapItems["right " .. slot][layer] and
						(player.swapItems["left " .. slot][layer].from == player.swapItems["right " .. slot][layer].to) and
  					(player.swapItems["left " .. slot][layer].to == player.swapItems["right " .. slot][layer].from)) then
  					-- remove redundant swap
  					cecho('\n&lt;green&gt;GEAR SWAP: &lt;white&gt;removed redundant swap (left/right ' .. slot .. '.' .. layer .. ')')
  					player.swapItems["left " .. slot][layer] = nil
  					player.swapItems["right " .. slot][layer] = nil
  			end
			end

      



			removeRedundantSwap('hand finger', 'over')
			removeRedundantSwap('hand finger', 'base')
			removeRedundantSwap('hand finger', 'top')
			removeRedundantSwap('wrist', 'base')
			removeRedundantSwap('wrist', 'over')
      
        -- ["left hand"] = {
          -- base = {
            -- from = "dar.ston.dagg.desp",
            -- to = "blac.stri.leat"
          -- }
        -- },
      
      -- weapons are fucked up if we are dual weiling the same weap but want to swap left hand
      -- remove the right hand weap also in this case
      if ( player.swapItems["left hand"] and player.swapItems["left hand"].base) then
      
        if (
              player.gear["left hand"] and player.gear["left hand"].base and 
              player.gear["right hand"] and player.gear["right hand"].base and
              player.gear["right hand"].base.item == player.gear["left hand"].base.item) then
          swapItems(player.gear["right hand"].base.item, player.gear["right hand"].base.item, "right hand", "base")
        end   
      end 


      -- swap all layers on top of any layers changing due to fucked up things like Xanas bracelets
      for slot, layers in pairs(player.swapItems) do
        
        -- for whatever reason sometimes the first item isnt the lowest layer
        local firstLayer = table.keys(layers)[1]
        local flIndex = table.index_of(common.layers,firstLayer)
        
        for layer in pairs(layers) do 
          local thisIndex = table.index_of(common.layers,layer)
          if (thisIndex &lt; flIndex) then
            flIndex = thisIndex
            firstLayer = layer
          end
        end 

        
        if (firstLayer) then
          for idx = table.index_of(common.layers,firstLayer) + 1, #common.layers do
            local checkLayer = common.layers[idx]
            if ((not player.swapItems[slot] or not player.swapItems[slot][checkLayer]) and (player.gear[slot] and player.gear[slot][checkLayer])) then
              swapItems(player.gear[slot][checkLayer].item, player.gear[slot][checkLayer].item, slot, checkLayer)
            end
          end
        end
      
      end



			local cb = function ()
				callback()
			end
      
      if #table.keys(player.swapItems) == 0 then
        
        cecho('\n&lt;green&gt;GEAR SWAP: &lt;white&gt;no gear needs swapping\n')
    		player.equippingSet = nil
    		if cb then cb() end
    		raiseEvent(common.events.CHANGED_EQUIPMENT)
        
      else
  
  			-- lets do it...
  			performSwap(cb)
    
      end

		end -- end check if this was a valid set

  end)

	send('eq', false)

end

-- Error: invalid item switch of items in slot left hand
-- {
  -- to = "fir.gian.scap",
  -- from = "cora.shie.reju"
-- }
-- {
  -- to = "cora.shie.reju",
  -- from = "cora.shie.reju"
-- }


function swapItems (to, from, slot, layer)

	-- cecho('&lt;green&gt;swap: &lt;white&gt;swap to ' .. to .. ' from ' .. from .. '\n')

	if (slot == nil) then
		cecho('&lt;red&gt;ERROR: &lt;white&gt;no slot provided on item swap ' .. to .. ' to ' .. from .. '\n')
	end

	local swap = {from=common.itemShorten(to), to=common.itemShorten(from)}

	player.swapItems[slot] = player.swapItems[slot] or {}

	if (player.swapItems[slot][layer]) then

		if (player.swapItems[slot][layer].to == swap.from) then
			swap.from = player.swapItems[slot][layer].from
		else
			cecho('Error: invalid item switch of items in slot ' .. slot)
			display(player.swapItems[slot][layer])
			display(swap)
		end

	end

	player.swapItems[slot][layer] = swap

end


function swapCommands (removeList, wearList)

	if(#wearList &gt; 0) then
		send('get ' .. table.concat(wearList, ',') .. ' from ' .. player.bag)
	end

	if(#removeList &gt; 0) then
		send('remove ' .. table.concat(removeList, ','))
	end

	if(#wearList &gt; 0) then
		send('wear ' .. table.concat(wearList, ','))
	end

	if(#removeList &gt; 0) then
		send('put ' .. table.concat(removeList, ',') .. ' in ' .. player.bag)
	end


end

function performSwap (callback)

	local cb = callback

	local removeList = {}
	local wearList = {}

	local removeLength = 0
	local wearLength = 0

	local idx


  for k, slot in pairs(common.slots) do

    if (player.swapItems[slot]) then

      items = player.swapItems[slot]

  		for k, layer in pairs(common.layers) do
  		-- for layer, swap in pairs(items) do
  			local swap = items[layer]

  			if (items[layer]) then

    			if string.len(swap.from) &gt; 0 then
    				removeList = common.tfeItemListAdd(removeList, swap.from)
    				-- this is an approximation since if it's already in the list
    				-- we are only actually adding 2 (i.e 2*item)
    				removeLength = removeLength + string.len(swap.from)
    			end

    			if string.len(swap.to) &gt; 0 then

  				  wearList = common.tfeItemListAdd(wearList, swap.to)
    				-- this is an approximation since if it's already in the list
    				-- we are only actually adding 2 (i.e 2*item)
    				wearLength = wearLength + string.len(swap.to)
    			end

  			end -- check if layer is being swapped

  		end -- end layer loop


  		if (wearLength &gt; 150 or removeLength &gt; 150) then
  			-- gotta remove items in the reverse order (i.e top layer first)
  			swapCommands(common.reverseList(removeList), wearList)
  			removeList = {}
  			wearList = {}
  			removeLength = 0
  			wearLength = 0
  		end

  	end -- end slot if
  end -- slot loop

	-- display(wearList)
	-- display(removeList)

	if (wearLength &gt; 0 or removeLength &gt; 0) then
		-- gotta remove items in the reverse order (i.e top layer first)
		swapCommands(common.reverseList(removeList), wearList)
	end

	send('queue group &amp; queue eq', false)

	common.onNextEvent(common.events.PARSED_EQUIPMENT, function()
		player.equippingSet = nil
		if cb then cb() end
		raiseEvent(common.events.CHANGED_EQUIPMENT)
	end)

	player.swapItems = {}

end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>casting / respell</name>
			<packageName></packageName>
			<script>-- first check if we need to re-up BM
njs50 = njs50 or {}

njs50.cast = function (spell, options)
  
  -- target, callback, failCallback
  options = options or {}
  
  local target = options.target
  local callback = options.callback
  local failCallback = options.failCallback

-- You don't know the spell hardiness.
-- Unknown spell.
-- You need a brown duck feather to cast float.
-- The room doesn't contain any beings matching "nutjob".
-- +++ You cast bless +++
  
  -- handle being webbed!
  -- You can't cast spells while entangled.
  -- You break out of the web holding you.
  
  -- handle missing target
  -- Nothing found matching "gem bright".
  
  
  local spellUnprepped, spellUnknown, castFailedSleep
  
  local castFailed, castFailedBank, reagentFail, missingTarget
  
  local castSuccess, shortMana, msg
  
  local cleanTriggers = function()
    killTrigger(spellUnprepped)
    killTrigger(spellUnknown)
    killTrigger(castFailedSleep)
    
    killTrigger(castFailed)
    killTrigger(castFailedBank)
    killTrigger(reagentFail)
    
    if (missingTarget) then
      killTrigger(missingTarget)
    end
   
    killTrigger(castSuccess)
    -- killTrigger(shortMana)
    
  end
 
  local leachSub = {
    ['protection/chaos'] = 'Prot Vs Chaos',
    ['protection/good'] = 'Prot Vs Good',
    ['protection/law'] = 'Prot Vs Law',
    ['protection/evil'] = 'Prot Vs Evil',
  }
  
  
  local cmd = 'cast ' .. spell
  
  if (target and target ~= '') then
    cmd = cmd .. ' ' .. target
  end
  
  if (options.queueSpellImprove) then
    if (player.skills[spell] &lt; 10) then
      
      if (leachSub[spell]) then
        spell = leachSub[spell]
      end
      
      cmd = cmd .. ' &amp; wait 1 &amp; queue leech ' .. spell
    
      improves.queueSpell(cmd)
      
      tempTimer(0, function()
        if (callback) then callback() end
      end)
      
    else
    
      cecho('\n&lt;green&gt;RESPELL:&lt;white&gt; improve mode, skipping ' .. cmd .. '\n')
      tempTimer(0, function()
        if (callback) then callback() end
      end)
    end
  else
  
    if (target and target ~= '') then
      
      local nt = rex.gsub(target, [[\.]], " ")
      
      missingTarget = tempRegexTrigger([[^Nothing found matching "]] .. nt .. [[)"\.$]], function()
        msg = 'failed due to missing target - ' .. target .. '?'
        cecho('\n&lt;red&gt;CAST: &lt;white&gt;' .. msg .. '\n\n')
        cleanTriggers()
        if (failCallback) then failCallback(msg) end 
      end, 1)
    
    end
    
  
   
    -- You don't have tornado prepared.
    spellUnprepped = tempRegexTrigger([[^You don't have ]] .. spell .. [[ prepared\.$]], function()
      msg = 'failed due to unprepped spell - ' .. spell .. '?'
      cecho('\n&lt;red&gt;CAST: &lt;white&gt;' .. msg .. '\n\n')
      cleanTriggers()
      if (failCallback) then failCallback(msg) end 
    end, 1)
      
    spellUnknown = tempRegexTrigger([[^(Unknown spell|You don't know the spell ]] .. spell .. [[)\.$]], function()
      msg = 'failed due to unkown spell - ' .. spell .. '?'
      cecho('\n&lt;red&gt;CAST: &lt;white&gt;' .. msg .. '\n\n')
      cleanTriggers()
      if (failCallback) then failCallback(msg) end 
    end, 1)
    
    castFailedSleep = tempRegexTrigger([[^You cannot do that while sleeping$]], function ()
      msg = 'failed to do something while sleeping - ' .. spell .. '?'
      cecho('\n&lt;red&gt;CAST: &lt;white&gt;' .. msg .. '\n\n')
      cleanTriggers()
      if (failCallback) then failCallback(msg) end        
    end, 1)  
    
    castFailed = tempRegexTrigger([[^&gt;&gt; Your ]] .. spell .. [[ casting is disrupted. &lt;&lt;$]], function ()
      msg = 'casting ' .. spell .. ' was disrupted'
      cecho('\n&lt;red&gt;CAST: &lt;white&gt;' .. msg .. '\n\n')
      cleanTriggers()
      if (failCallback) then failCallback(msg) end    
    end, 1)
    
    castFailedBank = tempRegexTrigger([[^As you cast ]] .. spell .. [[, you feel the energy drain from you and nothing happens\.$]], function ()
      msg = 'casting ' .. spell .. ' failed due to no magic room'
      cecho('\n&lt;red&gt;CAST: &lt;white&gt;' .. msg .. '\n\n')
      cleanTriggers()
      if (failCallback) then failCallback(msg) end    
    end, 1)
      
    -- As you cast float
    
    reagentFail = tempRegexTrigger([[^You need (.*) to cast ]] .. spell .. [[\.$]], function ()
      msg = 'missing ' .. matches[2] .. ' for casting ' .. spell
      cecho('\n&lt;red&gt;CAST: &lt;white&gt;' .. msg .. '\n\n')
      cleanTriggers()
      if (failCallback) then failCallback(msg) end
    end, 1)
    
    -- this is caught by the missing reagent pattern above
    -- You need 75 energy points to cast summon.
    -- shortMana = tempRegexTrigger([[^You need \d+ energy points to cast ]] .. spell .. [[\.$]], function ()
      -- msg = 'not enough mana to cast ' .. spell
      -- cecho('\n&lt;red&gt;CAST: &lt;white&gt;' .. msg .. '\n\n')
      -- cleanTriggers()
      -- if (failCallback) then failCallback(msg) end
    -- end, 1)
    
    castSuccess = tempRegexTrigger([[^\+\+\+ You cast ]] .. spell .. [[ \+\+\+$]], function ()
      cecho('\n&lt;green&gt;CAST: &lt;white&gt;spell - ' .. spell .. '!\n\n')
      cleanTriggers()
      if (callback) then callback() end
    end, 1)    
  
  
  
  
  
    send(cmd)
  end

end

-- buffs = {
  -- sustenance = 'You are being sustained.',
  -- bless = 'You feel righteous.',
-- }

njs50.cancelPendingRespell = function()
  player.pendingRespell = nil
end


njs50.defaultRespell = function(cb)
   njs50.respell(player.buffs, {
    target = 'gstat', 
    callback = function()
      if (cb) then cb() end
    end
  })
end

njs50.respell = function (buffs, options)

  options = options or {}

  local target = options.target
  local cb = options.callback
  local fcb = options.failCallback
  local queueSpellImprove = options.queueSpellImprove
  
  if (lw) then
  
    if (target and target ~= '') then
      send('queue ' .. target .. ' respell is already queued')
    end
    
  else
    
    local co
    
    player.pendingRespell = true
    
    common.getAffects( function (affects)
      
      local respellFailed = false
      local failMessage = ''
  
      co = coroutine.create(function()
      
        for spell, affectText in pairs(buffs) do 
        
              
          if (not respellFailed and not affects[affectText]) then
            njs50.cast(spell, {
              queueSpellImprove = queueSpellImprove,
              callback = function ()
                local ok, errorMsg = coroutine.resume(co)
                if not ok then
                  error("Error in co-routine respell: " .. errorMsg)
                end
              end,
              failCallback = function(msg)
                respellFailed = true
                failMessage = msg
                local ok, errorMsg = coroutine.resume(co)
                if not ok then
                  error("Error in co-routine respell: " .. errorMsg)
                end
              end
            })
            coroutine.yield()
          end 
  
        end
        
        player.pendingRespell = nil
        
        
        if (respellFailed) then
           
          cecho('\n&lt;red&gt;RESPELL: &lt;white&gt;failed! - ' .. failMessage .. '\n\n')
          
          if (target and target ~= '') then
            send('queue ' .. target .. ' ' .. failMessage .. ' (' .. player.name .. ')')
          end
          
          if fcb then fcb() end
               
        else
        
          cecho('\n&lt;green&gt;RESPELL: &lt;white&gt;completed!\n\n')
          
          if (target and target ~= '') then
            send('queue ' .. target .. ' respell done (' .. player.name .. ')')
          end
          
          njs50.onNextEvent(common.events.PARSED_INVENTORY, function()
            if (cb) then tempTimer(0, cb) end
          end)
          send('inventory')
  
        end
        
      end)
    
      local ok, errorMsg = coroutine.resume(co)
      if not ok then
        error("Error in co-routine respell: " .. errorMsg)
      end
      
    end)
    
  end
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>player.manageInventory</name>
			<packageName></packageName>
			<script>player = player or {}

player.keepInPack = player.keepInPack or {}

-- player.keepInPack = {
  -- ["a spotted cheetah skin"] = true,
  -- ["a shadowy rod"] = true,
  -- ["a feather-tipped rod"] = true,
  -- ["a pearl"] = true,
  -- ["a feathered talisman"] = true,
  -- ["a multicoloured belt of the elements"] = true,
  -- ["a cottonwood rod of presage"] = true,
  -- ["a dowsing stick"] = true,
  -- ["a soft, snow-white bear skin"] = true,
  -- ["a shadowbox"] = true
-- }

player.manageInventory = function(evt, data)
  
  local moveItems = {}
  
-- "a soft, snow-white bear skin"

  for item, qty in pairs(player.inventory) do
    
    -- ffs. "a poop might" become "an enchanted poop" if you are detecting magic
    item = common.itemSanitize(item)
    
    altItem = rex.gsub(item, [[^an? ]], 'a ')
    
    if (player.keepInPack[item] or player.keepInPack[altItem]) then
    
      -- lua common.itemShorten("a soft, snow-white bear skin")
      local itemStr = ''
      
      if (qty &gt; 1) then
        itemStr = tostring(qty) .. '*'
      end
      
      itemStr = itemStr .. common.itemShorten(item)
      
      table.insert(moveItems, itemStr)
      
    end
  
  end
    
  if (#moveItems &gt; 0) then
    send('put ' .. table.concat(moveItems, ',') .. ' in ' .. player.pack)
  end

end</script>
			<eventHandlerList>
				<string>COMMON:parsed_inventory_contents</string>
			</eventHandlerList>
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>combat</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
combat = combat or {
	active = false,
	mobs = 0,
	clear_timer = nil,
	sleeping_mob = false
}

combat.roomClearDelay = 5

-- starting a 4 sec timer to make sure nothing else
-- wants to get fighty before declaring the room clear
combat.startTimer = function ()
	if(combat.clear_timer) then
		-- cecho('&lt;yellow&gt;&lt;-- restarting room clear timer\n')
		combat.clearTimer()
	end  
  -- cecho('&lt;yellow&gt;&lt;-- setting room clear timer for 5s\n')
	combat.clear_timer = tempTimer(combat.roomClearDelay, function()
    combat.clear_timer = nil
    -- cecho('&lt;yellow&gt;&lt;-- running on room clear\n')
    combat.onRoomClear()
  end, 'combat clear timer')
end

combat.onRoomClear = function ()
	-- cecho('&lt;green&gt;&lt;-- room is clear ...\n')
  combat.clearTimer()
	if (murder.enabled and not murder.speedwalking and player.position == 'standing') then
    murder.scan('room clear')
	end
  -- cecho('&lt;green&gt;&lt;-- CLEAR (no combat for ' .. tostring(combat.roomClearDelay) .. ' seconds)!!! \n')
  raiseEvent(common.events.ROOM_CLEAR)
end


combat.clearTimer = function()
	if (combat.clear_timer) then
    -- cecho('&lt;yellow&gt;&lt;-- room clear timer cancelled ...\n')
		killTimer(combat.clear_timer)
	end
	combat.clear_timer = nil
end

combat.reset = function()
  -- cecho('&lt;yellow&gt;&lt;-- room found - reseting combat timer\n')
	combat.startTimer()
end

combat.extendRoomCheck = function ()

	if (combat.clear_timer) then
		-- cecho('&lt;green&gt;&lt;-- EXTEND ROOM CLEAR CHECK\n')
		combat.clearTimer()
    combat.startTimer()
	end

end

combat.start = function()
	
  if (not combat.active) then
    combat.startTime = getEpoch()
		combat.active = true
		-- cecho(' &lt;white&gt;&lt;-- -=[ COMBAT started ]=-')
		raiseEvent(common.events.COMBAT_STARTED)
    combat.clearTimer()
	end

end

combat.finish = function ()
	
  if (combat.active) then
    combat.active = false
    	cecho(' &lt;white&gt; -=[ combat ended ]=-')
    if (group.leader == player.name) then
      murder.scan('combat ended')
    else
      cecho('&lt;green&gt;&lt;-- skipped scan due to not being leader\n')
    end
      
    	raiseEvent(common.events.COMBAT_ENDED, getEpoch() - combat.startTime)
    	combat.startTimer()
  end

end


-- reset timer if we change rooms
if (combat.eventWatcher) then
  killAnonymousEventHandler(combat.eventWatcher)
  combat.eventWatcher = nil
end
combat.eventWatcher = registerAnonymousEventHandler('tfe mapper: room found', combat.reset)


-- kill the pending combat timer if room is announced clear elsewhere i.e from scan results
if (combat.clearEventWatcher) then
  killAnonymousEventHandler(combat.clearEventWatcher)
  combat.clearEventWatcher = nil
end

combat.clearEventWatcher = registerAnonymousEventHandler(common.events.ROOM_CLEAR, function()
  cecho('&lt;green&gt;&lt;-- room clear event happened\n')
  combat.clearTimer()
end)



</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>trigger helpers</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

-- moved to common
common.timedTempTrigger = njs50.timedTempTrigger
timedTempTrigger = njs50.timedTempTrigger

common.killTimedTempTrigger = njs50.killTimedTempTrigger
killTimedTempTrigger = njs50.killTimedTempTrigger


common.onNextEvent = function (evt, callback)

	if not evt then

		echo('no event defined!!!')
		error()

	end


	local handlerId = nil
	local cb2 = callback

	local cb = function (evt, args)
		-- kill the event handler now in case the event errors preventing it's destruction
		killAnonymousEventHandler(handlerId)
		-- cecho('\n&lt;blue&gt;self destructing handler: ' .. evt .. ' : ' .. tostring(handlerId) .. '\n')
		cb2(evt, args)
	end

	handlerId = registerAnonymousEventHandler(evt, cb, true)

	-- cecho('\n&lt;green&gt;registering self destruct event: ' .. evt .. ' : ' .. tostring(handlerId) .. '\n')

	return function ()
		-- cecho('\n&lt;orange&gt;destructing handler: ' .. evt .. ' : ' .. tostring(handlerId) .. '\n')
		killAnonymousEventHandler(handlerId)
	end

end

onNextEvent = common.onNextEvent

common.oneRoomExitTrig = function (direction, code)

  local tempTrigId = tempRegexTrigger('^You see no exit to the (' .. direction .. ')\.$', function ()
		code(matches[2])
	end, 1)

  echo(' &lt;- room sepecific trig: ' .. tostring(tempTrigId))

	-- need to dest these as the first room change will be entering the room where we
	-- want to watch for the event
	common.onNextEvent(tfe.events.ROOM_CHANGED, function ()
		-- got to wait for a prompt or else this will trigger on the same event as the first
		common.onNextEvent(common.events.PARSED_PROMPT, function ()
      common.onNextEvent(tfe.events.ROOM_CHANGED, function ()
      	echo('\n ^^ killed room specific trig : '  .. tostring(tempTrigId) .. '\n')
        killTrigger(tempTrigId)
      end)
		end)
	end)

end

oneRoomExitTrig = common.oneRoomExitTrig


common.clearTriggers = function(aTriggers)
  for i, j in pairs(aTriggers) do 
    killTrigger(j)
  end
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>team</name>
			<packageName></packageName>
			<script>common.includeInRollCalls = {
  Mojune = true,
  Mohoonay = true,
  Myrth = true,
  Grehild = true,
  Darion = true,
  Darius = true,
  Bimgore = true,
	-- Marial = true,
	-- Grackle = true,
  -- Raksha = true,
  -- Gnodrick = true,
  Grexil = true,
}

common.groupDo = function (command)
  send('gt time to ' .. command)
  for member in pairs(group.members) do
    if (not common.includeInRollCalls[member]) then
      send('tell ' .. member .. ' do ' .. command)
    end
  end
end


common.comeToMe = function (callback)

  local roll = common.newRollCall(true)
  

  if (#table.keys(roll) == 1) then
    cecho('\n&lt;yellow&gt;COMMON: &lt;white&gt;skipping regroup due to only one party member\n\n')
    callback()
    return
  end


	local mcb = callback
	

	tempTimer(2, function ()

		local atTrig

		local preFetchState = mapper.paused

		mapper.paused = true

  	atTrig = tempRegexTrigger([[^.+ reports group status[^:]*: "(\w+) is now at (\d+)"]], function ()
  		if (tostring(tfe.roomInfo.vnum) == matches[3]) then

				roll[matches[2]] = true

				if (common.rollCheck(roll)) then
					mapper.paused = preFetchState
					send('gstat all here - moving...')
  				killTrigger(atTrig)
  				mcb()
				end

			else
				send('mutter')
				send('gstat ' .. matches[2] .. ' go to ' .. tostring(tfe.roomInfo.vnum))
			end

  	end)

		send('gstat meet at ' .. tostring(tfe.roomInfo.vnum))


	end, 'comeToMe')

end

common.collectFollowers = function (callback)

	if (not murder.paused) then
		murder.pause()
	end


	local roll = common.newRollCall(true)

	send('stand &amp; remove blanket')

	local outStandingResponses = group.memberCount - 1

	local onAllResponded = function ()

  	for key, value in pairs(roll) do
  		if (value ~= true) then
  			cecho('\n\n&lt;red&gt;MURDER: &lt;white&gt;' .. key .. ' is lost at ' .. tostring(value) .. '\n')
				tfe.gotoRoom(value, function()
          tempTimer(3, function()
					 common.collectFollowers(callback)
           end, 'finding next follower?')
				end)
				return
  		end
  	end

		-- if we got to here then everyone is here already
		cecho('\n\n&lt;green&gt;MURDER: &lt;white&gt;everyone is collected now!\n')
		if (murder.paused) then
  		murder.resume()
  	end
		callback()

	end


	tempRegexTrigger([[^.+ reports group status[^:]*: "(\w+) is at (\d+)"]], function ()

		local vnum = tonumber(matches[3])

		if (tfe.roomInfo.vnum == vnum) then
			roll[matches[2]] = true
		else
			roll[matches[2]] = vnum
		end

		outStandingResponses = outStandingResponses - 1

		if (outStandingResponses == 0) then
			onAllResponded()
		end

	end, outStandingResponses)

	send('gstat where are you?')

end


common.fixConditions = function (callback)

	if (not murder.paused) then
		murder.pause()
	end

	local roll = common.newRollCall(false)

	local healthyCheckId = tempRegexTrigger([[^.+ reports? group status: "healthy - (\w+)"]], function ()
		local vic = matches[2]
		if (vic == 'You') then vic = player.name end
		roll[matches[2]] = true
	end)

	send('gstatus condition report')

	tempTimer(5, function ()

		killTrigger(healthyCheckId)

		if common.rollCheck(roll) then
			send('gstatus all healthy')
			if (murder.paused) then
    		murder.resume()
    	end
  		if callback then callback() end
		else
			send('gstatus not yet healthy enough... retrying')
			tempTimer(10, function()
				common.fixConditions(callback)
			end, 'waiting for cures before checking conditions')
		end

	end)

end


common.newRollCall = function (excludeSelf)

	local roll = {}

	for name, value in pairs(group.members) do
    if (common.includeInRollCalls[name]) then
		  roll[name] = false
    end
	end

	if (excludeSelf) then
		roll[player.name] = true
	end

	return roll

end

common.rollCheck = function(roll)

	for key, value in pairs(roll) do
		if (not value) then
			return false
		end
	end
	return true

end



common.sendPlayer = function (player, rnum, callback)

	local ncb = callback
	tempRegexTrigger([[^.+ reports group status[^:]*: "]] .. player .. [[ is now at ]] .. tostring(rnum) .. [["]], function ()
		ncb()
	end, 1)

	send('gstat ' .. player .. ' go to ' .. tostring(rnum))

end

common.groupOnReady = function (cb)

	local grcb = cb

	local rct

	local roll = common.newRollCall(false)


	local readyCheck = function ()
		if (common.rollCheck(roll)) then -- group members
			killTrigger(rct)
  		if (grcb) then
  			grcb()
  		end
		end
	end
  
  display(roll)

	rct = tempRegexTrigger([[^.* reports? group status[^:]*: "ready \((.*)\)"]], function ()
		roll[matches[2]] = true
		readyCheck()
	end)

end

common.groupPrepIfUnder = function (options)

  local cb = options.callback or function() end

  local cmd = 'gstat report if '

  
  if (options.mana) then
    cmd = cmd .. 'mana &lt; ' .. tostring(options.mana) .. '%, '
  end
   
  if (options.heals) then
    cmd = cmd .. 'heals &lt; ' .. tostring(options.heals) .. 'hp, '
  end 

  if (options.storms) then
    cmd = cmd .. 'storms &lt; ' .. tostring(options.storms) .. ', '
  end 
  
  cmd = cmd:gsub(', $', '')
  
  njs50.timedTempTrigger(7, 1, [[^[^"]+ reports? group status: "need prep"$]], function()
   
    common.groupOnReady(function ()
    		send('gstat mudering continues')
    		cb()
    	end)   
   
    if (options.type == 'full') then
      send('gstat pfull')
    elseif (options.type == 'free') then
      send('gstat pfree')
    else
      send('gstat get ready')
    end  
      
  end, function()
    send('gstat mudering continues')
    cb()
  end)
  
  
  
	send(cmd)

end

common.groupPrepFree = function (cb)

	local pfcb = cb

  if (group.memberCount == 1) then
    cecho('\n&lt;yellow&gt;COMMON: &lt;white&gt;skipping group prep full due to only one party member\n\n')
    player.prepFull(pfcb)
    return
  end

	common.groupOnReady(function ()
		send('gstat going')
		if (pfcb) then
			pfcb()
		end
	end)

	send('gstat pfree')

end


common.groupPrepFull = function (cb)

	local pfcb = cb

  if (group.memberCount == 1) then
    cecho('\n&lt;yellow&gt;COMMON: &lt;white&gt;skipping group prep full due to only one party member\n\n')
    player.prepFull(pfcb)
    return
  end

	common.groupOnReady(function ()
		send('gstat going')
		if (pfcb) then
			pfcb()
		end
	end)

	send('gstat get full')

end
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>status checks / prep</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

common.getAffects =  function (cb)
	common.onNextEvent(common.events.PARSED_AFFECTS, function (evt, affects)
		cb(affects)
	end)
	send('affects')
end

common.onClear = function(action)
	common.onNextEvent(common.events.ROOM_CLEAR, action)
end


common.checkShields = function (cbGood, cbBad)


  -- Affect                                            Source
  --
  -- ------                                            ------
  -- You sense a divine protection.                    leech: a male vyan
  -- You feel righteous.                               leech: a male vyan

	local affectWatcher = nil

	local tempAffects = false
	local affectCount = 0

	local okayTempAffects = {
		['You feel sick!'] = true,
		['Your battlemind is divinely focused.'] = true,
		['You are embraced by earthen protection.'] = true,
	}

	common.getAffects( function (affects)



		for affect, source in pairs(affects) do




  		if (source == 'temporary') then
  			-- earthen protection is always tempporary
  			if not okayTempAffects[affect] then
  				cecho('&lt;white&gt;--== &lt;red&gt;expiring : ' .. affect .. ' &lt;white&gt; =-\n')
  				tempAffects = true
  			end

  		end
  		affectCount = affectCount + 1

		end

		if (tempAffects) then
			cecho('\n&lt;red&gt;WARNING: &lt;white&gt;Affects Checked!, some shields will expire!\n')
			if (cbBad) then
				cbBad(player.affects)
			end
		else
			cecho('\n&lt;green&gt;Affects Checked!, ' .. tostring(affectCount) .. ' affects are good\n')
			if (cbGood) then
				cbGood(player.affects)
			end
		end

	end)


end
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>check resources</name>
			<packageName></packageName>
			<script>
common.updateStatus = function(callback)
  common.onNextEvent(common.events.PARSED_GROUP, function ()
  	  callback()
  end)
	send('group')
end

common.checkFull = function(callback)
	return common.checkResources(player.hp_max, player.mp_max, player.moves_max * 0.6)
end


common.onOffsetReady = function(lessHp, lessMp, lessMoves, callback)

	local readyStatus = common.checkResources(player.hp_max - lessHp, player.mp_max - lessMp, player.moves_max - lessMoves)
	
  if(readyStatus) then
		callback()
	else
    common.checkFullTimer = njs50.onNextEvent('gmcp.Char.Vitals', function()
			common.checkFullTimer = nil
			common.onOffsetReady(lessHp, lessMp, lessMoves, callback)
    end)
	end

end


common.onManaReady = function(mana, callback)

	local readyStatus = common.checkResources(0, mana, 0)
  
	if(readyStatus) then
		callback()
	else
    common.checkFullTimer = njs50.onNextEvent('gmcp.Char.Vitals', function()
			common.checkFullTimer = nil
			common.onManaReady(mana, callback)
    end)
	end


end


common.checkResources = function(hp, mp, moves)

	if (gmcp.Char.Vitals.hp &gt;= hp and gmcp.Char.Vitals.en &gt;= mp and gmcp.Char.Vitals.mv &gt;= moves) then
		echo('\n\n .. READY TO KILL\n')
		return true
	else
		echo('\n\n .. sleep more little tank\n')
		return false
	end

end



common.checkFull = function()
	return common.checkResources(player.hp_max, player.mp_max * 0.95, player.moves_max * 0.6)
end

-- [ 75 Pal Ogr   ] Darion              1510/1520  763/1038   306/321     16,597,229
-- [ 75 Pal Ogr   ] Darion              1440/1576   708/728   291/296     16,597,229

common.onFullish = function (hp, mp, moves, callback)

	local readyStatus = common.checkResources(hp, mp, moves)

	if(readyStatus) then
		callback()
	else 
    common.checkFullTimer = njs50.onNextEvent('gmcp.Char.Vitals', function()
			common.checkFullTimer = nil
			common.onFullish(hp, mp, moves, callback)
    end)
	end

end


common.onFull = function (callback)

	local readyStatus = common.checkFull()

	if(readyStatus) then
		callback()
	else 
    common.checkFullTimer = njs50.onNextEvent('gmcp.Char.Vitals', function()
			common.checkFullTimer = nil
			common.onFull(callback)
    end)
	end

end
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>conversions from old code</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------

mapper = mapper or {}
murder = murder or {}

murder.tankState = murder.tankState or 'here'

mapper.gotoRoom = function(rnum, callback)
  tfe.gotoRoom(rnum, {callback = callback})
end
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>combat.hit</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------

combat = combat or {}

combat.hit = function(evt, attackData)

  -- deleteLine()
  cecho('&lt;green&gt;ATK:&lt;white&gt; ' .. attackData.subject .. ' : ' .. attackData.damage)

  -- display(attackData)
end</script>
			<eventHandlerList>
				<string>COMMON::combat_attack</string>
			</eventHandlerList>
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>tfe.char_fighting</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------

tfe = tfe or {}

tfe.char_fighting = function ()

  local fighting = gmcp.Char.Fighting or {}
  
  -- display(gmcp.Char)

  local count = 0

  for mob, state in pairs(gmcp.Char.Fighting) do
    count = count + 1
  end
  
  combat.mobs = count
  
  if (count == 0 and combat.active) then
    if (combat.finshDelayTimer ~= nil) then
      killTimer(combat.finshDelayTimer)
      combat.finshDelayTimer = nil
    end 
    combat.finishPending = true
    combat.finshDelayTimer = tempTimer(1, function()
      combat.finish()
      combat.finshDelayTimer = nil
      combat.finishPending = nil
    end)
  elseif (count &gt; 0 and not combat.active) then
    if (combat.finshDelayTimer ~= nil) then
      killTimer(combat.finshDelayTimer)
      combat.finshDelayTimer = nil
    end 
    combat.start()
  end

end

</script>
			<eventHandlerList>
				<string>gmcp.Char.Fighting</string>
			</eventHandlerList>
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>improves</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------

improves = improves or {}

improves.castQueue = improves.castQueue or {}

improves.fillerSpell = 'filler'

improves.castFillerLastTick = true

improves.queueSpell = function(spell)
  if (not table.contains(improves.castQueue, spell)) then
	 table.insert(improves.castQueue, spell)
  end
end


improves.setFiller = function (spell)
	improves.fillerSpell  = spell
end

improves.resetFiller = function ()
	improves.fillerSpell = 'filler'
end




improves.castSpell = function (cb)
  
  cb = cb or function() end
  
	if (#improves.castQueue == 0) then
    
    cecho('\n\n -= improve filler =-\n\n')
    if type(improves.fillerSpell) == 'string' then 
  	  expandAlias(improves.fillerSpell)
      cb()
    elseif type(improves.fillerSpell) == 'function' then   
      improves.fillerSpell(cb)
    end
    
    improves.castFillerLastTick = true

	else

		if (improves.castFillerLastTick) then

			improves.castFillerLastTick = false
			cecho('\n\n -= holding filler for real spell next tick =-\n\n')
      cb()

		else

			local spell = table.remove(improves.castQueue, 1)
			improves.castFillerLastTick = true
			cecho('\n\n -= ' .. spell .. ' =-\n\n')
			send(spell)
      cb()

		end

	end

end

improves.defaultMageList = {
  'shock',
  'burning hands',
  'chilling touch',
  'corrosive touch',
  'fireball',
  'freeze',
  'lightning bolt',
  -- 'sleep',
  'acid blast',
  -- 'mists of sleep',
  'chain lightning',
  'ice storm',
  'flame strike',
  'acid storm',
  'arc lightning',
  'ice lance',
  'conflagration'
}

improves.druidAoeList = {
  'impede',
  'storm',
  'aqueous spirit',
  'xerotes',
}


improves.spellList = improves.spellList or improves.defaultMageList

improves.setImproveList = function (improveList)
  improves.spellList = improveList
end

improves.improveLeech = function (spell)
  if (player.skills[spell] &lt; 10) then
    improves.queueSpell('cast ' .. spell .. ' &amp; queue leech ' .. spell)
  else
    cecho('\n\n&lt;green&gt; ' .. spell .. ' is maxxed, hooray!\n')
  end
end

improves.getImproveSpellName = function ()

  if (#improves.spellList == 0) then
    return ''
  end

  player.impAttempt = player.impAttempt or 0

  player.impAttempt = (player.impAttempt % #improves.spellList) + 1

  local spell = improves.spellList[player.impAttempt]

  if (player.skills == nil) then
    send('abil all')
  else
    -- remove this maxxed out or unlearned spell and return the next one in the list
    if (player.skills[spell] == nil or player.skills[spell] &gt;= 10 or player.skills[spell] == 0) then
      cecho('\n&lt;yellow&gt;removing ' .. spell .. ' from impprove list\n')
      table.remove(improves.spellList, player.impAttempt)
      return improves.getImproveSpellName()
    end
  end

  return spell

end

improves.getImproveSpell = function ()
  
  local spell = improves.getImproveSpellName()

  if (spell == '') then
    return ''
  end


  return 'cast ' .. spell

end



improves.improveNonCombat = function(improveThings, options)
  
  options.cb = options.cb or function() end
  
  options.hpItem = options.hpItem or 'serp.ring'
  options.bandage = options.bandage or 'a simple bandage'
  
  -- local improveThings = {
    -- 
    -- -- this one is a bit shit because you can't keep doing it in the same room
    -- -- dowse = { cmd = 'cast dowse &amp; |fill cant puddle &amp; |empt cant &amp; |fill cant puddle &amp; |empt cant', level = 7},
    -- 
    -- bandage = { bandage = true, cmd = 'bandage self', reagent = 'a simple bandage', level = 10 },
    -- compress = { bandage = true, cmd = 'compress self', reagent = 'a clump of herbs', level = 10 },
    -- poultice = { bandage = true, cmd = 'poultice self', reagent = 'a thick aloe leaf', level = 10 },
    -- salve = { bandage = true, cmd = 'poultice self', level = 7 },
    -- ['healing mist'] = { heal = true, cmd = 'cast healing mist', level = 7 },
    -- ['healing rain'] = { heal = true, cmd = 'cast healing rain', level = 10 },
    -- 
    -- impede = { cmd = 'cast impede', level = 10},
    -- 
    -- fireflies = { cmd = 'remove gold.ball &amp; | cast fireflies &amp; | remove fireflies &amp; | wear gold.ball', level = 10},
    -- 
    -- squall = { cmd = 'prep squall &amp; |cast squall', level = 10},
    -- storm = { cmd = 'prep storm &amp; |cast storm', level = 10},
    -- blizzard = { cmd = 'prep blizzard &amp; |cast blizzard', level = 7},
    -- tornado = { cmd = 'prep tornado &amp; |cast tornado', level = 7},
    -- tempest = { cmd = 'prep tempest &amp; |cast tempest', level = 10},
    -- 
    -- anemogenesis = { cmd = 'cast anemogenesis', level = 10},
    -- xerotes = { cmd = 'cast xerotes', level = 10},
  -- }
  
  -- display(thing, data)
  local skipThing = true
  
  -- find thing to imp
  for thing, data in pairs(improveThings) do 
   
    if (
      player.lastImproveSkill == nil or 
      thing == player.lastImproveSkill
    ) then
      skipThing = false
    end
    
    if ( not skipThing and
         player.lastImproveSkill ~= thing and
         player.skills[thing] and 
         player.skills[thing] &gt; 0 and 
         player.skills[thing] &lt; data.level 
    ) then
    
      cecho('\n&lt;green&gt;IMPROVE:&lt;white&gt; lets improve ' .. thing .. '\n\n')
  
      
      if (data.bandage) then
  
        common.getReagents(data.reagent, 1, function()
          common.getReagents(options.bandage, 1, function()
            send('|remove ' .. options.hpItem .. ' &amp; |wear ' .. options.hpItem .. ' &amp; |sit')
            send('|' .. data.cmd .. ' &amp; |wait 4 &amp; |stand')
            options.cb()
          end, function()
            cecho('\n\nOut of ' .. options.bandage .. '!!!\n\n')
          end)
        end, function()
          cecho('\n\nOut of ' .. data.reagent .. '!!!\n\n')
        end)
  
      elseif (data.heal) then
  
        send('|remove ' .. options.hpItem .. ' &amp; |wear ' .. options.hpItem .. ' &amp; |' .. data.cmd)
        options.cb()
      
      else
        send('|' .. data.cmd)
        options.cb()
      end
  
      player.lastImproveSkill = thing
      
      
      return
  
    end
  
  end
  
  if (player.lastImproveSkill ~= nil) then
    player.lastImproveSkill = nil
    improves.improveNonCombat(improveThings, options)
  else
    cecho('\n&lt;green&gt;IMPROVE:&lt;white&gt; nothing left to improve!!!\n\n')
    options.cb()
  end
  
end

improves.improveCombat = function(improveThings, target)
  
  -- 
  -- local improveThings = {
    -- 
    -- -- need to keep moving while doing this. bleh
    -- dowse = { cmd = 'cast dowse &amp; |fill cant puddle &amp; |empt cant &amp; |fill cant puddle &amp; |empt cant &amp; |cast gale', level = 7},
    -- 
    -- -- darkness
    -- nocturne = { cmd = 'cast nocturne', level = 7},
    -- gloom = { cmd = 'cast gloom', level = 10},
    -- shadowstrike = { cmd = 'cast shadowstrike', level = 7},
    -- ['veil of darkness'] = { cmd = 'cast veil of darkness', level = 10},
    -- 
    -- -- for healing
    -- ['aqueous surge'] = { cmd = 'cast aqueous surge', level = 7},
    -- ['aqueous spirit'] = { cmd = 'cast aqueous spirit', level = 7},
    -- 
    -- -- wind
    -- gust = { cmd = 'cast gust', level = 7},
    -- ['wind shear'] = { cmd = 'cast wind shear', level = 7},
    -- gale = { cmd = 'cast gale', level = 10},
    -- whirlwind = { cmd = 'cast whirlwind', level = 10},
    -- 
    -- -- util
    -- undergrowth = { cmd = 'cast undergrowth', level = 10},
    -- 
    -- -- drying (for xerotes)
    -- dry = { cmd = 'cast dry', level = 10},
    -- parch = { cmd = 'cast parch', level = 7},
    -- desiccate = { cmd = 'cast desiccate', level = 7},
    -- 
    -- -- aoe (optional)
    -- blizzard = { cmd = 'prep blizzard &amp; |cast blizzard &amp; |sigh', level = 7},
    -- 
  -- }
  
  -- display(thing, data)
  local skipThing = true
  
  -- find thing to imp
  for thing, data in pairs(improveThings) do 
   
    if (
      player.lastImproveSkill == nil or 
      thing == player.lastImproveSkill
    ) then
      skipThing = false
    end
    
    if ( not skipThing and
         player.lastImproveSkill ~= thing and
         player.skills[thing] and 
         player.skills[thing] &gt; 0 and 
         player.skills[thing] &lt; data.level 
    ) then
    
      cecho('\n&lt;green&gt;IMPROVE:&lt;white&gt; lets improve ' .. thing .. '\n\n')
  
      player.lastImproveSkill = thing
      
      return data.cmd .. ' ' .. target
  
    end
  
  end
  
  if (player.lastImproveSkill ~= nil) then
    player.lastImproveSkill = nil
    return improves.improveCombat(improveThings, target)
  else
    cecho('\n&lt;green&gt;IMPROVE:&lt;white&gt; nothing left to improve!!!\n\n')
    return ''
  end
  
end
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>channel.update</name>
			<packageName></packageName>
			<script>channel = channel or {}

channel.seq = channel.seq or {}

local chatTabs = {
  Gossip = 'Public',
  OOC =  'Public',
  UC =  'Public',
  ATALK =  'Public',
  Yell =  'Public',
  Ctell =  'Clan',
  Tell = 'Tell',
  Cstatus = nil,
  Gtell = 'Group',
  Gstatus = nil,
  Log = 'Log',
  Other = 'Other',
}


channel.update = function()

  for chan, status in pairs(gmcp.Channels) do
  
    if (channel.seq[chan] == nil or channel.seq[chan] ~= status.sequence) then
      channel.seq[chan] = status.sequence
  
      
      if (chatTabs[chan]) then
        -- 
        local excludeAll = false
        
        if chan == 'Tell' and rex.find(status.message, [[^(do |repopped|location:|ee |ack:|running command)]]) then
          chan = 'Log'
          excludeAll = true
        end
        
        if (chan == 'Yell' and (status.language == 'unknown' or status.language == 'primal')) then
          chan = 'Other'
          excludeAll = true        
        end    
        
        local message = '[' .. chan .. '] ' .. status.who .. ': ' .. status.message
        common.consoleMessage(chatTabs[chan], message, 'green', excludeAll)
        
      end
      
    end
    
  end
  

end</script>
			<eventHandlerList>
				<string>gmcp.Channels</string>
			</eventHandlerList>
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>leveling tools</name>
			<packageName></packageName>
			<script>tools = tools or {}

tools.weapCheck = function(failcb)
  common.getWeaponCondition(function(weaponConditon)
    -- display(weaponConditon)
    if (weaponConditon &lt; common.conditions["very worn"]) then
      cecho('\n\n&lt;green&gt;CHECK&lt;white&gt;: weapon needs fixing' .. tostring(weaponConditon) .. '\n\n')
      if (failcb) then failcb() end
    else
      cecho('\n\n&lt;green&gt;CHECK&lt;white&gt;: weapon okay still ' .. tostring(weaponConditon) .. '\n\n')
    end
  end)
end</script>
			<eventHandlerList />
		</Script>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>gmcp-group</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>gcmp healer</name>
				<packageName></packageName>
				<script>common = common or {}


local convertRecord = function (record)
  return {
    mp_max = record.maxen,
    mp = record.en,
    moves_max = record.maxmv,
    hp = record.hp,
    hp_max = record.maxhp,
    moves = record.mv
  }
end


common.updateGMCPTimer = nil;

common.updateFromGMCP = function()

  -- skip if gmcp is not fully init
  if (not gmcp.Char.Score) then
    cecho('&lt;yellow&gt; &lt;-- (gmcp update but not fully init)')
    return
  end

  if (common.updateGMCPTimer ~= nil) then
    -- cecho('&lt;yellow&gt; &lt;-- (update already pending)')
    return
  end
       
  common.updateGMCPTimer = tempTimer(0.1, function()
      
    local playerStats = convertRecord(gmcp.Char.Vitals)
    
    group.lowest_moves = gmcp.Group.minmv
    group.leader = gmcp.Group.leader
    
    group.memberCount = 1
    
    group.members = {[gmcp.Char.Score.name] = true}
    group.data = {[gmcp.Char.Score.name] = playerStats}
    
      
    for stat, val in pairs(playerStats) do
      player[stat] = val
    end
    
    
    if (gmcp.Group.members) then
      for name, stats in pairs(gmcp.Group.members) do
        group.memberCount = group.memberCount + 1
        group.members[name] = true
        group.data[name] = convertRecord(stats)
      end
    end
  
    raiseEvent(common.events.PARSED_GROUP);
    common.updateGMCPTimer = nil;
    -- cecho('&lt;green&gt; &lt;--- &lt;white&gt;data updated!!\n')
  end, 'gmcp update')
  
  -- cecho('&lt;orange&gt; &lt;-- update queued...\n')
  
end


-- 
-- healer.reducePlayerHp = function(subject, amount)
  -- 
  -- group[subject].hp = group[subject].hp - amount
  -- 
  -- -- if the player is us...
  -- if (player.name == subject) then
    -- player.hp = player.hp - amount
  -- end
  -- 
  -- cecho('&lt;red&gt;HP: &lt;white&gt;' .. subject .. ': ' .. tostring(group[subject].hp))
  -- 
  -- healer.check_player_health(subject)
  -- 
-- end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>common.groupUpdateGMCP</name>
				<packageName></packageName>
				<script>
common.groupUpdateGMCP = function ()

  -- cecho('&lt;green&gt; &lt;-- group updated ')
  common.updateFromGMCP()

end</script>
				<eventHandlerList>
					<string>gmcp.Group</string>
				</eventHandlerList>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>common.playerUpdateGMCP</name>
				<packageName></packageName>
				<script> -- display(gmcp.Group)
 
common.playerUpdateGMCP = function ()
  -- cecho('&lt;green&gt; &lt;-- player updated ')
  common.updateFromGMCP()
end</script>
				<eventHandlerList>
					<string>gmcp.Char.Vitals</string>
				</eventHandlerList>
			</Script>
			<Script isActive="no" isFolder="no">
				<name>common.playerHitEvent</name>
				<packageName></packageName>
				<script>common.playerHitEvent = function (evt, data)

  -- healer.reducePlayerHp(data.subject, data.amount)

end</script>
				<eventHandlerList>
					<string>COMMON::combat_player_hit</string>
				</eventHandlerList>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>common.groupClearUpdateTimer</name>
				<packageName></packageName>
				<script>common.groupClearUpdateTimer = function()
  common.updateGMCPTimer = nil
  cecho('&lt;yellow&gt; &lt;-- (cleared update gmcp timer)')
end

-- this one is for initial mod load in case it was already set
common.updateGMCPTimer = nil</script>
				<eventHandlerList>
					<string>gmcp.Room.Info</string>
				</eventHandlerList>
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Damage Meter</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>damage meter</name>
				<packageName></packageName>
				<script>damageMeter = damageMeter or {}

damageMeter.start = function ()

  if (damageMeter.combatEndWatcher) then
    killAnonymousEventHandler(damageMeter.combatEndWatcher)
    damageMeter.combatEndWatcher = nil
  end
  
  damageMeter.combatEndWatcher = registerAnonymousEventHandler(common.events.COMBAT_ENDED, damageMeter.combatTimer)


  damageMeter.reset()
  damageMeter.startTime = getEpoch()
  damageMeter.recording = true
  damageMeter.combatTime = 0
end

damageMeter.stop = function ()
  damageMeter.stopTime = getEpoch()
  damageMeter.recording = false
end

local updateDamageRecord = function(record, amount) -- , type
  record.count = record.count or 0
  record.count = record.count + 1
  record.amount = record.amount or 0
  record.amount = record.amount + amount
  -- record.spells = record.spells or {}
  
  -- if (type) then
    -- record.type = type
  -- end
  -- i don't think we need to keep this...
  -- record.amounts = record.amounts or {}
  -- table.insert(record.amounts, amount)
end

damageMeter.record = function (dealer, amount, target, type, spell)

  -- echo(' &lt;- ' .. type .. ' ' .. dealer .. ' : ' .. tostring(amount))
  -- deleteLine()
  
  -- if (type == 'no-damage') then
    -- cecho('\n\n&lt;green&gt;[DAMAGE METER] &lt;white&gt;non damage hit ' .. spell .. '\n\n')
  -- end
  
  if (damageMeter.recording) then
  
    damageMeter.byMember[dealer] = damageMeter.byMember[dealer] or {}
  
    local record = damageMeter.byMember[dealer]
  
    -- record.spell = record.spell or {}
    record.type = record.type or {}

    record.type[type] = record.type[type] or {}
    record.type[type].spells = record.type[type].spells or {}
    record.type[type].spells[spell] = record.type[type].spells[spell] or {}
    
    -- record.spell[spell] = record.spell[spell] or {}
  
    updateDamageRecord(record.type[type], amount)
    updateDamageRecord(record.type[type].spells[spell], amount)
    
    -- updateDamageRecord(record.spell[spell], amount, type)
  
  end

end

damageMeter.reset = function ()
  damageMeter.recording = false
  damageMeter.stopTime = nil
  damageMeter.byMember = {}
  -- damageMember.byTarget = {}
end

damageMeter.report = function(target, chan)

  chan = chan or 'cecho'

  if (target and group.members[target]) then
    damageMeter.reportPlayer(target, chan)
    return
  end
  
  
  local time = damageMeter.combatTime or 1
  local elapsedTime = (damageMeter.stopTime or getEpoch()) - damageMeter.startTime
  
  
  common.sendToChan(chan, '\n&lt;green&gt;Damage')
  common.sendToChan(chan, '&lt;white&gt;Combat Time: ' .. common.formatElapsedTime(time))
  common.sendToChan(chan, '&lt;white&gt;Elapsed Time: ' .. common.formatElapsedTime(elapsedTime) .. '\n')
  
  
  for member, cats in pairs(damageMeter.byMember) do
    
    local total = 0
    
    for dt, stats in pairs(cats.type) do
      total = total + stats.amount
    end
    
    local dps = math.floor(100 * total / time) / 100
    
    common.sendToChan(chan,
      demonnic:cfText(
        member, 
        {
          alignment = "left", 
          width = 15, 
          spacer = ".", 
          inside = true, 
          textColor = "&lt;green&gt;"
        }
      ) ..
      demonnic:fText(
        tostring(dps), 
        {
          alignment = "right", 
          width = 10, 
          spacer = ".", 
          textColor = "&lt;white&gt;"
        }
      ) ..
      ' dps'
    ) 
  end
  
  if (target and target == 'all') then
    for player, data in pairs(damageMeter.byMember) do
      damageMeter.reportPlayer(player, chan)
    end
  end
  
end

damageMeter.reportPlayer = function(player, chan)

  local time = damageMeter.combatTime or 1
  local elapsedTime = (damageMeter.stopTime or getEpoch()) - damageMeter.startTime
  
  local total = 0
    
  for dt, stats in pairs(damageMeter.byMember[player].type) do
    total = total + stats.amount
  end
  
  
  common.sendToChan(chan, '\n&lt;green&gt;Damage by ' .. player)
  common.sendToChan(chan, '&lt;white&gt;Combat Time: ' .. common.formatElapsedTime(time))
  common.sendToChan(chan, '&lt;white&gt;Elapsed Time: ' .. common.formatElapsedTime(elapsedTime))
  common.sendToChan(chan, '&lt;white&gt;Damage output: ' .. tostring(math.floor(100 * total / time) / 100) .. ' dps\n')
  
  
  if (damageMeter.byMember[player].type.spell) then
    damageMeter.reportByType(chan, 'spell', damageMeter.byMember[player].type.spell, player)
  end
  
  if (damageMeter.byMember[player].type.melee) then
    damageMeter.reportByType(chan, 'melee damage', damageMeter.byMember[player].type.melee, player)
  end
  
  if (damageMeter.byMember[player].type.proc) then
    damageMeter.reportByType(chan, 'procs', damageMeter.byMember[player].type.proc, player)
  end
  
  if (damageMeter.byMember[player].type['no-damage']) then
    damageMeter.reportByType(chan, 'non damage', damageMeter.byMember[player].type['no-damage'], player)
  end

end

damageMeter.reportByType = function(chan, type, rollup, player)

  local data = rollup.spells

  -- 
  testMaker = demonnic.TableMaker:new({
    edgeCharacter = '|'
  })
  
  local meleeHits = 1
  
  if (damageMeter.byMember[player].type.melee) then
    meleeHits = damageMeter.byMember[player].type.melee.count or 1
  end
  
 
  local time = damageMeter.combatTime or 1

  local dataKeys = table.keys(data)
  
  if (type == 'non damage') then
    testMaker:addColumn({name = type, width = 25, textColor = "&lt;green&gt;"})
    testMaker:addColumn({name = "count", width = 10, textColor = "&lt;white&gt;"})
    testMaker:addColumn({name = "% melee", width = 20, textColor = "&lt;purple&gt;"})
    table.sort(dataKeys, function(a,b) return data[a].count &gt; data[b].count end)
  else
    testMaker:addColumn({name = type, width = 25, textColor = "&lt;green&gt;"})
    testMaker:addColumn({name = "average", width = 10, textColor = "&lt;white&gt;"})
    testMaker:addColumn({name = "count", width = 10, textColor = "&lt;white&gt;"})
    testMaker:addColumn({name = "dps", width = 10, textColor = "&lt;purple&gt;"})
    table.sort(dataKeys, function(a,b) return data[a].amount &gt; data[b].amount end)
  end
  
  for idx, spell in ipairs(dataKeys) do
  
    local stats = data[spell]
    
    local avg = math.floor(10 * stats.amount / stats.count) / 10
    local dps = math.floor(100 * stats.amount / time) / 100
    
    local pctMelee = math.floor(10000 * stats.count / meleeHits)  / 100
    
    
    local calcSpecialPct = function(otherSpell, otherType)
      local chargeCt = damageMeter.byMember[player].type[otherType].spells[otherSpell].count or 0
      chargeCt = chargeCt + stats.count
      return math.floor(10000 * stats.count / chargeCt) / 100    
    end
    
    
    
    if (type == 'non damage') then
      if (spell == 'fall down') then 
        pctMelee = calcSpecialPct('charge', 'melee')
        testMaker:addRow({'charge: ' .. spell, tostring(stats.count), tostring(pctMelee) .. '%'})
      elseif (spell == 'revealing') then 
        pctMelee = calcSpecialPct('reveals nothing', 'no-damage')
        testMaker:addRow({'stones: ' .. spell, tostring(stats.count), tostring(pctMelee) .. '%'})     
      elseif (spell == 'reveals nothing') then 
        pctMelee = calcSpecialPct('revealing', 'no-damage')
        testMaker:addRow({'stones: ' .. spell, tostring(stats.count), tostring(pctMelee) .. '%'})               
      else 
        testMaker:addRow({spell, tostring(stats.count), tostring(pctMelee) .. '%'})
      end
    else
      testMaker:addRow({spell, tostring(avg), tostring(stats.count), tostring(dps)})
    end
    
  end
      
  if (type ~= 'non damage') then
    testMaker:addRow({
      'total', 
      tostring(math.floor(10 * rollup.amount / rollup.count) / 10), 
      tostring(rollup.count), tostring(math.floor(100 * rollup.amount / time) / 100)
    })
  end
  
  common.sendToChan(chan, testMaker:assemble())

end

damageMeter.combatTimer = function(evt, duration) 
  damageMeter.combatTime = damageMeter.combatTime + duration
end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>damageMeter.hit</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------

damageMeter = damageMeter or {}

damageMeter.hit = function(evt, attackData)
  if (damageMeter.recording) then
    damageMeter.record(attackData.subject, attackData.damage, attackData.mob, attackData.damageType, attackData.move)
  end
end</script>
				<eventHandlerList>
					<string>COMMON::combat_attack</string>
				</eventHandlerList>
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="no" isFolder="yes">
			<name>auto assist</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>auto_assist</name>
				<packageName></packageName>
				<script>combat = combat or {}
player = player or {}

combat.assistOffCooldown = true

</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>combat.auto_assist_on_attack</name>
				<packageName></packageName>
				<script>

combat.auto_assist_on_attack = function (evt, attackData)
  
  if ( group.leader and 
     player.name ~= group.leader and 
     attackData.subject == group.leader and 
     combat.assistOffCooldown == true and 
     combat.active ~= true
  ) then
    
    combat.assistOffCooldown = false    
    -- enable assist again after 1 second (prevent excessive spam before gmcp combat starts)
    tempTimer(1, function () 
      combat.assistOffCooldown = true
    end)

    local target = common.dotCase(common.toMurderString(attackData.mob))
    
    player.autoAttack(target)
    
  end
  
end
</script>
				<eventHandlerList>
					<string>COMMON::combat_attack</string>
				</eventHandlerList>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>combat.auto_assist_on_room_change</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
combat.auto_assist_on_room_change = function ()
  cecho('&lt;green&gt;&lt;-- room changed')
  combat.assistOffCooldown = true
  
end</script>
				<eventHandlerList>
					<string>tfe mapper: room found</string>
				</eventHandlerList>
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>demonnic</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
			<eventHandlerList />
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>EMCO</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>EMCO</name>
					<packageName></packageName>
					<script>--- Embeddable Multi Console Object.
-- This is essentially YATCO, but with some tweaks, updates, and it returns an object
-- similar to Geyser so that you can a.) have multiple of them and b.) easily embed it
-- into your existing UI as you would any other Geyser element.
-- @module EMCO
EMCO = Geyser.Container:new({
  name = "TabbedConsoleClass",
})

function EMCO:readYATCO()
  local config
  if demonnic and demonnic.chat and demonnic.chat.config then
    config = demonnic.chat.config
  else
    cecho("&lt;white&gt;(&lt;blue&gt;EMCO&lt;white&gt;)&lt;reset&gt; Could not find demonnic.chat.config, nothing to convert\n")
    return
  end
  local constraints = "EMCO:new({\n"
  constraints = string.format("%s  x = %d,\n", constraints, demonnic.chat.container.get_x())
  constraints = string.format("%s  y = %d,\n", constraints, demonnic.chat.container.get_y())
  constraints = string.format("%s  width = %d,\n", constraints, demonnic.chat.container.get_width())
  constraints = string.format("%s  height = %d,\n", constraints, demonnic.chat.container.get_height())
  if config.timestamp then
    constraints = string.format("%s  timestamp = true,\n  timestampFormat = \"%s\",\n", constraints, config.timestamp)
  else
    constraints = string.format("%s  timestamp = false,\n", constraints)
  end
  if config.timestampColor then
    constraints = string.format("%s  customTimestampColor = true,\n", constraints)
  else
    constraints = string.format("%s  customTimestampColor = false,\n", constraints)
  end
  if config.timestampFG then
    constraints = string.format("%s  timestampFGColor = \"%s\",\n", constraints, config.timestampFG)
  end
  if config.timestampBG then
    constraints = string.format("%s  timestampBGColor = \"%s\",\n", constraints, config.timestampBG)
  end
  if config.channels then
    local channels = "consoles = {\n"
    for _,channel in ipairs(config.channels) do
      if _ == #config.channels then
        channels = string.format("%s    \"%s\"", channels, channel)
      else
        channels = string.format("%s    \"%s\",\n", channels, channel)
      end
    end
    channels = string.format("%s\n  },\n", channels)
    constraints = string.format([[%s  %s]], constraints, channels)
  end
  if config.Alltab then
    constraints = string.format("%s  allTab = true,\n", constraints)
    constraints = string.format("%s  allTabName = \"%s\",\n", constraints, config.Alltab)
  else
    constraints = string.format("%s  allTab = false,\n", constraints)
  end
  if config.Maptab and config.Maptab ~= "" then
    constraints = string.format("%s  mapTab = true,\n", constraints)
    constraints = string.format("%s  mapTabName = \"%s\",\n", constraints, config.Maptab)
  else
    constraints = string.format("%s  mapTab = false,\n", constraints)
  end
  constraints = string.format("%s  blink = %s,\n", constraints, tostring(config.blink))
  constraints = string.format("%s  blinkFromAll = %s,\n", constraints, tostring(config.blinkFromAll))
  if config.fontSize then
    constraints = string.format("%s  fontSize = %d,\n", constraints, config.fontSize)
  end
  constraints = string.format("%s  preserveBackground = %s,\n", constraints, tostring(config.preserveBackground))
  constraints = string.format("%s  gag = %s,\n", constraints, tostring(config.gag))
  constraints = string.format("%s  activeTabBGColor = \"&lt;%s,%s,%s&gt;\",\n", constraints, config.activeColors.r, config.activeColors.g, config.activeColors.b)
  constraints = string.format("%s  inactiveTabBGColor = \"&lt;%s,%s,%s&gt;\",\n", constraints, config.inactiveColors.r, config.inactiveColors.g, config.inactiveColors.b)
  constraints = string.format("%s  consoleColor = \"&lt;%s,%s,%s&gt;\",\n", constraints, config.windowColors.r, config.windowColors.g, config.windowColors.b)
  constraints = string.format("%s  activeTabFGColor = \"%s\",\n", constraints, config.activeTabText)
  constraints = string.format("%s  inactiveTabFGColor = \"%s\"", constraints, config.inactiveTabText)
  constraints = string.format("%s\n})", constraints)
  return constraints
end

--- Scans for the old YATCO configuration values and prints out a set of constraints to use.
-- with EMCO to achieve the same effect. Is just the invocation
function EMCO:miniConvertYATCO()
  local constraints = self:readYATCO()
  cecho("&lt;white&gt;(&lt;blue&gt;EMCO&lt;white&gt;)&lt;reset&gt; Found a YATCO config. Here are the constraints to use with EMCO(x,y,width, and height have been converted to their absolute values):\n\n")
  echo(constraints .. "\n")
end

--- Echos to the main console a script object you can add which will fully convert YATCO to EMCO.
-- This replaces the demonnic.chat variable with a newly created EMCO object, so that the main
-- functions used to place information on the consoles (append(), cecho(), etc) should continue to
-- work in the user's triggers and events.
function EMCO:convertYATCO()
  local invocation = self:readYATCO()
  local header = [[
  &lt;white&gt;(&lt;blue&gt;EMCO&lt;white&gt;)&lt;reset&gt; Found a YATCO config. Make a new script, then copy and paste the following output into it.
  &lt;white&gt;(&lt;blue&gt;EMCO&lt;white&gt;)&lt;reset&gt; Afterward, uninstall YATCO (you can leave YATCOConfig until you're sure everything is right) and restart Mudlet
  &lt;white&gt;(&lt;blue&gt;EMCO&lt;white&gt;)&lt;reset&gt; If everything looks right, you can uninstall YATCOConfig. 


-- Copy everything below this line until the next line starting with --
demonnic = demonnic or {}
demonnic.chat = ]]
  cecho(string.format("%s%s\n--- End script\n", header, invocation))
end

function EMCO:checkTabPosition(position)
  if position == nil then
    return 0
  end
  return tonumber(position) or type(position)
end

function EMCO:checkTabName(tabName)
  if not tostring(tabName) then
    return "tabName as string expected, got" .. type(tabName)
  end
  tabName = tostring(tabName)
  if table.contains(self.consoles, tabName) then
    return "tabName must be unique, and we already have a tab named " .. tabName
  else
    return "clear"
  end
end

function EMCO.ae(funcName, message)
  error(string.format("%s: Argument Error: %s", funcName, message))
end

function EMCO:ce(funcName, message)
  error(string.format("%s:gg Constraint Error: %s", funcName, message))
end

--- Adds a tab to the EMCO object
-- @tparam string tabName the name of the tab to add
-- @tparam[opt] number position position in the tab switcher to put this tab
function EMCO:addTab(tabName, position)
  local funcName = "EMCO:addTab(tabName, position)"
  position = self:checkTabPosition(position)
  if type(position) == "string" then self.ae(funcName, "position as number expected, got " .. position) end
  local tabCheck = self:checkTabName(tabName)
  if tabCheck ~= "clear" then self.ae(funcName, tabCheck) end
  if position == 0 then
    table.insert(self.consoles, tabName)
    self:createComponentsForTab(tabName)
  else
    table.insert(self.consoles, position, tabName)
    self:reset()
  end
end

function EMCO:switchTab(tabName)
  local oldTab = self.currentTab
  if oldTab ~= tabName and oldTab ~= "" then
    self.windows[oldTab]:hide()
    self.tabs[oldTab]:setStyleSheet(self.inactiveTabCSS)
    self.tabs[oldTab]:setColor(self.inactiveTabBGColor)
    self.tabs[oldTab]:echo(oldTab, self.inactiveTabFGColor, "c")
    if self.blink then
      if self.allTab and tabName == self.allTabName then
        self.tabsToBlink = {}
      elseif self.tabsToBlink[tabName] then
        self.tabsToBlink[tabName] = nil
      end
    end
  end
  self.tabs[tabName]:setStyleSheet(self.activeTabCSS)
  self.tabs[tabName]:setColor(self.activeTabBGColor)
  self.tabs[tabName]:echo(tabName, self.activeTabFGColor, "c")
  if oldTab and self.windows[oldTab] then
    self.windows[oldTab]:hide()
  end
  self.windows[tabName]:show()
  self.currentTab = tabName
end

function EMCO:createComponentsForTab(tabName)
  local tab = Geyser.Label:new({
    name = string.format("%sTab%s", self.name, tabName)
  }, self.tabBox)
  tab:echo(tabName, self.inactiveTabFGColor, 'c')
  -- use the inactive CSS. It's "" if unset, which is ugly, but
  tab:setStyleSheet(self.inactiveTabCSS)
  -- set the BGColor if set. if the CSS is set it overrides the setColor, but if it's "" then the setColor actually covers that.
  -- and we set a default for the inactiveBGColor
  tab:setColor(self.inactiveTabBGColor)
  tab:setClickCallback("EMCOHelper.switchTab", nil, string.format("%s+%s",self.name, tabName))
  self.tabs[tabName] = tab
  local window
  local windowConstraints = {
    x = 1,
    y = 1,
    height = "-2px",
    width = "100%",
    name = string.format("%sWindow%s", self.name, tabName)
  }
  local parent = self.consoleContainer
  if self.mapTab and tabName == self.mapTabName then
    window = Geyser.Mapper:new(windowConstraints, parent)
  else
    window = Geyser.MiniConsole:new(windowConstraints, parent)
    window:setFontSize(self.fontSize)
    window:setColor(self.consoleColor)
    if self.autoWrap then
      window:enableAutoWrap()
    else
      window:setWrap(self.wrapAt)
    end
    if self.scrollbars then
      window:enableScrollBar()
    else
      window:disableScrollBar()
    end
  end
  self.windows[tabName] = window
  window:hide()
end

--- resets the object, redrawing everything
function EMCO:reset()
  self:createContainers()
  for _,tabName in ipairs(self.consoles) do
    self:createComponentsForTab(tabName)
  end
  local default
  if self.currentTab == "" then
    default = self.allTabName or self.consoles[1]
  else
    default = self.currentTab
  end
  self:switchTab(default)
end

function EMCO:createContainers()
  self.tabBoxLabel = Geyser.Label:new({
    x=0,
    y=0,
    width = "100%",
    height = tostring(tonumber(self.tabHeight) + 2) .. "px",
    name = self.name .. "TabBoxLabel"
  }, self)
  self.tabBox = Geyser.HBox:new({
    x=0,
    y=0,
    width = "100%",
    height = "100%",
    name = self.name .. "TabBox"
  }, self.tabBoxLabel)
  self.tabBoxLabel:setStyleSheet(self.tabBoxCSS)
  self.tabBoxLabel:setColor(self.tabBoxColor)

  local heightPlusGap = tonumber(self.tabHeight) + tonumber(self.gap)
  self.consoleContainer = Geyser.Label:new({
    x = 0,
    y = tostring(heightPlusGap) .. "px",
    width = "100%",
    height = "-0px",
    name = self.name .. "ConsoleContainer"
  }, self)
  self.consoleContainer:setStyleSheet(self.consoleContainerCSS)
  self.consoleContainer:setColor(self.consoleContainerColor)
end

function EMCO:stripTimeChars(str)
  return string.gsub(string.trim(str), '[hHmMszZaApPdy:. ]', '')
end

--- Expands boolean definitions to be more flexible.
-- &lt;br&gt;True values are "true", "yes", "0", 0, and true
-- &lt;br&gt;False values are "false", "no", "1", 1, false, and nil
-- @param bool item to test for truthiness
function EMCO:fuzzyBoolean(bool)
  if type(bool) == "boolean" or bool == nil then
    return bool
  elseif tostring(bool) then
    local truth = {
      "yes",
      "true",
      "0"
    }
    local untruth = {
      "no",
      "false",
      "1"
    }
    local boolstr = tostring(bool)
    if table.contains(truth, boolstr) then
      return true
    elseif table.contains(untruth, boolstr) then
      return false
    else
      return nil
    end
  else
    return nil
  end
end

--- enables custom colors for the timestamp, if displayed
function EMCO:enableCustomTimestampColor()
  self.customTimestampColor = true
end

--- disables custom colors for the timestamp, if displayed
function EMCO:disableCustomTimestampColor()
  self.customTimestampColor = false
end

--- enables the display of timestamps
function EMCO:enableTimestamp()
  self.timestamp = true
end

--- disables the display of timestamps
function EMCO:disableTimestamp()
  self.timestamp = false
end

--- Sets the formatting for the timestamp, if enabled
-- @tparam string format Format string which describes the display of the timestamp. See: https://wiki.mudlet.org/w/Manual:Lua_Functions#getTime
function EMCO:setTimestampFormat(format)
  local funcName = "EMCO:setTimestampFormat(format)"
  local strippedFormat = self:stripTimeChars(format)
  if strippedFormat ~= "" then
    self.ae(funcName, "format contains invalid time format characters. Please see https://wiki.mudlet.org/w/Manual:Lua_Functions#getTime for formatting information")
  else
    self.timestampFormat = format
  end
end

--- Sets the background color for the timestamp, if customTimestampColor is enabled.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setTimestampBGColor(color)
  self.timestampBGColor = color
end
--- Sets the foreground color for the timestamp, if customTimestampColor is enabled.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setTimestampFGColor(color)
  self.timestampFGColor = color
end

--- Sets the 'all' tab name.
-- &lt;br&gt;This is the name of the tab itself
-- @tparam string allTabName name of the tab to use as the all tab. Must be a tab which exists in the object.
function EMCO:setAllTabName(allTabName)
  local funcName = "EMCO:setAllTabName(allTabName)"
  local allTabNameType = type(allTabName)
  if allTabNameType ~= "string" then self.ae(funcName, "allTabName expected as string, got" .. allTabNameType) end
  if not table.contains(self.consoles, allTabName) then self.ae(funcName, "allTabName must be the name of one of the console tabs. Valid options are: " .. table.concat(self.containers, ",")) end
  self.allTabName = allTabName
end

--- Enables use of the 'all' tab
function EMCO:enableAllTab()
  self.allTab = true
end

--- Disables use of the 'all' tab
function EMCO:disableAllTab()
  self.allTab = false
end

--- Enables tying the Mudlet Mapper to one of the tabs.
-- &lt;br&gt;mapTabName must be set, or this will error. Forces a redraw of the entire object
function EMCO:enableMapTab()
  local funcName = "EMCO:enableMapTab()"
  if not self.mapTabName then
    error(funcName .. ": cannot enable the map tab, mapTabName not set. try running :setMapTabName(mapTabName) first with the name of the tab you want to bind the map to")
  end
  self.mapTab = true
  self:reset()
end

--- disables binding the Mudlet Mapper to one of the tabs.
-- &lt;br&gt;CAUTION: this may have unexpected behaviour, as you can only open one Mapper console per profile
-- so you can't really unbind it. Binding of the Mudlet Mapper is best decided at instantiation.
function EMCO:disableMapTab()
  self.mapTab = false
end

--- sets the name of the tab to bind the Mudlet Map.
-- &lt;br&gt;Forces a redraw of the object
-- &lt;br&gt;CAUTION: Mudlet only allows one Map object to be open at one time, so if you are going to attach the map to an object
-- you should probably do it at instantiation.
-- @tparam string mapTabName name of the tab to connect the Mudlet Map to.
function EMCO:setMapTabName(mapTabName)
  local funcName = "EMCO:setMapTabName(mapTabName)"
  local mapTabNameType = type(mapTabName)
  if mapTabNameType ~= "string" then
    self.ae(funcName, "mapTabName as string expected, got" .. mapTabNameType)
  end
  if not table.contains(self.consoles, mapTabName) and mapTabName ~= "" then
    self.ae(funcName, "mapTabName must be one of the existing console tabs. Current tabs are: " .. table.concat(self.consoles, ","))
  end
  self.mapTabName = mapTabName
end

--- Enables tab blinking even if you're on the 'all' tab
function EMCO:enableBlinkFromAll()
  self.enableBlinkFromAll = true
end

--- Disables tab blinking when you're on the 'all' tab
function EMCO:disableBlinkFromAll()
  self.enableBlinkFromAll = false
end

--- Enables gagging of the line passed in to :append(tabName)
function EMCO:enableGag()
  self.gag = true
end

--- Disables gagging of the line passed in to :append(tabName)
function EMCO:disableGag()
  self.gag = false
end

--- Enables tab blinking when new information comes in to an inactive tab
function EMCO:enableBlink()
  self.blink = true
end

--- Disables tab blinking when new information comes in to an inactive tab
function EMCO:disableBlink()
  self.blink = false
end

--- Enables preserving the chat's background over the background of an incoming :append()
function EMCO:enablePreserveBackground()
  self.preserveBackground = true
end

--- Enables preserving the chat's background over the background of an incoming :append()
function EMCO:disablePreserveBackground()
  self.preserveBackground = false
end

--- Sets how long in seconds to wait between blinks
-- @tparam number blinkTime time in seconds to wait between blinks
function EMCO:setBlinkTime(blinkTime)
  local funcName = "EMCO:setBlinkTime(blinkTime)"
  local blinkTimeNumber = tonumber(blinkTime)
  if not blinkTimeNumber then
    self.ae(funcName, "blinkTime as number expected, got ".. type(blinkeTime))
  else
    self.blinkTime = blinkTimeNumber
    if self.blinkTimerID then
      killTimer(self.blinkTimerID)
    end
    self.blinkTimerID = tempTimer(blinkTimeNumber, function() self:blink() end, true)
  end
end

function EMCO:doBlink()
  if self.hidden or self.auto_hidden or not self.blink then
    return
  end
  for tab,_ in pairs(self.tabsToBlink) do
    self.tabs[tab]:flash()
  end
end

--- Sets the font size of the attached consoles
-- @tparam number fontSize font size for attached consoles
function EMCO:setFontSize(fontSize)
  local funcName = "EMCO:setFontSize(fontSize)"
  local fontSizeNumber = tonumber(fontSize)
  local fontSizeType = type(fontSize)
  if not fontSizeNumber then
    self.ae(funcName, "fontSize as number expected, got " .. fontSizeType)
  else
    self.fontSize = fontSizeNumber
    for _,tabName in ipairs(self.consoles) do
      if self.mapTab and tabName == self.mapTabName then
        -- skip this one
      else
        local window = self.windows[tabName]
        window:setFontSize(fontSizeNumber)
      end
    end
  end
end

function EMCO:adjustTabNames()
  for _,console in ipairs(self.consoles) do
    if console == self.currentTab then
      self.tabs[console]:echo(console, self.activTabFGColor, 'c')
    else
      self.tabs[console]:echo(console, self.inactiveTabFGColor, 'c')
    end
  end
end

function EMCO:adjustTabBackgrounds()
  for _, console in ipairs(self.consoles) do
    local tab = self.tabs[console]
    if console == self.currentTab then
      tab:setStyleSheet(self.activeTabCSS)
      tab:setColor(self.activeBGColor)
    else
      tab:setStyleSheet(self.inactiveTabCSS)
      tab:setColor(self.inactiveBGColor)
    end
  end
end

--- Sets the FG color for the active tab
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setActiveTabFGColor(color)
  self.activeTabFGColor = color
  self:adjustTabNames()
end

--- Sets the FG color for the inactive tab
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setInactiveTabFGColor(color)
  self.inactiveTabFGColor = color
  self:adjustTabNames()
end

--- Sets the BG color for the active tab.
-- &lt;br&gt;NOTE: If you set CSS for the active tab, it will override this setting.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setActiveTabBGColor(color)
  self.activeTabBGColor = color
  self:adjustTabBackgrounds()
end

--- Sets the BG color for the inactive tab.
-- &lt;br&gt;NOTE: If you set CSS for the inactive tab, it will override this setting.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setInactiveTabBGColor(color)
  self.inactiveTabBGColor = color
  self:adjustTabBackgrounds()
end

--- Sets the BG color for the consoles attached to this object
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setConsoleColor(color)
  self.consoleColor = color
  self:adjustConsoleColors()
end

function EMCO:adjustConsoleColors()
  for _,console in ipairs(self.consoles) do
    if self.mapTab and self.mapTabName == console then
      -- skip Map
    else
      self.windows[console]:setColor(self.consoleColor)
    end
  end
end

--- Sets the CSS to use for the tab box which contains the tabs for the object
-- @tparam string css The css styling to use for the tab box
function EMCO:setTabBoxCSS(css)
  local funcName = "EMCHO:setTabBoxCSS(css)"
  local cssType = type(css)
  if cssType ~= "string" then
    self.ae(funcName, "css as string expected, got " .. cssType)
  else
    self.tabBoxCSS = css
    self:adjustTabBoxBackground()
  end
end

--- Sets the color to use for the tab box background
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setTabBoxColor(color)
  self.tabBoxColor = color
  self:adjustTabBoxBackground()
end

function EMCO:adjustTabBoxBackground()
    self.tabBoxLabel:setStyleSheet(self.tabBoxCSS)
    self.tabBoxLabel:setColor(self.tabBoxColor)
end

--- Sets the color for the container which holds the consoles attached to this object.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setConsoleContainerColor(color)
  self.consoleContainerColor = color
  self:adjustConsoleContainerBackground()
end

--- Sets the CSS to use for the container which holds the consoles attached to this object
-- @tparam string css CSS to use for the container
function EMCO:setConsoleContainerCSS(css)
  self.consoleContainerCSS = css
  self:adjustConsoleContainerBackground()
end

function EMCO:adjustConsoleContainerBackground()
  self.consoleContainer:setStyleSheet(self.consoleContainerCSS)
  self.consoleContainer:setColor(self.consoleContainerColor)
end

--- Sets the amount of space to use between the tabs and the consoles
-- @tparam number gap Number of pixels to keep between the tabs and consoles
function EMCO:setGap(gap)
  local gapNumber = tonumber(gap)
  local funcName = "EMCO:setGap(gap)"
  local gapType = type(gap)
  if not gapNumber then
    self.ae(funcName, "gap expected as number, got " .. gapType)
  else
    self.gap = gapNumber
    self:reset()
  end
end

--- Sets the height of the tabs in pixels
-- @tparam number tabHeight the height of the tabs for the object, in pixels
function EMCO:setTabHeight(tabHeight)
  local tabHeightNumber = tonumber(tabHeight)
  local funcName = "EMCO:setTabHeight(tabHeight)"
  local tabHeightType = type(tabHeight)
  if not tabHeightNumber then
    self.ae(funcName, "tabHeight as number expected, got ".. tabHeightType)
  else
    self.tabHeight = tabHeightNumber
    self:reset()
  end
end

--- Enables autowrap for the object, and by extension all attached consoles.
-- &lt;br&gt;To enable autoWrap for a specific miniconsole only, call myEMCO.windows[tabName]:enableAutoWrap()
-- but be warned if you do this it may be overwritten by future calls to EMCO:enableAutoWrap() or :disableAutoWrap()
function EMCO:enableAutoWrap()
  self.autoWrap = true
  for _,console in ipairs(self.consoles) do
    if self.mapTab and console == self.mapTabName then
      -- skip the map
    else
      self.windows[console]:enableAutoWrap()
    end
  end
end

--- Disables autowrap for the object, and by extension all attached consoles.
-- &lt;br&gt;To disable autoWrap for a specific miniconsole only, call myEMCO.windows[tabName]:disableAutoWrap()
-- but be warned if you do this it may be overwritten by future calls to EMCO:enableAutoWrap() or :disableAutoWrap()
function EMCO:disableAutoWrap()
  self.autoWrap = false
  for _,console in ipairs(self.consoles) do
    if self.mapTab and self.mapTabName == console then
      -- skip Map
    else
      self.windows[console]:disableAutoWrap()
    end
  end
end

--- Sets the number of characters to wordwrap the attached consoles at.
-- &lt;br&gt;it is generally recommended to make use of autoWrap unless you need
-- a specific width for some reason
function EMCO:setWrap(wrapAt)
  local funcName = "EMCO:setWrap(wrapAt)"
  local wrapAtNumber = tonumber(wrapAt)
  local wrapAtType = type(wrapAt)
  if not wrapAtNumber then
    self.ae(funcName, "wrapAt as number expect, got " .. wrapAtType)
  else
    self.wrapAt = wrapAtNumber
    for _,console in ipairs(self.consoles) do
      if self.mapTab and self.mapTabName == console then
        -- skip the Map
      else
        self.windows[console]:setWrap(wrapAtNumber)
      end
    end
  end
end

--- Appends the current line from the MUD to a tab.
-- &lt;br&gt;depending on this object's configuration, may gag the line
-- &lt;br&gt;depending on this object's configuration, may gag the next prompt
-- @tparam string tabName The name of the tab to append the line to
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:append(tabName, excludeAll)
  local funcName = "EMCO:append(tabName, excludeAll)"
  local tabNameType = type(tabName)
  local validTab = table.contains(self.consoles, tabName)
  if tabNameType ~= "string" then
    self.ae(funcName, "tabName as string expected, got ".. tabNameType)
  elseif not validTab then
    self.ae(funcName, "tabName must be a tab which is contained in this object. Valid tabnames are: " .. table.concat(self.consoles, ","))
  end
  self:xEcho(tabName, nil, 'a', excludeAll)
end

function EMCO:checkEchoArgs(funcName, tabName, message, excludeAll)
  local tabNameType = type(tabName)
  local messageType = type(message)
  local validTabName = table.contains(self.consoles, tabName)
  local excludeAllType = type(excludeAll)
  local ae = self.ae
  if tabNameType ~= "string" then
    ae(funcName, "tabName as string expected, got " .. tabNameType)
  elseif messageType ~= "string" then
    ae(funcName, "message as string expected, got " .. messageType)
  elseif not validTabName then
    ae(funcName, "tabName must be the name of a tab attached to this object. Valid names are: " .. table.concat(self.consoles, ","))
  elseif excludeAllType ~= "nil" and excludeAllType ~= "boolean" then
    ae(funcName, "optional argument excludeAll expected as boolean, got " .. excludeAllType)
  end
end

function EMCO:xEcho(tabName, message, xtype, excludeAll)
  if self.mapTab and self.mapTabName == tabName then
    error("You cannot send text to the Map tab")
  end
  local console = self.windows[tabName]
  local allTab = (self.allTab and not excludeAll and not table.contains(self.allTabExclusions, tabName) and tabName ~= self.allTabName) and self.windows[self.allTabName] or false
  local ofr,ofg,ofb,obr,obg,obb
  if xtype == "a" then
    selectCurrentLine()
    ofr,ofg,ofb = getFgColor()
    obr,obg,obb = getBgColor()
    if self.preserveBackground then
      local r,g,b = Geyser.Color.parse(self.consoleColor)
      setBgColor(r,g,b)
    end
    copy()
  else
    ofr,ofg,ofb = Geyser.Color.parse("white")
    obr,obg,obb = Geyser.Color.parse(self.consoleColor)
  end
  if self.timestamp then
    local colorString = ""
    if self.customTimestampColor then
      local tfr,tfg,tfb = Geyser.Color.parse(self.timestampFGColor)
      local tbr,tbg,tbb = Geyser.Color.parse(self.timestampBGColor)
      colorString = string.format("&lt;%s,%s,%s:%s,%s,%s&gt;", tfr,tfg,tfb,tbr,tbg,tbb)
    else
      colorString = string.format("&lt;%s,%s,%s:%s,%s,%s&gt;", ofr,ofg,ofb,obr,obg,obb)
    end
    local timestamp = getTime(true, self.timestampFormat)
    local fullTimestamp = string.format("%s%s&lt;r&gt; ", colorString, timestamp)
    console:decho(fullTimestamp)
    if allTab and tabName ~= self.allTabName then
      allTab:decho(fullTimestamp)
    end
  end
  if self.blink and tabName ~= self.currentTab then
    if not (self.allTabName == self.currentTab and not self.blinkFromAll) then
      self.tabsToBlink[tabName] = true
    end
  end
  if xtype == "a" then
    console:appendBuffer()
    if allTab then
      allTab:appendBuffer()
    end
    if self.gag then
      deleteLine()
      if self.gagPrompt then
        tempPromptTrigger(function() deleteLine() end, 1)
      end
    end
  else
    console[xtype](console, message)
    if allTab then allTab[xtype](allTab, message) end
  end
  if self.blankLine then
    console:echo("\n")
    if allTab then allTab:echo("\n") end
  end
end

--- cecho to a tab, maintaining functionality
-- @tparam string tabName the name of the tab to cecho to
-- @tparam string message the message to cecho to that tab's console
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:cecho(tabName, message, excludeAll)
  local funcName = "EMCO:cecho(tabName, message, excludeAll)"
  self:checkEchoArgs(funcName, tabName, message, excludeAll)
  self:xEcho(tabName, message, 'cecho', excludeAll)
end

--- decho to a tab, maintaining functionality
-- @tparam string tabName the name of the tab to decho to
-- @tparam string message the message to decho to that tab's console
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:decho(tabName, message, excludeAll)
  local funcName = "EMCO:decho(console, message, excludeAll)"
  self:checkEchoArgs(funcName, tabName, message, excludeAll)
  self:xEcho(tabName, message, 'decho', excludeAll)
end

--- hecho to a tab, maintaining functionality
-- @tparam string tabName the name of the tab to hecho to
-- @tparam string message the message to hecho to that tab's console
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:hecho(tabName, message, excludeAll)
  local funcName = "EMCO:hecho(console, message, excludeAll)"
  self:checkEchoArgs(funcName, tabName, message, excludeAll)
  self:xEcho(tabName, message, 'hecho', excludeAll)
end

--- echo to a tab, maintaining functionality
-- @tparam string tabName the name of the tab to echo to
-- @tparam string message the message to echo to that tab's console
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:echo(tabName, message, excludeAll)
  local funcName = "EMCO:echo(console, message, excludeAll)"
  self:checkEchoArgs(funcName, tabName, message, excludeAll)
  self:xEcho(tabName, message, 'echo', excludeAll)
end

-- internal function used for type checking echoLink/Popup arguments
function EMCO:checkLinkArgs(funcName, tabName, text, commands, hints, excludeAll, popup)
  local expectedType = popup and "table" or "string"
  local textType = type(text)
  local commandsType = type(commands)
  local hintsType = type(hints)
  local tabNameType = type(tabName)
  local validTabName = table.contains(self.consoles, tabName)
  local excludeAllType = type(excludeAll)
  local sf = string.format
  local ae = self.ae
  if textType ~= "string" then
    ae(funcName, "text as string expected, got " .. textType)
  elseif commandsType ~= expectedType then
    ae(funcName, sf("commands as %s expected, got %s", expectedType, commandsType))
  elseif hintsType ~= expectedType then
    ae(funcName, sf("hints as %s expected, got %s", expectedType, hintsType))
  elseif tabNameType ~= "string" then
    ae(funcName, "tabName as string expected, got " .. tabNameType)
  elseif not validTabName then
    ae(funcName, sf("tabName must be a tab which exists, tab %s could not be found", tabName))
  elseif self.mapTab and tabName == self.mapTabName then
    ae(funcName, sf("You cannot echo to the map tab, and %s is configured as the mapTabName", tabName))
  elseif excludeAllType ~= "nil" and excludeAllType ~= "boolean" then
    ae(funcName, "Optional argument excludeAll expected as boolean, got " .. excludeAllType)
  end
end

-- internal function used for handling echoLink/popup
function EMCO:xLink(tabName, linkType, text, commands, hints, useCurrentFormat, excludeAll)
  local console = self.windows[tabName]
  local allTab = (self.allTab and not excludeAll and not table.contains(self.allTabExclusions, tabName) and tabName ~= self.allTabName) and self.windows[self.allTabName] or false
  local arguments = {text, commands, hints, useCurrentFormat}
  if self.timestamp then
    local colorString = ""
    if self.customTimestampColor then
      local tfr,tfg,tfb = Geyser.Color.parse(self.timestampFGColor)
      local tbr,tbg,tbb = Geyser.Color.parse(self.timestampBGColor)
      colorString = string.format("&lt;%s,%s,%s:%s,%s,%s&gt;", tfr,tfg,tfb,tbr,tbg,tbb)
    else
      local ofr,ofg,ofb = Geyser.Color.parse("white")
      local obr,obg,obb = Geyser.Color.parse(self.consoleColor)
      colorString = string.format("&lt;%s,%s,%s:%s,%s,%s&gt;", ofr,ofg,ofb,obr,obg,obb)
    end
    local timestamp = getTime(true, self.timestampFormat)
    local fullTimestamp = string.format("%s%s&lt;r&gt; ", colorString, timestamp)
    console:decho(fullTimestamp)
    if allTab then
      allTab:decho(fullTimestamp)
    end
  end
  console[linkType](console, unpack(arguments))
  if allTab then allTab[linkType](allTab, unpack(arguments)) end
end

--- cechoLink to a tab
-- @tparam string tabName the name of the tab to cechoLink to
-- @tparam string text the text underlying the link
-- @tparam string command the lua code to run in string format
-- @tparam string hint the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:cechoLink(tabName, text, command, hint, excludeAll)
  local funcName = "EMCO:cechoLink(tabName, text, command, hint)"
  self:checkLinkArgs(funcName, tabName, text, command, hint, excludeAll)
  self:xLink(tabName, "cechoLink", text, command, hint, true, excludeAll)
end

--- dechoLink to a tab
-- @tparam string tabName the name of the tab to dechoLink to
-- @tparam string text the text underlying the link
-- @tparam string command the lua code to run in string format
-- @tparam string hint the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:dechoLink(tabName, text, command, hint, excludeAll)
  local funcName = "EMCO:dechoLink(tabName, text, command, hint)"
  self:checkLinkArgs(funcName, tabName, text, command, hint, excludeAll)
  self:xLink(tabName, "dechoLink", text, command, hint, true, excludeAll)
end

--- hechoLink to a tab
-- @tparam string tabName the name of the tab to hechoLink to
-- @tparam string text the text underlying the link
-- @tparam string command the lua code to run in string format
-- @tparam string hint the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:hechoLink(tabName, text, command, hint, excludeAll)
  local funcName = "EMCO:hechoLink(tabName, text, command, hint)"
  self:checkLinkArgs(funcName, tabName, text, command, hint, excludeAll)
  self:xLink(tabName, "hechoLink", text, command, hint, true, excludeAll)
end

--- echoLink to a tab
-- @tparam string tabName the name of the tab to echoLink to
-- @tparam string text the text underlying the link
-- @tparam string command the lua code to run in string format
-- @tparam string hint the tooltip hint to use for the link
-- @tparam boolean useCurrentFormat use the format for the window or blue on black (hyperlink colors)
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:echoLink(tabName, text, command, hint, useCurrentFormat, excludeAll)
  local funcName = "EMCO:echoLink(tabName, text, command, hint, useCurrentFormat)"
  self:checkLinkArgs(funcName, tabName, text, command, hint, excludeAll)
  self:xLink(tabName, "echoLink", text, command, hint, useCurrentFormat, excludeAll)
end

--- cechoPopup to a tab
-- @tparam string tabName the name of the tab to cechoPopup to
-- @tparam string text the text underlying the link
-- @tparam table commands the lua code to run in string format
-- @tparam table hints the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:cechoPopup(tabName, text, commands, hints, excludeAll)
  local funcName = "EMCO:cechoPopup(tabName, text, commands, hints)"
  self:checkLinkArgs(funcName, tabName, text, commands, hints, excludeAll, true)
  self:xLink(tabName, "cechoPopup", text, commands, hints, true, excludeAll)
end

--- dechoPopup to a tab
-- @tparam string tabName the name of the tab to dechoPopup to
-- @tparam string text the text underlying the link
-- @tparam table commands the lua code to run in string format
-- @tparam table hints the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:dechoPopup(tabName, text, commands, hints, excludeAll)
  local funcName = "EMCO:dechoPopup(tabName, text, commands, hints)"
  self:checkLinkArgs(funcName, tabName, text, commands, hints, excludeAll, true)
  self:xLink(tabName, "dechoPopup", text, commands, hints, true, excludeAll)
end

--- hechoPopup to a tab
-- @tparam string tabName the name of the tab to hechoPopup to
-- @tparam string text the text underlying the link
-- @tparam table commands the lua code to run in string format
-- @tparam table hints the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:hechoPopup(tabName, text, commands, hints, excludeAll)
  local funcName = "EMCO:hechoPopup(tabName, text, commands, hints)"
  self:checkLinkArgs(funcName, tabName, text, commands, hints, excludeAll, true)
  self:xLink(tabName, "hechoPopup", text, commands, hints, true, excludeAll)
end

--- echoPopup to a tab
-- @tparam string tabName the name of the tab to echoPopup to
-- @tparam string text the text underlying the link
-- @tparam table commands the lua code to run in string format
-- @tparam table hints the tooltip hint to use for the link
-- @tparam boolean useCurrentFormat use the format for the window or blue on black (hyperlink colors)
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:echoPopup(tabName, text, commands, hints, useCurrentFormat, excludeAll)
  local funcName = "EMCO:echoPopup(tabName, text, commands, hints, useCurrentFormat)"
  self:checkLinkArgs(funcName, tabName, text, commands, hints, excludeAll, true)
  self:xLink(tabName, "echoPopup", text, commands, hints, useCurrentFormat, excludeAll)
end

--- adds a tab to the exclusion list for echoing to the allTab
-- @tparam string tabName the name of the tab to add to the exclusion list
function EMCO:addAllTabExclusion(tabName)
  local funcName = "EMCO:addAllTabExclusion(tabName)"
  local ae = self.ae
  local tabNameType = type(tabName)
  local validTabName = table.contains(self.consoles, tabName)
  if tabNameType ~= "string" then
    ae(funcName, "tabName as string expected, got " .. tabNameType)
  elseif not validTabName then
    ae(funcName, string.format("tabName %s does not exist in this EMCO. valid tabs: " .. table.concat(self.consoles, ",")))
  end
  if not table.contains(self.allTabExclusions, tabName) then table.insert(self.allTabExclusions, tabName) end
end

--- removess a tab from the exclusion list for echoing to the allTab
-- @tparam string tabName the name of the tab to remove from the exclusion list
function EMCO:removeAllTabExclusion(tabName)
  local funcName = "EMCO:removeAllTabExclusion(tabName)"
  local ae = self.ae
  local tabNameType = type(tabName)
  local validTabName = table.contains(self.consoles, tabName)
  if tabNameType ~= "string" then
    ae(funcName, "tabName as string expected, got " .. tabNameType)
  elseif not validTabName then
    ae(funcName, string.format("tabName %s does not exist in this EMCO. valid tabs: " .. table.concat(self.consoles, ",")))
  end
  local index = table.index_of(self.allTabExclusions, tabName)
  if index then table.remove(self.allTabExclusions, index) end
end

--- Enable placing a blank line between all messages.
function EMCO:enableBlankLine()
  self.blankLine = true
end

--- Enable placing a blank line between all messages.
function EMCO:disableBlankLine()
  self.blankLine = false
end

--- Enable scrollbars for the miniconsoles
function EMCO:enableScrollbars()
  self.scrollbars = true
  self:adjustScrollbars()
end

--- Disable scrollbars for the miniconsoles
function EMCO:disableScrollbars()
  self.scrollbars = false
  self:adjustScrollbars()
end

function EMCO:adjustScrollbars()
  for _,console in ipairs(self.consoles) do
    if self.mapTab and self.mapTabName == console then
      -- skip the Map tab
    else
      if self.scrollbars then
        self.windows[console]:enableScrollBar()
      else
        self.windows[console]:disableScrollBar()
      end
    end
  end
end

EMCOHelper = EMCOHelper or {}
EMCOHelper.items = EMCOHelper.items or {}
function EMCOHelper:switchTab(designator)
  local args = string.split(designator, "+")
  local emcoName = args[1]
  local tabName = args[2]
  for _,emco in ipairs(EMCOHelper.items) do
    if emco.name == emcoName then
      emco:switchTab(tabName)
      return
    end
  end
end

EMCO.parent = Geyser.Container

--- Creates a new Embeddable Multi Console Object.
-- &lt;br&gt;see https://github.com/demonnic/EMCO/wiki for information on valid constraints and defaults
-- @tparam table cons table of constraints which configures the EMCO.
-- @tparam GeyserObject container The container to use as the parent for the EMCO
-- @return the newly created EMCO
function EMCO:new(cons, container)
  local funcName = "EMCO:new(cons, container)"
  cons = cons or {}
  cons.type = cons.type or "tabbedConsole"
  cons.consoles = cons.consoles or { "All" }
  if cons.mapTab then
    if not type(cons.mapTabName) == "string" then
      self:ce(funcName, [["mapTab" is true, thus constraint "mapTabName" and string expected, got ]] .. type(cons.mapTabName))
    elseif not table.contains(cons.consoles, cons.mapTabName) then
      self:ce(funcName, [["mapTabName" must be one of the consoles contained within constraint "consoles". Valid option for tha mapTab are: ]] .. table.concat(cons.consoles, ","))
    end
  end
  cons.allTabExclusions = cons.allTabExclusions or {}
  if not type(cons.allTabExclusions) == "table" then self:se(funcName, "allTabExclusions must be a table if it is provided") end
  local me = self.parent:new(cons, container)
  setmetatable(me, self)
  self.__index = self
  -- set some defaults. Almost all the defaults we had for YATCO, plus a few new ones
  if me:fuzzyBoolean(cons.timestamp) then
    me:enableTimestamp()
  else
    me:disableTimestamp()
  end
  if me:fuzzyBoolean(cons.customTimestampColor) then
    me:enableCustomTimestampColor()
  else
    me:disableCustomTimestampColor()
  end
  if me:fuzzyBoolean(cons.mapTab) then
    me.mapTab = true
  else
    me.mapTab = false
  end
  if me:fuzzyBoolean(cons.blinkFromAll) then
    me:enableBlinkFromAll()
  else
    me:disableBlinkFromAll()
  end
  if me:fuzzyBoolean(cons.preserveBackground) then
    me:enablePreserveBackground()
  else
    me:disablePreserveBackground()
  end
  if me:fuzzyBoolean(cons.gag)then
    me:enableGag()
  else
    me:disableGag()
  end
  me:setTimestampFormat(cons.timestampFormat or "HH:mm:ss")
  me:setTimestampBGColor(cons.timestampBGColor or "blue")
  me:setTimestampFGColor(cons.timestampFGColor or "red")
  if me:fuzzyBoolean(cons.allTab) then
    me:enableAllTab(cons.allTab)
  else
    me:disableAllTab()
  end
  if me:fuzzyBoolean(cons.blink) then
    me:enableBlink()
  else
    me:disableBlink()
  end
  if me:fuzzyBoolean(cons.blankLine) then
    me:enableBlankLine()
  else
    me:disableBlankLine()
  end
  if me:fuzzyBoolean(cons.scrollbars) then
    me.scrollbars = true
  else
    me.scrollbars = false
  end
  me.blinkTime = cons.blinkTime or 3
  me.fontSize = cons.fontSize or 9
  me.activeTabCSS = cons.activeTabCSS or ""
  me.inactiveTabCSS = cons.inactiveTabCSS or ""
  me.activeTabFGColor = cons.activeTabFGColor or "purple"
  me.inactiveTabFGColor = cons.inactiveTabFGColor or "white"
  me.activeTabBGColor = cons.activeTabBGColor or "&lt;0,180,0&gt;"
  me.inactiveTabBGColor = cons.inactiveTabBGColor or "&lt;60,60,60&gt;"
  me.consoleColor = cons.consoleColor or "black"
  me.tabBoxCSS = cons.tabBoxCSS or ""
  me.tabBoxColor = cons.tabBoxColor or "black"
  me.consoleContainerCSS = cons.consoleContainerCSS or ""
  me.consoleContainerColor = cons.consoleContainerColor or "black"
  me.gap = cons.gap or 1
  me.consoles = cons.consoles
  me.tabHeight = cons.tabHeight or 25
  if cons.autoWrap == nil then
    me.autoWrap = true
  else
    me.autoWrap = cons.autoWrap
  end
  me.wrapAt = cons.wrapAt or 300
  me.currentTab = ""
  me.tabs = {}
  me.tabsToBlink = {}
  me.windows = {}
  self.blinkTimerID = tempTimer(me.blinkTime, function() me:doBlink() end, true)
  me:reset()
  if me.allTab then me:setAllTabName(me.allTabName or me.consoles[1]) end
  table.insert(EMCOHelper.items, me)
  return me
end
</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>TextFormatter</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>standaloneFormatter</name>
					<packageName></packageName>
					<script>--- fText processing
-- @module demonnic
demonnic = demonnic or {}

function demonnic:wordWrap(str, limit, indent, indent1)
  -- pulled from http://lua-users.org/wiki/StringRecipes
  indent = indent or ""
  indent1 = indent1 or indent
  limit = limit or 72
  local here = 1-#indent1
  local function check(sp, st, word, fi)
    if fi - here &gt; limit then
      here = st - #indent
      return "\n"..indent..word
    end
  end
  return indent1..str:gsub("(%s+)()(%S+)()", check)
end

function demonnic:fText(str, opts)
  local options = demonnic:fixFormatOptions(str, opts)
  if options.wrap and (options.strLen &gt; options.effWidth) then
    local wrapped = demonnic:wordWrap(str, options.effWidth)
    local lines = wrapped:split("\n")
    local formatted = {}
		options.fixed = false
    for _,line in ipairs(lines) do
      table.insert(formatted, demonnic:fLine(line, options))
    end
    return table.concat(formatted, "\n")
  else
    return demonnic:fLine(str, options)
  end
end

function demonnic:fixFormatOptions(str, opts)
  if opts.fixed then return table.deepcopy(opts) end
  --Set up all the things we might call the different echo types
  local dec = {"d", "decimal", "dec"}
  local hex = {"h", "hexidecimal", "hex"}
  local col = {"c", "color", "colour", "col", "name"}
  if opts == nil then opts = {} end -- don't overwrite options if they passed them
  --but if they passed something other than a table as the options than oopsie!
  if type(opts) ~= "table" then
    error("Improper argument: options expected to be passed as table")
  end
  --now we make a copy of the table, so we don't edit the original during all this
  local options = table.deepcopy(opts)
  if options.wrap == nil then options.wrap = true end --wrap by default.
  options.formatType = options.formatType or "" --by default, no color formatting.
  options.width = options.width or 80 --default 80 width
  options.cap = options.cap or "" --no cap by default
  options.spacer = options.spacer or " " --default spacer is the space character
  options.alignment = options.alignment or "center" --default alignment is centered
  if options.nogap == nil then options.nogap = false end
  if options.inside == nil then options.inside = false end --by default, we don't put the spacer inside
  if not options.mirror == false then options.mirror = options.mirror or true end--by default, we do want to use mirroring for the caps
  --setup default options for colors based on the color formatting type
  if table.contains(dec, options.formatType) then
    options.capColor = options.capColor or "&lt;255,255,255&gt;"
    options.spacerColor = options.spacerColor or "&lt;255,255,255&gt;"
    options.textColor = options.textColor or "&lt;255,255,255&gt;"
    options.colorReset = "&lt;r&gt;"
    options.colorPattern = "&lt;%d+,%d+,%d+:?%d*,?%d*,?%d*&gt;"
  elseif table.contains(hex, options.formatType) then
    options.capColor = options.capColor or "#FFFFFF"
    options.spacerColor = options.spacerColor or "#FFFFFF"
    options.textColor = options.textColor or "#FFFFFF"
    options.colorReset = "#r"
    options.colorPattern = 'c|%d%d%d%d%d%d'
  elseif table.contains(col, options.formatType) then
    options.capColor = options.capColor or "&lt;white&gt;"
    options.spacerColor = options.spacerColor or "&lt;white&gt;"
    options.textColor = options.textColor or "&lt;white&gt;"
    options.colorReset = "&lt;reset&gt;"
    options.colorPattern = "&lt;%w*_?%w*:?%w*_?%w*&gt;"
  else
    options.capColor = ""
    options.spacerColor = ""
    options.textColor = ""
    options.colorReset = ""
    options.colorPattern = ""
  end
  options.originalString = str
  options.strippedString = string.gsub(tostring(str), options.colorPattern, "")
  options.strLen = string.len(options.strippedString)
  options.leftCap = options.cap
  options.rightCap = options.cap
  options.capLen = string.len(options.cap)
  local gapSpaces = 0
  if not options.nogap then
    if options.alignment == "center" then
      gapSpaces = 2
    else
      gapSpaces = 1
    end
  end
  options.nontextlength = options.width - options.strLen - gapSpaces
  options.leftPadLen = math.floor(options.nontextlength / 2)
  options.rightPadLen = options.nontextlength - options.leftPadLen
  options.effWidth = options.width - ((options.capLen * gapSpaces) + gapSpaces)
  if options.capLen &gt; options.leftPadLen then
    options.cap = options.cap:sub(1, leftPadLen)
    options.capLen = string.len(options.cap)
  end
  options.fixed = true
  return options
end

function demonnic:fLine(str,opts)
  local options = demonnic:fixFormatOptions(str,opts)
  local leftCap = options.leftCap
  local rightCap = options.rightCap
  local leftPadLen = options.leftPadLen
  local rightPadLen = options.rightPadLen
  local capLen = options.capLen

  if options.alignment == "center" then --we're going to center something
    if options.mirror then --if we're reversing the left cap and the right cap (IE {{[[ turns into ]]}} )
      rightCap = string.gsub(rightCap, "&lt;", "&gt;")
      rightCap = string.gsub(rightCap, "%[", "%]")
      rightCap = string.gsub(rightCap, "{", "}")
      rightCap = string.gsub(rightCap, "%(", "%)")
      rightCap = string.reverse(rightCap)
    end --otherwise, they'll be the same, so don't do anything
    if not options.nogap then str = string.format(" %s ", str) end

  elseif options.alignment == "right" then --we'll right-align the text
    leftPadLen = leftPadLen + rightPadLen
    rightPadLen = 0
    rightCap = ""
    if not options.nogap then str = string.format(" %s", str) end

  else --Ok, so if it's not center or right, we assume it's left. We don't do justified. Sorry.
    rightPadLen = rightPadLen + leftPadLen
    leftPadLen = 0
    leftCap = ""
    if not options.nogap then str = string.format("%s ", str) end
  end--that's it, took care of both left, right, and center formattings, now to output the durn thing.
  local fullLeftCap = string.format("%s%s%s", options.capColor, leftCap, options.colorReset)
  local fullLeftSpacer = string.format("%s%s%s", options.spacerColor, string.rep(options.spacer, (leftPadLen - capLen)), options.colorReset)
  local fullText = string.format("%s%s%s", options.textColor, str, options.colorReset)
  local fullRightSpacer = string.format("%s%s%s", options.spacerColor, string.rep(options.spacer, (rightPadLen - capLen)), options.colorReset)
  local fullRightCap = string.format("%s%s%s", options.capColor, rightCap, options.colorReset)

  if options.inside then
  -- "endcap===== some text =====endcap"
  -- "endcap===== some text =====pacdne"
  -- "endcap================= some text"
  -- "some text =================endcap"
    local finalString = string.format("%s%s%s%s%s", fullLeftCap, fullLeftSpacer, fullText, fullRightSpacer, fullRightCap)
    return finalString
  else
  --"=====endcap some text endcap====="
  --"=====endcap some text pacdne====="
  --"=================endcap some text"
  --"some text endcap================="

    local finalString = string.format("%s%s%s%s%s", fullLeftSpacer, fullLeftCap, fullText, fullRightCap, fullRightSpacer)
    return finalString
  end
end

function demonnic:align(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = ""
		options.wrap = false
  else
    error("Improper argument: options expected to be passed as table")
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:dalign(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "d"
    options.wrap = false
  else
    error("Improper argument: options expected to be passed as table")
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:calign(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "c"
    options.wrap = false
  else
    error("Improper argument: options expected to be passed as table")
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:halign(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "h"
    options.wrap = false
  else
    error("Improper argument: options expected to be passed as table")
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:cfText(str, opts)
  local options = {}
  if opts == nil then opts = {} end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "c"
  else
    error("Improper argument: options expected to be passed as table")
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fText(str, options)
end

function demonnic:dfText(str, opts)
  local options = {}
  if opts == nil then opts = {} end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "d"
  else
    error("Improper argument: options expected to be passed as table")
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fText(str, options)
end

function demonnic:hfText(str, opts)
  local options = {}
  if opts == nil then opts = {} end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "h"
  else
    error("Improper argument: options expected to be passed as table")
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fText(str, options)
end

function demonnic:test_ftext()
  local testString = "This is a test of the emergency broadcast system. This is only a test. If this had been a real emergency, we would have given you more sensible information after this. But this was only a test."

  local nTable = {width = 40, cap = "(CAP)", inside = true, alignment = 'center'}
  local cTable = table.deepcopy(nTable)
    cTable.formatType="c"
    cTable.capColor = "&lt;red:black&gt;"
    cTable.spacerColor = "&lt;purple:green&gt;"
    cTable.textColor = "&lt;purple:green&gt;"

  local dTable = table.deepcopy(nTable)
    dTable.formatType="d"
    dTable.capColor = "&lt;0,0,182&gt;"
    dTable.spacerColor = "&lt;0,182,0&gt;"
    dTable.textColor = "&lt;182,0,0&gt;"

  local hTable = table.deepcopy(nTable)
    hTable.formatType="h"
    hTable.capColor = "#FF0000"
    hTable.spacerColor = "#00FF00"
    hTable.textColor = "#0000FF"
  echo(string.rep("\n", 5))
  echo("With word wrap:\n")
  echo(demonnic:fText(testString, nTable) .. "\n")
  cecho(demonnic:fText(testString, cTable) .. "\n")
  decho(demonnic:fText(testString, dTable) .. "\n")
  hecho(demonnic:fText(testString, hTable) .. "\n")

  echo("\n\nWithout word wrap:\n")
  echo(demonnic:align(testString, nTable) .. "\n")
  decho(demonnic:dalign(testString, dTable) .. "\n")
  cecho(demonnic:calign(testString, cTable) .. "\n")
  hecho(demonnic:halign(testString, hTable) .. "\n")
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>reusableFormatter</name>
					<packageName></packageName>
					<script>--- Stand alone text formatter object. Remembers the options you set and can be adjusted as needed
-- @module demonnic.textFormatter
demonnic.TextFormatter = {}
demonnic.TextFormatter.validFormatTypes = { 'd', 'dec', 'decimal', 'h', 'hex', 'hexidecimal', 'c', 'color', 'colour', 'col', 'name'}

--- Set's the formatting type whether it's for cecho, decho, or hecho
--@tparam string typeToSet What type of formatter is this? Valid options are { 'd', 'dec', 'decimal', 'h', 'hex', 'hexidecimal', 'c', 'color', 'colour', 'col', 'name'}
function demonnic.TextFormatter:setType(typeToSet)
  local isNotValid = not table.contains(self.validFormatTypes, typeToSet)
  if isNotValid then
    error("demonnic.TextFormatter:setType: Invalid argument, valid types are:" .. table.concat(self.validFormatTypes, ", "))
  end
  self.options.formatType = typeToSet
end

function demonnic.TextFormatter:toBoolean(thing)
  if type(thing) ~= "boolean" then
    if thing == "true" then
      thing = true
    elseif thing == "false" then
      thing = false
    else
      return nil
    end
  end
  return thing
end

function demonnic.TextFormatter:checkString(str)
  if type(str) ~= "string" then
    if tostring(str) then
      str = tostring(str)
    else
      return nil
    end
  end
  return str
end

--- Sets whether or not we should do word wrapping.
--@tparam boolean shouldWrap should we do wordwrapping?
function demonnic.TextFormatter:setWrap(shouldWrap)
  local argumentType = type(shouldWrap)
  shouldWrap = self:toBoolean(shouldWrap)
  if shouldWrap == nil then
    error("demonnic.TextFormatter:setWrap(shouldWrap) Argument error, boolean expected, got " .. argumentType .. ", if you want to set the number of characters wide to format for, use setWidth()")
  end
  self.options.wrap = shouldWrap
end

--- Sets the width we should format for
--@tparam number width the width we should format for
function demonnic.TextFormatter:setWidth(width)
  if type(width) ~= "number" then
    if tonumber(width) then
      width = tonumber(width)
    else
      error("demonnic.TextFormatter:setWidth(width): Argument error, number expected, got " .. type(width))
    end
  end
  self.options.width = width
end

--- Sets the cap for the formatter
--@tparam string cap the string to use for capping the formatted string.
function demonnic.TextFormatter:setCap(cap)
  local argumentType = type(cap)
  local cap = self:checkString(cap)
  if cap == nil then error("demonnic.TextFormatter:setCap(cap): Argument error, string expect, got " .. argumentType) end
  self.options.cap = cap
end

--- Sets the color for the format cap
--@tparam string capColor Color which can be formatted via Geyser.Color.parse()
function demonnic.TextFormatter:setCapColor(capColor)
  local argumentType = type(capColor)
  local capColor = self:checkString(capColor)
  if capColor == nil then error("demonnic.TextFormatter:setCapColor(capColor): Argument error, string expected, got " .. argumentType) end
  self.options.capColor = capColor
end

--- Sets the color for spacing character
--@tparam string spacerColor Color which can be formatted via Geyser.Color.parse()
function demonnic.TextFormatter:setSpacerColor(spacerColor)
  local argumentType = type(spacerColor)
  local spacerColor = self:checkString(spacerColor)
  if spacerColor == nil then error("demonnic.TextFormatter:setSpacerColor(spacerColor): Argument error, string expected, got " .. argumentType) end
  self.options.spacerColor = spacerColor
end

--- Sets the color for formatted text
--@tparam string textColor Color which can be formatted via Geyser.Color.parse()
function demonnic.TextFormatter:setTextColor(textColor)
  local argumentType = type(textColor)
  local textColor = self:checkString(textColor)
  if textColor == nil then error("demonnic.TextFormatter:setTextColor(textColor): Argument error, string expected, got " .. argumentType) end
  self.options.textColor = textColor
end

--- Sets the spacing character to use. Should be a single character
--@tparam string spacer the character to use for spacing
function demonnic.TextFormatter:setSpacer(spacer)
  local argumentType = type(spacer)
  local spacer = self:checkString(spacer)
  if spacer == nil then error("demonnic.TextFormatter:setSpacer(spacer): Argument error, string expect, got " .. argumentType) end
  self.options.spacer = spacer
end

--- Set the alignment to format for
--@tparam string alignment How to align the formatted string. Valid options are 'left', 'right', or 'center'
function demonnic.TextFormatter:setAlignment(alignment)
  local validAlignments = {
    "left",
    "right",
    "center"
  }
  if not table.contains(validAlignments, alignment) then
    error("demonnic.TextFormatter:setAlignment(alignment): Argument error: Only valid arguments for setAlignment are 'left', 'right', or 'center'. You sent" .. alignment)
  end
  self.options.alignment = alignment
end

--- Set whether the the spacer should go inside the the cap or outside of it
--@tparam boolean spacerInside 
function demonnic.TextFormatter:setInside(spacerInside)
  local argumentType = type(spacerInside)
  spacerInside = self:toBoolean(spacerInside)
  if spacerInside == nil then
    error("demonnic.TextFormatter:setInside(spacerInside) Argument error, boolean expected, got " .. argumentType)
  end
  self.options.inside = spacerInside
end

--- Set whether we should mirror/reverse the caps. IE &lt;&lt; becomes &gt;&gt; if set to true
--@tparam boolean shouldMirror
function demonnic.TextFormatter:setMirror(shouldMirror)
  local argumentType = type(shouldMirror)
  shouldMirror = self:toBoolean(shouldMirror)
  if shouldMirror == nil then
    error("demonnic.TextFormatter:setMirror(shouldMirror): Argument error, boolean expected, got " .. argumentType)
  end
  self.options.mirror = shouldMirror
end

--- Format a string based on the stored options
--@tparam string str The string to format
function demonnic.TextFormatter:format(str)
  return demonnic:fText(str, self.options)
end

--- Creates and returns a new TextFormatter. For valid options, please see https://github.com/demonnic/fText/wiki/fText
--@tparam table options the options for the text formatter to use when running format()
function demonnic.TextFormatter:new(options)
  if options == nil then options = {} end
  if options and type(options) ~= "table" then
    error("demonnic.TextFormatter:new(options): Argument error, table expected, got " .. type(options))
  end
  local me = {}
  me.options = {
    formatType = "c",
    wrap = true,
    width = 80,
    cap = "",
    spacer = " ",
    alignment = "center",
    inside = true,
    mirror = false,
  }
  for option, value in pairs(options) do
    me.options[option] = value
  end
  setmetatable(me, self)
  self.__index = self
  return me
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tableFormatter</name>
					<packageName></packageName>
					<script>--- Easy formatting for text tables
-- @module demonnic.TableMaker

demonnic.TableMaker = {
  headCharacter = "*",
  footCharacter = "*",
  edgeCharacter = "*",
  rowSeparator = "-",
  separator = "|",
  colorReset = "&lt;reset&gt;",
  formatType = "c",
  printHeaders = true,
  autoEcho = false,
}

function demonnic.TableMaker:checkPosition(position, func)
  if position == nil then position = 0 end
  if type(position) ~= "number" then
    if tonumber(position) then
      position = tonumber(position)
    else
      error(func .. ": Argument error: position expected as number, got " .. type(position))
    end
  end
  return position
end

function demonnic.TableMaker:insert(tbl, pos, item)
  if pos ~= 0 then
    table.insert(tbl, pos, item)
  else
    table.insert(tbl, item)
  end
end

--- Adds a column definition for the table. 
--@tparam table options Table of options suitable for a TextFormatter object. See https://github.com/demonnic/fText/wiki/fText
--@tparam number position The position of the column you're adding, counting from the left. If not provided will add it as the last column
function demonnic.TableMaker:addColumn(options, position)
  if options == nil then options = {} end
  if not type(options) == "table" then error("demonnic.TableMaker:addColumn(options, position): Argument error: options expected as table, got " .. type(options)) end
  local options = table.deepcopy(options)
  position = self:checkPosition(position, "demonnic.TableMaker:addColumn(options, position)")
  options.width = options.width or 20
  options.name = options.name or ""
  local formatter = demonnic.TextFormatter:new(options)
  self:insert(self.columns, position, formatter)
end

--- Deletes a column at the given position
--@tparam number position the column you wish to delete
function demonnic.TableMaker:deleteColumn(position)
  if position == nil then error("demonnic.TableMaker:deleteColumn(position): Argument Error: position as number expected, got nil") end
  position = self:checkPosition(position)
  local maxColumn = #self.columns
  if position &gt; maxColumn then error("demonnic.TableMaker:deleteColumn(position): Argument Error: position provided was larger than number of columns in the table. Number of columns: " .. #self.columns) end
  table.remove(self.columns, position)
end

--- Replaces a column at a specific position with the newly provided formatting
--@tparam table options table of options suitable for a TextFormatter object. See https://github.com/demonnic/fText/wiki/fText
--@tparam number position which column you are replacing, counting from the left.
function demonnic.TableMaker:replaceColumn(options, position)
  if position == nil then
    error("demonnic.TableMaker:replaceColumn(options, position): Argument error: position as number expected, got nil")
  end
  position = self:checkPosition(position)
  if type(options) ~= "table" then error("demonnic.TableMaker:replaceColumn(options, position): Argument error: options as table expected, got " .. type(options)) end
  if #self.columns &lt; position then error("demonnic.TableMaker:replaceColumn(options, position): you cannot specify a position higher than the number of columns currently in the TableMaker. You sent:" .. position .. " and there are: " .. #self.columns .. "columns in the TableMaker") end
  options.width = options.width or 20
  options.name = options.name or ""
  local formatter = demonnic.TextFormatter:new(options)
  self.columns[position] = formatter
end

--- Adds a row of output to the table
--@tparam table columnEntries This indexed table contains an entry for each column in the table. Entries in the table must be strings, a table of options for insertPopup or insertLink, or a function which returns one of these things
--@tparam number position position for the row you want to add, counting from the top down. If not provided defaults to the last line in the table.
function demonnic.TableMaker:addRow(columnEntries, position)
  local columnEntriesType = type(columnEntries)
  if columnEntriesType ~= "table" then
    error("demonnic.TableMaker:addRow(columnEntries, position): Argument error, columnEntries expected as table, got " .. columnEntriesType)
  end
  for _,entry in ipairs(columnEntries) do
    local entryCheck = self:checkEntry(entry)
    if entryCheck == 0 then
      if type(entry) == "function" then
        error("demonnic.TableMaker:addRow(columnEntries, position): Argument Error, you provided a function for a columnEntry but it does not return a string. We need a string. It was entry number " .. _ .. "in columnEntries")
      else
        error("demonnic.TableMaker:addRow(columnEntries, position): Argument error, columnEntries items expected as string, got:" .. type(entry)) 
      end
    end
  end
  position = self:checkPosition(position, "demonnic.TableMaker:addRow(columnEntries, position)")
  self:insert(self.rows, position, columnEntries)
end

--- Deletes the row at the given position
--@tparam number position the row to delete
function demonnic.TableMaker:deleteRow(position)
  if position == nil then error("demonnic.TableMaker:deleteRow(position): Argument Error: position as number expected, got nil") end
  position = self:checkPosition(position, "demonnic.TableMaker:deleteRow(position)")
  local maxRow = #self.rows
  if position &gt; maxRow then error("demonnic.TableMaker:deleteRow(position): Argument Error: position given was &gt; the number of rows we have # of rows is:" .. maxRow) end
  table.remove(self.rows, position)
end

--- Replaces a row of output in the table
--@tparam table columnEntries This indexed table contains an entry for each column in the table. Entries in the table must be strings, a table of options for insertPopup or insertLink, or a function which returns one of these things
--@tparam number position position for the row you want to add, counting from the top down.
function demonnic.TableMaker:replaceRow(columnEntries, position)
  if position == nil then
    error("demonnic.TableMaker:replaceRow(columnEntries, position): ArgumentError: position expected as number, received nil")
  end
  position = self:checkPosition(position, "demonnic.TableMaker:replaceRow(columnEntries, position)")
  if #self.rows &lt; position then
    error("demonnic.TableMaker:replaceRow(columnEntries, position): position cannot be greater than the number of rows already in the tablemaker. You provided: " .. position .. " and there are " .. #self.rows .. "rows in the TableMaker")
  end
  for _,entry in ipairs(columnEntries) do
    local entryCheck = self:checkEntry(entry)
    if entryCheck == 0 then
      if type(entry) == "function" then
        error("demonnic.TableMaker:replaceRow(columnEntries, position): Argument Error: you provided a function for a columnEntry but it does not return a string. We need a string. It was entry number " .. _ .. "in columnEntries")
      else
        error("demonnic.TableMaker:replaceRow(columnEntries, position): Argument error: columnEntries items expected as string, got:" .. type(entry))
      end
    end
  end
  self.rows[position] = columnEntries
end

function demonnic.TableMaker:checkEntry(entry)
  local allowedTypes = {
    "string"
  }
  if self.allowPopups then
    table.insert(allowedTypes, "table")
  end
  local entryType = type(entry)
  if entryType == "function" then
    entryType = type(entry())
  end
  if table.contains(allowedTypes, entryType) then
    return entry
  else
    return 0
  end
end

function demonnic.TableMaker:checkNumber(num)
  if num == nil then num = 0 end
  if not tonumber(num) then num = 0 end
  return tonumber(num)
end

--- Sets a specific cell's display information
--@tparam number row the row number of the cell, counted from the top down
--@tparam number column the column number of the cell, counted from the left
--@param entry What to set the entry to. Must be a string, or a table of options for insertLink/insertPopup if allowPopups is set. Or a function which returns one of these things
function demonnic.TableMaker:setCell(row, column, entry)
  local maxRow = #self.rows
  local maxColumn = #self.columns
  local ae = "demonnic.TableMaker:setCell(row, column, entry): Argument Error:"
  row = self:checkNumber(row)
  if row == 0 then error(ae .. " row must be a number, you provided " .. type(row)) end
  column = self:checkNumber(column)
  if column == 0 then error(ae .. " column must be a number, you provided " .. type(column)) end
  if row &gt; maxRow then error(ae .. " row is higher than the number of rows in the table. Highest row:" .. maxRow) end
  if column &gt; maxColumn then error(ae .. " column is higher than the number of columns in the table. Highest column:" .. maxColumn) end
  local entryType = type(entry)
  entry = self:checkEntry(entry)
  if entry == 0 then
    if type(entry) == "function" then 
      error(ae .. " entry was provided as a function, but does not return a string. We need a string in the end")
    else 
      error("demonnic.TableMaker:setCell(row, column, entry): Argument Error: entry must be a string, or a function which returns a string. You provided a " .. entryType)
    end
  end
  self.rows[row][column] = entry
end

function demonnic.TableMaker:totalWidth()
  local width = 0
  local numberOfColumns = #self.columns
  local separatorWidth = string.len(self.separator)
  local edgeWidth = string.len(self.edgeCharacter) * 2
  for _,column in ipairs(self.columns) do
    width = width + column.options.width
  end
  separatorWidth = separatorWidth * (numberOfColumns - 1)
  width = width + edgeWidth + separatorWidth
  return width
end

function demonnic.TableMaker:getType()
  local dec = {"d", "decimal", "dec"}
  local hex = {"h", "hexidecimal", "hex"}
  local col = {"c", "color", "colour", "col", "name"}
  if table.contains(dec, self.formatType) then
    return 'd'
  elseif table.contains(hex, self.formatType) then
    return 'h'
  elseif table.contains(col, self.formatType) then
    return 'c'
  else
    return ''
  end
end

function demonnic.TableMaker:echo(message, echoType, ...)
  local fType = self:getType()
  local consoleType = type(self.autoEchoConsole)
  local console = ""
  if echoType == nil then echoType = "" end
  if consoleType == "string" then
    console = self.autoEchoConsole
  else
    console = self.autoEchoConsole.name
  end
  local functionName = string.format("%secho%s", fType, echoType)
  local func = _G[functionName]
  if fType == "" then formatted = false end
  if echoType == "" then
    func(console, message)
  else
    func(console, message, ...)
  end
end

function demonnic.TableMaker:scanRow(rowToScan)
  local row = table.deepcopy(rowToScan)
  local rowEntries = #row
  local numberOfColumns = #self.columns
  local columns = {}
  local linesInRow = 0
  local rowText = ""
  local ec = self.frameColor .. self.edgeCharacter .. self.colorReset
  local sep = self.separatorColor .. self.separator .. self.colorReset

  if rowEntries &lt; numberOfColumns then
    entriesNeeded = numberOfColumns - rowEntries
    for i = 1,entriesNeeded do
      table.insert(row, "")
    end
  end
  for index,formatter in ipairs(self.columns) do
    local str = row[index]
    local column = ""
    if type(str) == "function" then str = str() end
    column = formatter:format(str)
    table.insert(columns, column:split("\n"))
  end
  for _,rowLines in ipairs(columns) do
    if linesInRow &lt; #rowLines then linesInRow = #rowLines end
  end
  for index,rowLines in ipairs(columns) do
    if #rowLines &lt; linesInRow then
      local neededLines = linesInRow - #rowLines
      for i=1,neededLines do
        table.insert(rowLines, self.columns[index]:format(""))
      end
    end
  end
  for i= 1,linesInRow do
    local thisLine = ec
    for index,column in ipairs(columns) do
      if index == 1 then
        thisLine = string.format("%s%s", thisLine, column[i])
      else
        thisLine = string.format("%s%s%s", thisLine, sep, column[i])
      end
    end
    thisLine = string.format("%s%s", thisLine, ec)
    if rowText == "" then
      rowText = thisLine
    else
      rowText = string.format("%s\n%s", rowText, thisLine)
    end
  end
  return rowText
end

function demonnic.TableMaker:echoRow(rowToScan)
  local row = table.deepcopy(rowToScan)
  local rowEntries = #row
  local numberOfColumns = #self.columns
  local columns = {}
  local linesInRow = 0
  local ec = self.frameColor .. self.edgeCharacter .. self.colorReset
  local sep = self.separatorColor .. self.separator .. self.colorReset
  if rowEntries &lt; numberOfColumns then
    entriesNeeded = numberOfColumns - rowEntries
    for i = 1,entriesNeeded do
      table.insert(row, "")
    end
  end
  for index,formatter in ipairs(self.columns) do
    local str = row[index]
    local column = ""
    if type(str) == "function" then str = str() end
    if type(str) == "table" then 
      str = str[1]
    end
    column = formatter:format(str)
    table.insert(columns, column:split("\n"))
  end
  for _,rowLines in ipairs(columns) do
    if linesInRow &lt; #rowLines then linesInRow = #rowLines end
  end
  for index,rowLines in ipairs(columns) do
    if #rowLines &lt; linesInRow then
      local neededLines = linesInRow - #rowLines
      for i=1,neededLines do
        table.insert(rowLines, self.columns[index]:format(""))
      end
    end
  end
  for i= 1,linesInRow do
    self:echo(ec)
    for index,column in ipairs(columns) do
      local message = column[i]
      if index ~= 1 then 
        self:echo(sep)
      end
      if type(row[index]) == "string" then
        self:echo(message)
      elseif type(row[index]) == "table" then
        local rowEntry = row[index]
        local echoType = ""
        if type(rowEntry[2]) == "string" then
          echoType = "Link"
        elseif type(rowEntry[2]) == "table" then
          echoType = "Popup"
        end
        self:echo(message, echoType, rowEntry[2], rowEntry[3], rowEntry[4] or true)
      end
    end
    self:echo(ec)
    if i ~= linesInRow then
      self:echo("\n")
    end
  end
end

function demonnic.TableMaker:makeHeader()
  local totalWidth = self:totalWidth()
  local ec = self.frameColor .. self.edgeCharacter .. self.colorReset
  local sep = self.separatorColor .. self.separator .. self.colorReset
  local header = self.frameColor .. string.rep(self.headCharacter, totalWidth) .. self.colorReset
  local columnHeaders = ""
  if self.printHeaders then
    local columnEntries = {}
    for _,v in ipairs(self.columns) do
      table.insert(columnEntries, v:format(v.options.name))
    end
    local divWithNewlines = string.format("\n%s", self:createRowDivider())
    columnHeaders = string.format("\n%s%s%s%s", ec, table.concat(columnEntries, sep), ec, divWithNewlines)
  end
  header = string.format("%s%s", header, columnHeaders)
  return header
end

function demonnic.TableMaker:createRowDivider()
  local columnPieces = {}
  for _,v in ipairs(self.columns) do
    local piece = string.format("%s%s%s", self.separatorColor, string.rep(self.rowSeparator, v.options.width), self.colorReset)
    table.insert(columnPieces, piece)
  end
  local ec = self.frameColor .. self.edgeCharacter .. self.colorReset
  local sep = self.separatorColor .. self.separator .. self.colorReset
  return string.format("%s%s%s", ec, table.concat(columnPieces, sep), ec)
end

--- enables making cells which incorporate insertLink/insertPopup
function demonnic.TableMaker:enablePopups()
  self.autoEcho = true
  self.allowPopups = true
end

--- enables autoEcho so that when assemble is called it echos automatically
function demonnic.TableMaker:enableAutoEcho()
  self.autoEcho = true
end

--- disables autoecho. Cannot be used if allowPopups is set
function demonnic.TableMaker:disableAutoEcho()
  if self.allowPopups then
    error("demonnic.TableMaker:disableAutoEcho(): you cannot disable autoEcho once you have enabled popups.")
  else
    self.autoEcho = false
  end
end

--- Enables automatically clearing the miniconsole we echo to
function demonnic.TableMaker:enableAutoClear()
  self.autoClear = true
end

--- Disables automatically clearing the miniconsole we echo to
function demonnic.TableMaker:disableAutoClear()
  self.autoClear = false
end

--- Set the miniconsole to echo to
--@param console The miniconsole to autoecho to. Set to "main" or do not pass the parameter to autoecho to the main console. Can be a string name of the console, or a Geyser MiniConsole
function demonnic.TableMaker:setAutoEchoConsole(console)
  local funcName = "demonnic.TableMaker:setAutoEchoConsole(console)"
  if console == nil then 
    console = "main" 
  end
  local consoleType = type(console)
  if consoleType ~= "string" and consoleType ~= "table" then
    error(funcName .. " ArgumentError: console as string or Geyser.MiniConsole expected, got " .. consoleType)
  elseif consoleType == "table" and console.type ~= "miniConsole" then
    error(funcName .. " ArgumentError: console received was a table and may be a Geyser object, but console.type is not miniConsole, it is " .. console.type)
  end
  self.autoEchoConsole = console
end

--- Assemble the table. If autoEcho is enabled/set to true, will automatically echo. Otherwise, returns the formatted string to echo the table
function demonnic.TableMaker:assemble()
  if self.allowPopups and self.autoEcho then
    self:popupAssemble()
  else
    return self:textAssemble()
  end
end

function demonnic.TableMaker:popupAssemble()
  if self.autoClear then
    local console = self.autoEchoConsole
    if console and console ~= "main" then
      if type(console) == "table" then
        console = console.name
      end
      clearWindow(console)
    end
  end
  local divWithNewLines = string.format("\n%s\n", self:createRowDivider())
  local header = self:makeHeader() .. "\n"
  local footer = string.format("\n%s%s%s\n", self.frameColor, string.rep(self.footCharacter, self:totalWidth()), self.colorReset)
  self:echo(header)
  for _,row in ipairs(self.rows) do
    if _ ~= 1 then
      self:echo(divWithNewLines)
    end
    self:echoRow(row)
  end
  self:echo(footer)
end

function demonnic.TableMaker:textAssemble()
  local sheet = ""
  local rows = {}
  for _,row in ipairs(self.rows) do
    table.insert(rows, self:scanRow(row))
  end
  local divWithNewlines = string.format("\n%s\n", self:createRowDivider())
  local footer = string.format("%s%s%s", self.frameColor, string.rep(self.footCharacter, self:totalWidth()), self.colorReset)
  sheet = string.format("%s\n%s\n%s\n", self:makeHeader(), table.concat(rows, divWithNewlines), footer)
  if self.autoEcho then
    local console = self.autoEchoConsole or "main"
    if type(console) == "table" then console = console.name end
    if self.autoClear and console ~= "main" then
      clearWindow(console)
    end
    self:echo(sheet)
  end
  return sheet
end

--- Creates and returns a new TableMaker. See https://github.com/demonnic/fText/wiki/TableMaker for valid entries to the options table.
--@tparam table options table of options for the TableMaker object
function demonnic.TableMaker:new(options)
  local funcName = "emonnic.TableMaker:new(options)"
  local me = {}
  setmetatable(me, self)
  self.__index = self
  if options == nil then options = {} end
  if type(options) ~= "table" then
    error("demonnic.TableMaker:new(options): ArgumentError: options expected as table, got " .. type(options))
  end
  local options = table.deepcopy(options)
  if options.allowPopups == true then
    options.autoEcho = true
  else
    options.allowPopups = false
  end
  local columns = false
  if options.columns then
    if type(options.columns) ~= "table" then error("demonnic.TableMaker:new(options): option error: You provided an options.columns entry of type " .. type(options.columns) .. " and columns must a table with entries suitable for demonnic.TableFormatter:addColumn().") end
    columns = table.deepcopy(options.columns)
    options.columns = nil
  end
  local rows = false
  if options.rows then
    if type(options.rows) ~= "table" then error("demonnic.tableMaker:new(options): option error: You provided an options.rows entry of type " .. type(options.rows) .. " and rows must be a table with entrys suitable for demonnic.TableFormatter:addRow()") end
    rows = table.deepcopy(options.rows)
    options.rows = nil
  end
  for option, value in pairs(options) do
    me[option] = value
  end
  local dec = {"d", "decimal", "dec"}
  local hex = {"h", "hexidecimal", "hex"}
  local col = {"c", "color", "colour", "col", "name"}
  if table.contains(dec, me.formatType) then
    me.frameColor = me.frameColor or "&lt;255,255,255&gt;"
    me.separatorColor = me.separatorColor or me.frameColor
    me.colorReset = "&lt;r&gt;"
  elseif table.contains(hex, me.formatType) then
    me.frameColor = me.frameColor or "#ffffff"
    me.separatorColor = me.separatorColor or me.frameColor
    me.colorReset = "#r"
  elseif table.contains(col, me.formatType) then
    me.frameColor = me.frameColor or "&lt;white&gt;"
    me.separatorColor = me.separatorColor or me.frameColor
    me.colorReset = "&lt;reset&gt;"
  else
    me.frameColor = ""
    me.separatorColor = ""
    me.colorReset = ""
  end
  me.columns = {}
  me.rows = {}
  if columns then
    for _,column in ipairs(columns) do
      me:addColumn(column)
    end
  end
  if rows then
    for _,row in ipairs(rows) do
      me:addRow(row)
    end
  end
  return me
end
</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
		</ScriptGroup>
		<Script isActive="yes" isFolder="no">
			<name>last script (to trigger dependencies!)</name>
			<packageName></packageName>
			<script>raiseEvent('njs50PlevLoaded')</script>
			<eventHandlerList />
		</Script>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>bitches for clan</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>clan.checkBitches</name>
				<packageName></packageName>
				<script>clan = clan or {}

clan.acceptableMasters = clan.acceptableMasters or {
  Gnoggh = true,
  Taldoran = true,
  Trongle = true,
  Marsuvious = true,
  Altus = true,
  Mojune = true,
  Mohoonay = true,
  Myrth = true,
  Darion = true,
  Darius = true,
  Grehild = true,
  Bimgore = true,
  Eluard = true,
  Raksha = true,
  Gnodrick = true,
  Shazzul = true,
  Uduvrin = true,
  Gnodrick = true,
  Quorrel = true,
  Drulethan = true,
  Umarra = true,
  Gnomigs = true,
  Trea = true,
  Chundrick = true,
  Aleron = true,
  Brazden = true,
  Bede = true,
  Migs = true,
  Darrarki = true,
}

clan.checkBitches = function(evt, who)

  -- display(who.Befriended[player.name].clan)
  
  if (who.Befriended[player.name] and who.Befriended[player.name].clan ~= ' -- ') then
    
    clan.online = who.clan[who.Befriended[player.name].clan]
  
    for name, playa in pairs(clan.online) do
      if (not clan.acceptableMasters[name]) then
        clan.acceptableMasters[name] = true
        cecho('&lt;green&gt;CLAN:&lt;white&gt; bitches granted to ' .. name .. ' due to clan member\n')
      end
    end
  
  end
  

end</script>
				<eventHandlerList>
					<string>COMMON::parsed_who</string>
				</eventHandlerList>
			</Script>
		</ScriptGroup>
	</ScriptPackage>
	<KeyPackage />
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
