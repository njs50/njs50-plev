<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>parse prompt</name>
			<script>-- set prompt to this:

-- Prompt:
-- ?p' -- MORE -- '&lt;%f?f|@R%hhp@n @G%ee@n @B?m'[%mmv]'!m'%vmv'@n %gwm %xxp?l' %llhp' %d?b' %c'&gt;


-- need to have the group parsed aleady to have things to fill in
if ( not group.leader or not player.name ) then

		echo('\nWaiting for leader before parsing prompt...\n')
		if (not player.initPending) then
			player.initPending = true
			common.initPlayer()
		end

else

	-- prompt flags:
	-- c - camouflaged
  -- h - hidden
  -- i - invisible
  -- P - player killing ok
  -- A - arena
  -- p - parry on
  -- S - sanctuary
  -- s - sneaking
  -- t - tracking
  -- x - searching
  -- B - burdened
  -- b - berserk skill active
  -- f - focus skill active
  -- M - you have new mudmail

	local promptFlags = matches[2]

	-- set parry state
	if string.find(promptFlags, 'p') then player.parry = true else player.parry = false end


	if string.find(promptFlags, '[chi]') then player.hidden = true else player.hidden = false end



  group[player.name].hp = tonumber(matches[3])
  group[player.name].mp = tonumber(matches[4])
  group[player.name].moves = tonumber(matches[5])

  player.hp = tonumber(matches[3])
  player.mp = tonumber(matches[4])
  player.moves = tonumber(matches[5])

  group.lowest_moves = tonumber(matches[6])

	if (matches[7] and matches[7] ~= '') then
		-- echo('\nsetting leader hp to ' .. tostring(matches[7]))
  	if (group[group.leader]) then
			group[group.leader].hp = tonumber(matches[7])
		else
			cecho('\n^^&lt;orange&gt;PROMPT &lt;white&gt; i spy leader hp but might not be grouped yet...\n')
		end

	end

	if (matches[9] == '-Dark-') then
		cecho('\n^^&lt;red&gt;\nIt\'s super dark yo! &lt;white&gt;-- make light\n')
	end

end

raiseEvent(common.events.PARSED_PROMPT)



-- examples...

-- &lt;209hp 94e 138mv 138wm 122617xp NESW&gt;
-- &lt;S|472hp 629e 150mv 150wm 12777631xp ??&gt;  &lt;-- sleeping prompt
-- &lt;304hp 28e [375mv] 152wm 1260782xp -Dark-&gt;

-- &lt;209hp 94e 138mv 138wm 122751xp NESW leaking guts&gt;
-- &lt;527hp 27e 181mv 161wm 7020514xp 500lhp EW&gt;
-- &lt;209hp 94e 138mv 138wm 122617xp NESW&gt;
-- &lt;527hp 27e 182mv 182wm 7020514xp ?? NESW&gt;
-- &lt;527hp 27e 181mv 161wm 7026324xp 500lhp EW covered in blood&gt;</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^&lt;(\w+\|)?(\d+)hp (\d+)e \[?(\d+)mv\]? (\d+)wm\s+[0-9-]+xp (\d+)?(lhp\s|\?\?\s)?([NESWneswUDud]+|-Dark-|none|\?\?)(\s.+)?&gt;</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>repeat stuff jammed in prompt</name>
			<script>-- deleting the line prevents any further triggers being executed on it?

if (matches[3] and matches[3] ~= '') then

  local prompt = matches[2]
  local stuff = matches[3]

  deleteLine() -- this will prevent any further triggers matching this line!?

  feedTriggers(prompt .. '\n')
  feedTriggers(stuff .. '\n')
  cecho('&lt;green&gt; ^^ was appended to prompt')

end
</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^(&lt;[^&gt;]*&gt;)\s*(.+)$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="yes" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>filter broken prompts</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^(?:&lt;[^&gt;]+&gt;\s*)?([^&lt;].*)$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>parsing stuff</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>parse score (position and condition)</name>
					<script>player.position = matches[2]
player.condition = string.split(matches[3], ' ')

if (common.tableHasValue(player.condition, 'delirious')) then
	cecho('\n&lt;green&gt;SCORE: &lt;white&gt;tripping with the fishes\n')
	player.tripping = true
else
	player.tripping = false
end

common.onNextEvent(common.events.PARSED_PROMPT, function (evt, args)
	raiseEvent(common.events.PARSED_SCORE)
end)
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\s+Position:\s+\[\s+(\w+)\s+]\s+Condition: \[\s+(\w+)\s+\]</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>parse group</name>
					<script>-- Leader: Darion
--
-- [ 14 Pal Dwf   ] Darion                209/209     94/94   138/138       122869
-- [ 41 Pal Dwf L ] Darion                641/641   100/100   205/205     11787449

-- pretend these players aren't in our group
-- need to do this if they don't have the teamwork triggers
-- i.e wont respond to commands / queries
local playerIgnore = {
	-- Marsuvious = true,
	-- Bashukin = true,
}

-- group row
if (matches[3]) then

	if (matches[2] == player.name or not player.tripping) then

		if playerIgnore[matches[2]] then
			echo(' &lt;-- ignored')
			return
		end

    local status = group[matches[2]] or {}

    status.hp = tonumber(matches[3])
    status.hp_max = tonumber(matches[4])
    status.mp = tonumber(matches[5])
    status.mp_max = tonumber(matches[6])
    status.moves = tonumber(matches[7])
    status.moves_max = tonumber(matches[8])
    status.xp = matches[9]

    --
    selectString(matches[1],1)
    replace(matches[1]:gsub(matches[9], common.commaCase(matches[9])))
    -- cecho(' &lt;- &lt;green&gt;replaced some numbers\n')
    group[matches[2]] = status

		-- dupe into player info for conwenience
		if (matches[2] == player.name) then
			for key, val in pairs(status) do
				player[key] = val
			end
		end

		if (not player.tripping) then
			group.memberCount = group.memberCount + 1
			group.members = group.members or {}
			group.members[matches[2]] = true
		end

	else
		echo(' &lt;-- tripping')
	end

-- leader row
else

	if (matches[2] == player.name or not player.tripping) then
		group.leader = matches[2]
		if (not player.tripping) then
  		group.memberCount = 0
  		group.members = {}
		end
	else
		echo(' &lt;-- tripping')
	end

  common.onNextEvent(common.events.PARSED_PROMPT, function (evt, args)
		-- echo('\n ^^ raising parsed group event\n\n')
		player.initPending = false
  	raiseEvent(common.events.PARSED_GROUP)
  end)

end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\[\s+\d+\s+\w+\s+\w+\s+\w*\s*\]\s+(\S+)\s+(\d+)/(\d+)\s+(\d+)/(\d+)\s+(\d+)/(\d+)\s+(\d+)$</string>
						<string>^Leader:\s+(.*)$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>parse inventory</name>
					<script>
-- display(matches)

-- a stick of blue chalk           1  .10   a simple mug of water           1  .27
-- a fragment of burning red stone                                          1  .50

if (matches[2] == 'Coins') then

	-- start of inventory
	player.coins = tonumber(matches[3])
	player.coinWeight = tonumber(matches[4])
	player.parsingInventory = true
	player.inventory = {}


else

	if (matches[2] == 'Number') then
		-- this is the end of the inventory

		raiseEvent(common.events.PARSED_INVENTORY)
		player.parsingInventory = false


	else

		-- inventory line
		player.inventory[matches[2]] = tonumber(matches[3])

		if(matches[5]) then
			player.inventory[matches[5]] = tonumber(matches[6])
		end

	end

end


</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(Coins): (\d+) = \[ .* \] \s+ Weight: (\d+\.\d+) lbs</string>
						<string>^\s+(Number):\s+(\d+)\s+\( Max =\s+(\d+) \)</string>
						<string>^(an? .+?)\s+(\d+)\s+(\d*\.?\d+?)\s+(an? .+?)\s+(\d+)\s+(\d*\.?\d+?)</string>
						<string>^(an? .+?)\s+(\d+)\s+(\d*\.?\d+?)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>parse affects</name>
					<script>echo('^^ --- looking at affects...\n')
player.affects = {}

local affectWatcher = tempRegexTrigger([[^(Your? .+?)\s{3,}(\S.*)$]], function ()
	player.affects[matches[2]] = matches[3]
end)

common.onNextEvent(common.events.PARSED_PROMPT, function()

	killTrigger(affectWatcher)
	raiseEvent(common.events.PARSED_AFFECTS, player.affects)

end)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Affect\s+Source\s*$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>parse prepped</name>
					<script>player.prepped = {}

local prepTrig = tempRegexTrigger([[^\s*(\d+)\s*(.+?)\s*\d+\s*$]], function ()
	player.prepped[matches[3]] = tonumber(matches[2])
end)

common.onNextEvent(common.events.PARSED_PROMPT, function (evt, args)
	killTrigger(prepTrig)
	raiseEvent(common.events.PARSED_PREPARED, player.prepped)
end)	</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You have no spells prepared.</string>
						<string>^Num\s+Spell\s+Mana\s*$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>parse equipment</name>
					<script>player = player or {}
player.gear = player.gear or {}
player.itemSlot = player.itemSlot or {}

if (matches[2] == 'Equipment') then
	-- start of parsing

	player.gear.parsing = true
	player.gear = {}
	-- cecho(' &lt;--- parsing start')

elseif (matches[2] == 'Weight') then

	-- end of parsing
	player.gear.parsing = nil
	player.gear.currentSlot = nil

	raiseEvent(common.events.PARSED_EQUIPMENT)
	-- cecho(' &lt; --- parsing end')
	-- display(player.gear)

else

 	-- if this line has a slot, get rid of the redundant part and set it to be the current slot
	if (matches[2] ~= '') then
		player.gear.currentSlot = rex.gsub(matches[2], [[^(floating|worn on|worn around|worn about) ]], "", 1)
	end

	local item = common.itemSanitize(matches[4])

	player.gear[player.gear.currentSlot] = player.gear[player.gear.currentSlot] or {}
	player.gear[player.gear.currentSlot][matches[3]] = {item = item, condition = matches[5] }

	player.itemSlot[item] = {slot=player.gear.currentSlot, layer=matches[3]}
	-- cecho(' &lt;--- its some gear ')

end



           </script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\s+ \+\+\+ (Equipment) \+\+\+</string>
						<string>^(Weight):</string>
						<string>^(.*?)\s+(bottom|under|base|over|top)\s+(.*?)\s+(worthless|damaged|very worn|worn|very scratch|scratched|reasonable|good|very good|excellent|perfect)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>parse skills</name>
					<script>-- replicate             unk        1920    8    minor enchantment [7] &amp; continual light [7]
-- riding                 10
-- ryoushi               unk          16    5

-- cecho('&lt;green&gt; &lt;--- incoming skills')

player.skills = player.skills or {}
local skillParser = tempRegexTrigger([[^(.+?)\s{2,}(\d+|unk)]], function()

  local skill = matches[2]
  local level
  if (matches[3] == 'unk') then
    level = 0
  else
    level = tonumber(matches[3])
  end
  player.skills[skill] = level
end)

common.onNextEvent(common.events.PARSED_PROMPT, function ()
  -- cecho('&lt;green&gt; &lt;--- incoming skills done')
  killTrigger(skillParser)
  -- display(player.skills)
end)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Skill\s+Level\s+Cost\s+Pracs\s+Prerequsites\s*$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>improve</name>
					<script>-- ** You improve at escape. **

local skill = matches[2]

if (player.skills and player.skills[skill] ~= nil and player.skills[skill] &gt; 0) then

  player.skills[skill] = player.skills[skill] + 1

else

  send('abil all')

end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\*\* You improve at (.*)\. \*\*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>sleep-murder</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>tank returned</name>
					<script>murder.tankState = 'here'

local combatStarted
local combatEnded
local roomChanged
local resumeTimer

-- kill countdown if combat ends in this time
local killResumeTimer = function ()

  if resumeTimer ~= nil then
		killTimer(resumeTimer)
		cecho('\n&lt;green&gt;MURDER: &lt;white&gt;killed waiting for tank action timer: ')
		resumeTimer = nil
     -- kill any remaining event watchers
    combatStarted()
    combatEnded()
    roomChanged()
	end

end



if (murder.resumeTimer) then
  killResumeTimer()
end

-- setup timer to resume in x secs if no action...
resumeTimer = tempTimer(90, function ()
  killResumeTimer()
	cecho('\n&lt;yellow&gt;MURDER: &lt;white&gt;tank returned and no action within 60s')
	send('gt seems like a suspect pause....')
	send('gt resume')
end, 'waitng for tank to do something after resuming (60s)')




-- the problematic one seems to be when we switch rooms right as
-- the tank returns because there is no mob to kill
roomChanged = common.onNextEvent(tfe.events.ROOM_CHANGED, function ()
  cecho('\n&lt;green&gt;MURDER:&lt;white&gt; cleared resume timer\n')
  killResumeTimer()
	-- common.onNextEvent(tfe.events.ROOM_CHANGED, killResumeTimer)
end)

combatEnded = common.onNextEvent(common.events.COMBAT_ENDED, killResumeTimer)
combatStarted = common.onNextEvent(common.events.COMBAT_STARTED, killResumeTimer)	</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\S+ tells the group[^:]*: "(back|still here|saw it die)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>mob state</name>
					<script>local damState = {
 ['perfect health'] = 1,
 ['slightly scratched'] = 0.95,
 ['few bruises'] = 0.85,
 ['some cuts'] = 0.75,
 ['several wounds'] = 0.65,
 ['badly wounded'] = 0.55,
 ['many nasty wounds'] = 0.45,
 ['bleeding freely'] = 0.35,
 ['covered in blood'] = 0.25,
 ['leaking guts'] = 0.15,
 ['mostly dead'] = 0.1,
 ['stunned'] = 0,
 ['incapacitated'] = 0,
 ['mortally wounded'] = 0,
 ['DEAD!'] = 0
}


player.dance_threshold = player.dance_threshold or damState['bleeding freely']



if (murder.pendingActionTimer) then
	killTimer(murder.pendingActionTimer)
	murder.pendingActionTimer = nil
end

if (murder.sleepMode == 'paused') then
	return
end


local health = damState[matches[3]] or 1

if (not damState[matches[3]]) then
	cecho('\n\n&lt;red&gt;MURDER: &lt;white&gt;Unknown health state' .. matches[3] .. '\n\n')
end




if health &lt;= player.dance_threshold then
-- if (matches[3] ~= 'DEAD!') then

	murder.sleepMode = 'dancing'

elseif (matches[3] == 'DEAD!') then

	-- back to the start
	murder.sleepMode = 'next'

else

	murder.sleepMode = 'chopping'

end

cecho(' &lt;-- &lt;white&gt;' .. health * 100 .. '% : ' .. murder.sleepMode .. '\n')
	</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff00ed</mFgColor>
					<mBgColor>#44433f</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Your ([a-z-]+) .*\[\s+(.*)\s+\]!?\.?$</string>
						<string>^The burst of flame (\S+) .*\[\s+(.*)\s+\]$</string>
						<string>^The blue arcs of energy (\S+) .*\[\s+(.*)\s+\]$</string>
						<string>^The touch of ice (\S+) .*\[\s+(.*)\s+\]$</string>
						<string>^The touch of acid (\S+) .*\[\s+(.*)\s+\]$</string>
						<string>^The brilliant bolt of lightning (\S+) .*\[\s+(.*)\s+\]$</string>
						<string>^The splatter of acid (\S+) .*\[\s+(.*)\s+\]$</string>
						<string>^The bifurcating lightning bolt (\S+) .*\[\s+(.*)\s+\]$</string>
						<string>^An incandescent spear of flame (\S+) .*\[\s+(.*)\s+\]$</string>
						<string>^The sphere of cold (\S+) .*\[\s+(.*)\s+\]$</string>
						<string>^The icy blast (\S+) .*\[\s+(.*)\s+\]$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>falls asleep - murder mode</name>
					<script>
-- nb: if mob is incapacitated mage will be unable to leave the room

local vic = common.dotCase(common.toMurderString(matches[3]))
murder.lastMob = vic


-- reminder to check murder.resume() clears a murder.pause() timer on moju
-- also that a second murder.pause doesn't start a second timer?


local setActionPending = function ()

 	-- setup timer to resume in x secs if no action...
	-- restart timer if one exists already
	if (murder.pendingActionTimer) then
		killTimer(murder.pendingActionTimer)
	end

	if (murder.sleepMoode ~= 'paused') then
  	murder.pendingActionTimer = tempTimer(10, function ()
  		cecho('\n\n&lt;yellow&gt;MURDER: &lt;White&gt;pending action didn\'t occur within 10s\n')
     	murder.sleepMode = 'next'
  		murder.pendingActionTimer = nil
  	end, 'pending action timer (chop/dance)')
	end


end

--
if (murder.sleepMode == 'next') then

	send('gt pause')

	-- go straight to dance mode if our threshold is 100%
	-- looking at you charging warriors / assasinating thieves
	if (player.dance_threshold == 1) then
		murder.sleepMode = 'dancing'
	else
		murder.sleepMode = 'chopping'
	end

end

if (murder.sleepMode == 'paused') then

	cecho('&lt;white&gt; &lt;- ignoring (murdering paused)')

elseif (murder.sleepMode == 'chopping') then

	murder.sleepMode = 'chop-pending'
	setActionPending()

	common.setParryState(false, 'sleepmode: chopping', function ()

  	if (improves and improves.spellList and #improves.spellList &gt; 0 and player.mp &gt; 90 and murder.castingLocked == nil) then

      local spell = improves.getImproveSpell()


      if (spell ~= '') then

        cecho(' &lt;-- set casting lock')
  			murder.castingLocked = tempTimer(35, function ()
  				murder.castingLocked = nil
  			end, 'casting locked for 35s')

        tempTimer(2, function ()
          send(spell .. ' ' .. vic .. ' &amp; k ' .. vic)
        end, 'delay in case of tank queued sleep?')

      else
			  send('k ' .. vic)
      end

  	else
			-- cecho('\n&lt;green&gt;MURDER: &lt;white&gt;didn\'t cast, mp: ' .. tostring(player.mp) .. ', cl: ' .. tostring(murder.castingLocked) .. '\n')
  		send('k ' .. vic)
  	end
	end)

-- can be in dance-pending if we miss during the previous dance-pending
elseif (murder.sleepMode == 'dancing') then

	murder.sleepMode = 'dance-pending'
	setActionPending()

	common.setParryState(true, 'sleepmode: dancing', function ()

  	if (murder.tankState == 'here') then
			-- delay to allow queue to catch up
			tempTimer(1, function ()
  			send('dismount &amp; stand &amp; sit')
    		send('queue gt leave')
			end, 'waiting for parry to kick in (queue delay)')

  		murder.tankState = 'out-pending'
    	tempRegexTrigger([[^\S+ tells the group[^:]*: "(out|failed to leave)"]], function ()

        murder.tankState = 'out-confirmed'

    		if (matches[2] == 'out') then

          cecho('\n&lt;orange&gt;PARRY: &lt;white&gt;setting  - temp off (dance hit then reenable)')
          player.parryQueue = player.parryQueue + 2


          local returnModes = {before = true, after = true, with = true}
          if (not returnModes[player.danceReturnMode]) then
            player.danceReturnMode = 'after'
          end

          player.danceReturnMode = player.danceReturnMode or 'after'

          if (player.danceReturnMode == 'before') then
            send('queue gt return ' .. vic)
          end

          send('queue opt parry &amp; queue stand &amp; queue mount')

          if (player.danceReturnMode == 'with') then
            send('queue gt return ' .. vic)
          end

          send('queue k ' .. vic .. ' &amp; queue opt parry')


          if (player.danceReturnMode == 'after') then
            send('queue gt return ' .. vic)
          end


    		else
  				cecho('\n&lt;orange&gt;PARRY: &lt;white&gt;setting  - temp off (dance hit then reenable)')
          send('opt parry &amp; stand &amp; mount &amp; k ' .. vic .. ' &amp; queue opt parry' )
          send('queue gt wtf??? - stabbing it anyway')
					player.parryQueue = player.parryQueue + 2
  				murder.tankState = 'here'
    		end

    	end, 1)

    else
      cecho('\n\n&lt;red&gt;MURDER: &lt;white&gt;wtf is the tank?\n')
  	end

	end)

end


cecho(' &lt;-- &lt;white&gt;' .. murder.sleepMode .. '\n')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#42ff2d</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(A|An|The) (.*) drops .* asleep\.</string>
						<string>^(A|An|The) (.*) slips deeper into slumber\.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>resume murdering on mob kill</name>
					<script>if (player.onDeadTrig ~= nil) then
  killTrigger(player.onDeadTrig)
  player.onDeadTrig = nil
end

player.onDeadTrig = tempRegexTrigger([[^\S+ tells the group[^:]*: "(back|still here|saw it die)"]], function ()

	if (murder.sleepMode ~= 'paused') then

  	murder.sleepMode = 'next'

  	common.setParryState(false, 'something died', function ()
  		send('gt resume')
  	end)

	end
	player.onDeadTrig = nil
end, 1)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\s+(A|An|The) .*s DEAD!!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>reset state on move</name>
					<script>murder = murder or {}
if (murder.sleepMode ~= 'paused') then
  murder.sleepMode = 'next'
  murder.tankState = 'here'
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\[Exits:</string>
						<string>^\|\s+Exits:</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>A x is DEAD!!</name>
					<script>send('look')
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#41ff1f</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\s+(A|An|The) .*s DEAD!!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>missed mob</name>
					<script>-- this will fail if we are parrying
-- but mob should be reslept anyway

local target = common.dotCase(common.toMurderString(matches[3]))

if (murder.sleepMode == 'dance-pending') then

  -- try agian next sleep
  cecho('\n\n&lt;yellow&gt;MURDER: &lt;white&gt;missed mob during dancing phase\n\n')
  murder.sleepMode = 'dancing'

else

  send('k ' .. target)

end

</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#38fbff</mFgColor>
					<mBgColor>#e000ff</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You miss (a|an|the) (.*)\.</string>
						<string>^You .+? (a|an|the) (.+?)('s.*)? inflicting no damage</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>mortal wound</name>
					<script>disableTrigger('mortal wound')
tempTimer(2, function()
  enableTrigger('mortal wound')
end)

local vic = common.dotCase(common.toMurderString(matches[3]))
cecho('\n&lt;yellow&gt;PARRY: &lt;white&gt;MORTAL WOUND')

if (murder.tankState == 'here') then
	-- can't do anything at this stage as mage is in combat and can't leave
	send('gt you should not be ere (might o hit that one too hard)')
  common.setParryState(false, 'sleepmode: mortal wound (tank in room)', function ()
    send('k ' .. vic)
  end)
else

  send('+gt abort abort, mortal wound detected!')

	-- send('opt parry &amp; stand &amp; k ' .. vic .. ' &amp; queue opt parry')
  common.onNextEvent(common.events.PARSED_PROMPT, function ()
    -- any queued parries will have been dequeued.
    player.parryQueue = 0
    common.setParryState(false, 'sleepmode: mortal wound', function ()
      send('k ' .. vic)
      send('queue gt return ' .. vic)
    end)
  end)
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(A|An|The) (.*) is mortally wounded, and will die soon, if not aided.</string>
						<string>^(A|An|The) (.*) is incapacitated and will slowly die, if not aided.</string>
						<string>^(A|An|The) (.*) is stunned, but will probably recover.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>tells the group to move</name>
					<script>if (murder.sleepMode ~= 'paused') then
	murder.sleepMode = 'next'
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(An? .+?|The .+?|\w+) tells the group[^:]*: "meet at (\d+)"</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>sleep failed</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Nothing happens.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Assist on Exits</name>
					<script>if (player.nextTarget) then
	send('k ' .. player.nextTarget)
	player.nextTarget =  nil
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>[Exits:</string>
						<string>^\|\s+Exits:</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>mob isn't here?</name>
					<script>cecho('&lt;red&gt; &lt;-- mob missing?!\n')
if (murder.sleepMode ~= 'paused') then
	murder.sleepMode = 'next'
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>The room doesn't contain any beings matching</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>get full if under x%</name>
					<script>local amt =  tonumber(matches[3]) / 100

local player = group[player.name]

local getFull = false


local pFullTrig = tempRegexTrigger([[^\w+ tells the group[^:]*: "getting full"]], function ()
	getFull = true
	send('gt righto')
end, 1)


tempTimer(3, function ()

	killTrigger(pFullTrig)

	if (getFull) then

  	send('sit couch &amp; sit chair &amp; sit pad &amp; sit boulder')
  	expandAlias('sl')
  	common.onFull( function ()
  		expandAlias('st')

  		tempTimer(3, function ()
  			player.gettingFull = false
  			expandAlias('gt ready (' .. player.name .. ')')
  		end)

    end)

	else

		send('gt ready (Myrth)')

	end


end)

</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^.* tells? (your|the) group[^:]*: "get full if under (\d+)% mana"</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>get full</name>
					<script>player.gettingFull = player.gettingFull or false

if (not player.gettingFull) then
	player.gettingFull = true
  send('ef &amp; dw &amp; dismount')

  tempTimer(2, function ()
  	send('sit couch &amp; sit chair &amp; sit pad &amp; sit boulder')
  	expandAlias('sl')
  	common.onFull( function ()
			expandAlias('st')
      send('mount')
    	-- expandAlias('give all.coin batso &amp; drop all.food &amp; get 2*food')

  		tempTimer(3, function ()
				player.gettingFull = false
  			expandAlias('gt ready (' .. player.name .. ')')
  		end)

    end)
  end)

else
	cecho('\n&lt;green&gt;PREP: &lt;white&gt;already getting full\n')
end

</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^.* tells? (?:your|the) group[^:]*: "(pfull|get full)"</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>dead thing</name>
					<script>-- send('skin corpse &amp; eat corpse &amp; get all &amp; drop all.corpse')
-- hope you are a troll or orc!
send('eat corpse')
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You receive \d+ experience points.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>snack break</name>
					<script>local vessel = player.vessel or 'leather.waterskin'

send('drink ' .. vessel .. ' &amp; drink ' .. vessel .. ' &amp; drink ' .. vessel .. ' &amp; queue give empty.' .. vessel .. ' ' .. group.leader)
send('queue gt fill my ' .. vessel)
send('gt snack me')
send('eat food &amp; eat food &amp; eat food &amp; eat food')
send('drop all.food &amp; get 4*food')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^.* tells the group[^:]*:\s+"snack break"$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>common</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Your throat feels dry.</name>
					<script>send('dw')

timedTempTrigger(0.5, 1, '^You cannot do that while sleeping\.$', function ()
	send('stand &amp; dw &amp; ef')
	tempTimer(1, function () send('sleep') end)
end)
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Your throat feels dry.</string>
						<string>^You are thirsty.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>^You are mildly hungry.</name>
					<script>send('eat corpse &amp; ef')

timedTempTrigger(0.5, 1, '^You cannot do that while sleeping\.$', function ()
	send('stand &amp; dw &amp; ef')
	tempTimer(1, function () send('sleep') end)
end)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You are mildly hungry.</string>
						<string>Your stomach rumbles with pangs of unnatural hunger.</string>
						<string>You are hungry.</string>
						<string>You are no longer afflicted by the hunger of the undead.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
						<integer>2</integer>
						<integer>2</integer>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>out of food</name>
					<script>disableTrigger('out of food')

tempTimer(3, function()
  enableTrigger('out of food')
end)

if (player.hasFoodBasket) then

  send('search basket &amp; eat food')

  -- You reach your hand into the basket and root around, but come up empty-handed.

elseif (player.caster) then



   if (common and common.getManaAndCast) then

    common.getManaAndCast(15, 'create food', '', false, function ()
  		send('eat food')
  	end)

  else

    timedTempTrigger(2, 1, '^You cannot do that while sleeping\.$', function ()
  		send('stand &amp; cast create food &amp; eat food')
    end)

    send('cast create food &amp; eat food')

  end




else
	send('gt out of food')
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Nothing found matching "food".</string>
						<string>You aren't carrying any items matching "food".</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>empty juice</name>
					<script>
disableTrigger('empty juice')

tempTimer(3, function()
  enableTrigger('empty juice')
end)


local vessel = common.dotCase(matches[2])


if (player.caster) then

  if (common and common.getManaAndCast) then
    send('remove blanket')
    common.getManaAndCast(10, 'create water', vessel, false, function ()
    	send('drink ' .. vessel)
    end)

  else

    timedTempTrigger(2, 1, '^You cannot do that while sleeping\.$', function ()
  		send('stand &amp; remove blanket &amp; empty ' .. vessel .. ' &amp; cast create water .. ' .. vessel .. ' &amp; wear blanket &amp; sleep')
    end)

    send('remove blanket &amp; cast create water ' .. vessel)
    send('drink ' .. vessel)

  end


else

	send('gt out of juice')

end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^An? (.*) you are carrying is already empty.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>created bad water</name>
					<script>local vessel = common.dotCase(matches[2])

if player.caster and matches[3] ~= 'water' then

  timedTempTrigger(2, 1, '^You cannot do that while sleeping\.$', function ()
		send('stand &amp; remove blanket &amp; empty ' .. vessel .. ' &amp; cast create water .. ' .. vessel .. ' &amp; wear blanket &amp; sleep')
  end)

	send('empty ' .. vessel)
  send('remove blanket &amp; cast create water ' .. vessel)

else

  timedTempTrigger(2, 1, '^You cannot do that while sleeping\.$', function ()
  	send('stand &amp; drink ' .. vessel .. '.water &amp; sleep')
  end)

	send('drink ' .. vessel .. '.water')

end


 -- Nothing found matching "dark crystal goblet".</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^An? (.*) fills to overflowing with (.*).</string>
						<string>^An? (.*) fills partially up with (.*).</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>awakened by pain</name>
					<script>send('sl')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You are suddenly awakened by the feeling of pain.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>dying of thirst etc</name>
					<script>
common.getAffects(function (affects) 

  if (affects["You feel the hunger of the undead."] == "temporary") then
    cecho('\n\n&lt;red&gt;HUNGRY: &lt;white&gt;suffering from hunger of the undead!!!\n\n')
    send('eat corpse &amp; ef')
  else
    send('ct poor management has led me to quit due to hunger or thirst.')
    send('quit')
  end

end)


</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You are dying</string>
						<string>^You are starving to death!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>level info</name>
					<script>
selectString(matches[1],1)
replace(matches[2] .. common.commaCase(matches[3]) .. matches[4])
-- cecho(' &lt;- &lt;green&gt;replaced some numbers\n')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(You have acquired )(\d+)( experience points so far this level\.)$</string>
						<string>^(You need )(\d+)( experience points to gain level \d+\.)$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>+++ You cast create food +++</name>
					<script>send('eat food')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>+++ You cast create food +++</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You happily follow x.</name>
					<script>group.leader = matches[2]</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You .* follow (\w+).</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>magic sleep/silence wears off</name>
					<script>send('stand &amp; group &amp; scan')
player.equippingSet = nil
if (healer and healer.clearQueued) then
  healer.clearQueued()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You no longer feel sleepy.</string>
						<string>You feel the cloak of silence enveloping you lift.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>sprawling</name>
					<script>disableTrigger('sprawling')
send('stand &amp; ord all stand &amp; k &amp; l')
tempTimer(2, function () enableTrigger('sprawling') end)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^A(n)? .* sends you sprawling on the ground!</string>
						<string>^A(n)? .* delivers a quick kick, knocking you down to the ground!</string>
						<string>^Perhaps you should stand first.</string>
						<string>^The fall .* you!</string>
						<string>^.* knocks you head over heels!$</string>
						<string>^You fall</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>teamwork</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>meet at x</name>
					<script>local rnum = matches[3]
send('look')

tempTimer(2, function ()

  tfe.gotoRoom(rnum, function ()
  	tempTimer(1, function ()
  		send('gt ' .. player.name .. ' is now at ' .. tostring(tfe.roomInfo.vnum))
  	end)
  end)

end)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(An? .+?|The .+?|\w+) tells the group[^:]*: "meet at (\d+)"</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>set next assist mob</name>
					<script>local vic = matches[4]
player.nextTarget = vic
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(.*) tells? (your|the) group[^:]*: "next is (.*)"</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>go to x</name>
					<script>local pname = matches[3]
local rnum = matches[4]

if (pname == player.name) then
	send('gt omw')

  tempTimer(2, function ()

    tfe.gotoRoom(rnum, function ()
    	tempTimer(1, function ()
    		send('gt ' .. player.name .. ' is now at ' .. tostring(tfe.roomInfo.vnum))
    	end)
    end)

  end)
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(An? .+?|The .+?|\w+) tells the group[^:]*: "(\w+) go to (\d+)"</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>where are you</name>
					<script>local pname = matches[3]

if (pname == "" or pname == player.name) then
   send('gt ' .. player.name .. ' is at ' .. tostring(tfe.roomInfo.vnum))
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(An? .+?|The .+?|\w+) tells the group[^:]*: "(\w*) ?where are you\?"</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>time for x</name>
					<script>expandAlias(matches[4])</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(An? .+?|The .+?|\w+) tells the group[^:]*: "time (for|to) (.*)"</string>
						<string>^(You) tell your group[^:]*: "time (for|to) (.*)"</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>x time for y</name>
					<script>
if (matches[3] == player.name) then
	expandAlias(matches[4])
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(An? .+?|The .+?|\w+) tells the group[^:]*: "(\w+) can you (.*)"</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>someone joins a group</name>
					<script>group = {}

send('group')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You join (.*)'s group.</string>
						<string>^(.*) joins (.*)'?s? group.</string>
						<string>^You remove (.*) from your group.</string>
						<string>^You leave (.*)'s group.</string>
						<string>^(.*) stops following you.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>pause/resume murder mode</name>
					<script>if (matches[2] == 'paused') then

	murder.sleepMode = 'paused'

	common.setParryState(true, 'murder mode paused', function ()
		send('gt holding off on the murdering')
	end, true)

else
	common.setParryState(false, 'murder mode resumed', function ()
		send('gt resuming the murdering')
	end, false)

	murder.sleepMode = 'next'
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\S+ tells the group[^:]*: "murder time (paused|resumed)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>command by leader or authority figure</name>
					<script>local acceptableMasters = {
  Gnoggh = true,
  Taldoran = true,
  Trongle = true,
  Marsuvious = true,
  Altus = true,
  Mojune = true,
  Mohoonay = true,
  Myrth = true,
  Darion = true,
  Darius = true,
  Grehild = true,
  Bimgore = true,
  Eluard = true,
  Raksha = true,
  Gnodrick = true,
  Shazzul = true,
  Uduvrin = true,
  Gnodrick = true,
}


if(matches[2] == group.leader or acceptableMasters[matches[2]]) then
  cecho('&lt;greenTEAMWORK: &lt;white&gt;command issued by leader')
  send('reply running command: ' .. matches[3])
	expandAlias(matches[3])
else
	cecho('&lt;red&gt;TEAMWORK: &lt;white&gt;command issued by non leader')
  send('reply command ignored due to not being leader or whitelisted')
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^([A-Za-z]+) tells you:\s*"do (.+)"$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>condition report</name>
					<script>if (#gmcp.Char.Status.conditions == 1 and gmcp.Char.Status.conditions[1]) then
	send('gstatus healthy - ' .. player.name )
else
  for idx, state in pairs(gmcp.Char.Status.conditions) do
  	if (state ~= 'sober') then
  		send('gstatus ' .. state .. ' - ' .. player.name )
      if (state == 'hungry') then
        send('ef &amp; ef')
      end
  	end
  end
end

</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^.* reports? group status: "condition report"$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>tells</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>tell</name>
					<script>common.chatConsole:cecho('&lt;green&gt;' .. getTime(true, "hh:mm:ss") .. ': &lt;white&gt;' .. matches[1] .. "\n")

</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>1</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^([A-Za-z]+) tells you:(.+)$</string>
						<string>^(You) tell (\w+|the clan):(.+)$</string>
						<string>^[^:]* ctells:(.+)$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>tell - two line</name>
					<script>common.chatConsole:cecho('&lt;green&gt;' .. getTime(true, "hh:mm:ss") .. ': &lt;white&gt;' .. multimatches[1][1] .. "\n")
common.chatConsole:cecho('&lt;white&gt;' .. multimatches[2][1] .. "\n")
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>2</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^([A-Za-z]+ tells you|You tell \w+|.* ctells|You tell the clan):$</string>
						<string>^\s*(".*")$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>tell - three line</name>
					<script>common.chatConsole:cecho('&lt;green&gt;' .. getTime(true, "hh:mm:ss") .. ': &lt;white&gt;' .. multimatches[1][1] .. "\n")
common.chatConsole:cecho('&lt;white&gt;' .. multimatches[2][1])
common.chatConsole:cecho('&lt;white&gt;' .. multimatches[3][1] .. "\n")
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>3</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^([A-Za-z]+ tells you|You tell \w+|.* ctells|You tell the clan):$</string>
						<string>^\s*(".*[^"])$</string>
						<string>^\s*([^" ].*")$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>prac/imp</name>
					<script>-- ** You improve at escape. **
-- ** You gain a practice point from escape. **

common.chatConsole:cecho('&lt;yellow&gt;' .. getTime(true, "hh:mm:ss") .. ': &lt;white&gt;' .. matches[1] .. "\n")

if (matches[2] == 'improve at') then
	send('save')
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\*\* You (gain a practice point from|improve at) (.*)\. \*\*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>player status</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>not tripping anymore</name>
					<script>player.tripping = false</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>The world returns to normal color.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>tripping</name>
					<script>player.tripping = true</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You see colors.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>standing status</name>
					<script>player.position = 'standing'</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You wake and stand up.</string>
						<string>^You stand up.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>sleep status</name>
					<script>player.position = 'sleeping'</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You lie down and go to sleep</string>
						<string>^You go to sleep .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>resting status</name>
					<script>player.position =  'resting'</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You wake and sit up.</string>
						<string>^You sit down.*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Parry set to x.</name>
					<script>if (matches[2] == 'true') then
	player.parry = true
else
	player.parry = false
end

player.parryQueue = (player.parryQueue or 1) - 1
cecho('&lt;yellow&gt; &lt;-- parry queue -- (' .. player.parryQueue .. ')')

if player.parryQueue &lt; 0 then
  player.parryQueue = 0
  cecho('\n&lt;red&gt;PARRY: &lt;white&gt;attempted to reduce queue below zero\n')
end

raiseEvent(common.events.PARRY_STATE_CHANGE)
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Parry set to (true|false)\.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Combat</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>inc mobs fighting</name>
					<script>combat.add(matches[3])</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(An?|The) (.*) leaps to attack you!$</string>
						<string>^(An?|The) (.*) counterattacks you!</string>
						<string>^(An?|The) (.*) says (in primal): "Have at you, then!"</string>
						<string>^(An?|The) (.*) says (in primal): "Please....please...h-help me..."</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>dec mobs fighting</name>
					<script>combat.remove(matches[2])</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You receive \d+ experience points\.</string>
						<string>^An? (.*) blindly flees (north|east|south|west|up|down).</string>
						<string>^An? (.*) vanishes in the blink of an eye!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>blocked|arrival|slept - extend room check</name>
					<script>combat.extendRoomCheck()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#0900ff</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(A|An|The) (.*) is blocking the exit to the (north|east|south|west|up|down)\.$</string>
						<string>^(A|An|The) (.*) arrives from the (north|east|south|west|up|down)\.$</string>
						<string>^(A|An|The) (.*) drops .* asleep\.</string>
						<string>You begin casting sleep.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>disarmed</name>
					<script>echo('disarmed!!!')
send('wear ' .. common.dotCase(matches[3]))</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\+\+\+ .+ disarms your (enchanted )?([^!]+)!  \+\+\+</string>
						<string>thrusts (his|her|their) shield against your ([^,]*),</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>counterattack</name>
					<script>combat.counterattack(matches[2])</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You counterattack an? (.*)!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>slept a mob</name>
					<script>combat.sleeping(matches[3])</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(A|An|The) (.*) drops .* asleep\.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>combat_parsing</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Caster assignment</name>
					<script>
-- `echo Mojune casts conflagration.
-- `echo A raging inferno *** DISINTEGRATES *** [437] a blue-skinned demon!  [ bleeding freely ]

local caster = matches[2]
local spell = matches[3]

if (caster == 'You') then
  caster = player.name
end

if not rex.find(spell, [[^(cure|heal|restoration|group|mists|purify|neutralize|fear|paralyze|group|slow|web|probe|silence)]]) then

  combat.dealer = caster
  combat.type = 'spell'
  combat.spell = spell
  combat.target = ''

else

  cecho('&lt;orange&gt; &lt;- non damage spell\n')
  combat.dealer = caster
  combat.type = ''
  combat.spell = ''
  combat.target = ''

end




</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>2</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#dee930</mFgColor>
					<mBgColor>#110092</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(\w+) casts (.*)\.</string>
						<string>^\+\+\+ (You) cast (.*) \+\+\+</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Melee assignmnet</name>
					<script>
-- You deflect a blue-skinned demon's obsidian claw rake and smash your shield into him!
-- Your shield strike SAVAGES [41] a blue-skinned demon!  [ covered in blood ] &lt;- proc Darion : 41

                                                                                        -- .
-- Darion deflects a blue-skinned demon's obsidian claw rake and smashes him with his shield!
-- Darion's shield strike SAVAGES [41] a blue-skinned demon!  [ covered in blood ]

local caster = matches[2]
local spell = matches[3]

if (caster == 'You') then
  caster = player.name
end

combat.dealer = caster
combat.type = 'melee'
combat.spell = ''
combat.target = ''

</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(You|[A-Z][a-z]+)'?s? [^[]+[!.]$   </string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>unassigned damage</name>
					<script>
-- removing things with 's in em due to tyrant's wife

-- ^((\S+).*?) (\** ?\w+ ?\**) \[(\d+)\]\s*((\S+).*)'s.*[!.]\s+\[\s+(.*?)\s+\]$


-- these should be legit:

-- The sword's thrust devastates [25] a beautiful witch!  [ slightly scratched ]
-- A raging inferno *** DISINTEGRATES *** [437] a blue-skinned demon!  [ bleeding freely ]
-- Your fire shield singes [1] a flying snake.  [ several wounds ]

-- A raging inferno ** INCINERATES ** [278] a tyrant's wife!



-- this is a problem after someone has cast a non damage spell:
-- A darkling's oily, musty secretion hits [3] a grasshopper mouse's small brown body.  [ several wounds ]

-- shoulld not match any of these:

-- Darion's blow MUTILATES [56] an orcish monk of the hidden order!  [ some cuts ]
-- The brilliant bolt of lightning ELECTRIFIES [78] Mojune!  [ few bruises ]

-- An orcish monk of the hidden order's spider kick DISEMBOWELS [81] your head!
-- A monk of the hidden order's serpent strike CRIPPLES [52] you!
-- The brilliant bolt of lightning ELECTRIFIES [78] Mojune!  [ few bruises ]

-- damage before mob
-- Darion's blow MUTILATES [56] an orcish monk of the hidden order!  [ some cuts ]
-- Darion's blow MUTILATES [56] an orcish monk of the hidden order's muscular arm!  [ some cuts ]

-- damage after mob
-- Your strike hits a red efreet's billowing flames [3].  [ slightly scratched ]
-- Your strike hits a red efreet [3].  [ slightly scratched ]


-- local caster = player.name
local spell = matches[2]
local spellFirstWord = matches[3]
local damageString = matches[4]
local damage = tonumber(matches[5])
local target = matches[6]
local targetFirstWord = matches[7]
local targetState = matches[8]



-- spell first word could be a group member!
if (spellFirstWord == 'You' or spellFirstWord == 'Your') then
  spellFirstWord = player.name
end
-- replace any 's i.e (Darion's) crushing blow -&gt; Darion
spellFirstWord = spellFirstWord:gsub("'?s?[.!]?$", "")

-- targetFirstWord could be a group member
if (targetFirstWord == 'you' or targetFirstWord == 'your') then
  targetFirstWord = player.name
end
-- replace any 's i.e (Darion's) crushing blow -&gt; Darion
targetFirstWord = targetFirstWord:gsub("'?s?[.!]?$", "")


if (group.members[spellFirstWord]) then
  -- cecho('\nGroup mmember attack, not unassigned...\n')
  combat.dealer = spellFirstWord
  combat.type = 'melee'
  combat.spell = ''
  combat.target = target

  if rex.match(damageString, [[^(scratches|grazes|hits|injures|wounds|mauls|decimates|devastates|maims|SAVAGES|CRIPPLES|MUTILATES|DISEMBOWELS|\* DISMEMBERS \*|\* EVISCERATES \*|\* MASSACRES \*|\* PULVERIZES \*|\*\* DEMOLISHES \*\*|\*\* EXTIRPATES \*\*|\*\*\* OBLITERATES \*\*\*|\*\*\* ERADICATES \*\*\*|\*\*\* ANNIHILATES \*\*\*)$]]) then
     -- this was melee damage and will be picked up elsewhere
     return
  else

    -- setting combat type to proc for any non melee damage done directly by a player.
    -- this should allow us to ignore ion/ice shield etc type damage when determining who a player is hitting
    combat.type = 'proc'

  end

end

if (group.members[targetFirstWord]) then
  -- cecho('\nmob attacking group member, not unassigned...\n')
  combat.type = ''
  return
end


if (combat.type and combat.type ~= '') then

  local attackData = {
    subject = combat.dealer,
    damageType = combat.type,
    move = spell,
    mob = target,
    damage = damage
  }

  if (combat.type == 'spell') then
    attackData.move = combat.spell
    combat.type = ''
  else
    attackData.damageType = 'proc'
  end

  if (group.members[attackData.subject]) then
    raiseEvent(common.events.COMBAT_ATTACK, attackData)
  else
    cecho('&lt;orange&gt; &lt;- non party member fighting\n')
  end

else
  cecho('&lt;- &lt;red&gt;COMBAT: &lt;white&gt;unsure who to allocate this damage to\n')
end

</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>4</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#dee930</mFgColor>
					<mBgColor>#10341f</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^((\S+).*?) (\** ?\w+ ?\**) \[(\d+)\]\s*((\S+).*)[!.]\s+\[\s+(.*?)\s+\]$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>hit - non attack</name>
					<script>-- Mohoonay's attack misses an ogre miner.
-- Shazzul hits an imposing fire giant witch-doctor with a power strike!

-- ^(You|Your|[A-Z][a-z]+?) hits (.*) with a (great cleave|cleave|power strike|critical hit)[!.]$
-- Shazzul parries a large shaggy wolf's attack, leaving her vulnerable to a counterattack!

-- You attempt to charge a minotaur guardian, but miss and fall down.

local subject = matches[2]
local move = matches[3]
local mob = matches[4]

local attacks = {
  ['great cleave'] = true,
  ['cleave'] = true,
  ['power strike'] = true,
  ['critical hit'] = true,
  ['counterattack'] = true,
  ['fall down'] = true,
}

-- swap mob and move if required
if (attacks[mob]) then
  local temp = mob
  mob = move
  move = temp
end


if (subject == 'You' or subject == 'Your') then
  subject = player.name
end

-- replace any 's i.e (Darion's) crushing blow -&gt; Darion
subject = subject:gsub("'s$", "")


local attackData = {
  subject = subject,
  move = move,
  mob = mob,
  damage = 0,
  damageType = 'no-damage',
}

if (group.members[attackData.subject]) then
  raiseEvent(common.events.COMBAT_ATTACK, attackData)
else
  cecho('&lt;orange&gt; &lt;- non party member fighting\n')
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#e13b95</mFgColor>
					<mBgColor>#1c1873</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(You|[A-Z][a-z]+) leaps? to (attack) (.*)[!.]$</string>
						<string>^(You|[A-Z][a-z]+) (miss)e?s? (.*)[!.]$</string>
						<string>^(You|[A-Z][a-z]+) (counterattack|critically hit|)s? (.*)[!.]$</string>
						<string>^(You|Your|[A-Z][a-z]+?)'?s? (great cleave|cleave|power strike) hits (.*)[!.]$</string>
						<string>^(Your|[A-Z][a-z]+)'s attack (miss)e?s? (.*)[!.]$</string>
						<string>^(You|Your|[A-Z][a-z]+?) hits (.*) with a (great cleave|cleave|power strike|critical hit)[!.]$</string>
						<string>^(You|[A-Z][a-z]+) (gouges) (.*) in the eye[!.]$</string>
						<string>^(You|[A-Z][a-z]+) calls upon the (shadows to deestroy) (.*)[!.]$</string>
						<string>^(You|[A-Z][a-z]+) parries (.*)'?s? attack, leaving .* vulnerable to a (counterattack)[!.]$</string>
						<string>^(You|[A-Z][a-z]+) attempts? to charge (.*), but miss and (fall down)[!.]$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>hit - damage first</name>
					<script>-- damage before mob

-- Darion's blow MUTILATES [56] an orcish monk of the hidden order!  [ some cuts ]
-- Darion's blow MUTILATES [56] an orcish monk of the hidden order's muscular arm!  [ some cuts ]



local subject = matches[2]

if (subject == 'You' or subject == 'Your') then
  subject = player.name
end

-- replace any 's i.e (Darion's) crushing blow -&gt; Darion
subject = subject:gsub("'s$", "")

combat.dealer = subject
combat.type = 'melee'
combat.spell = ''
combat.target = ''


local attackData = {
  subject = subject,
  move = matches[3],
  mob = matches[6],
  damage = tonumber(matches[5]),
  damageType = 'melee',
}

if (group.members[attackData.subject]) then
  raiseEvent(common.events.COMBAT_ATTACK, attackData)
else
  cecho('&lt;orange&gt; &lt;- non party member fighting\n')
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#e13b95</mFgColor>
					<mBgColor>#1c1873</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(Your|[A-Z][a-z]+'s) (.+) (scratches|grazes|hits|injures|wounds|mauls|decimates|devastates|maims|SAVAGES|CRIPPLES|MUTILATES|DISEMBOWELS|\* DISMEMBERS \*|\* EVISCERATES \*|\* MASSACRES \*|\* PULVERIZES \*|\*\* DEMOLISHES \*\*|\*\* EXTIRPATES \*\*|\*\*\* OBLITERATES \*\*\*|\*\*\* ERADICATES \*\*\*|\*\*\* ANNIHILATES \*\*\*) \[(\d+)\] (.*)'s .*[!.]\s+\[.+\]$</string>
						<string>^(Your|[A-Z][a-z]+'s) (.+) (scratches|grazes|hits|injures|wounds|mauls|decimates|devastates|maims|SAVAGES|CRIPPLES|MUTILATES|DISEMBOWELS|\* DISMEMBERS \*|\* EVISCERATES \*|\* MASSACRES \*|\* PULVERIZES \*|\*\* DEMOLISHES \*\*|\*\* EXTIRPATES \*\*|\*\*\* OBLITERATES \*\*\*|\*\*\* ERADICATES \*\*\*|\*\*\* ANNIHILATES \*\*\*) \[(\d+)\] (.+?)[!.]\s+\[.+\]$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>hit - damage last</name>
					<script>
-- damage after mob
-- Your strike hits a red efreet's billowing flames [3].  [ slightly scratched ]
-- Your strike hits a red efreet [3].  [ slightly scratched ]

local subject = matches[2]

if (subject == 'You' or subject == 'Your') then
  subject = player.name
end

-- replace any 's i.e (Darion's) crushing blow -&gt; Darion
subject = subject:gsub("'s$", "")

combat.dealer = subject
combat.type = 'melee'
combat.spell = ''
combat.target = ''


local attackData = {
  subject = subject,
  move = matches[3],
  mob = matches[5],
  damage = tonumber(matches[6]),
  damageType = 'melee',
}

if (group.members[attackData.subject]) then
  raiseEvent(common.events.COMBAT_ATTACK, attackData)
else
  cecho('&lt;orange&gt; &lt;- non party member fighting\n')
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#e13b95</mFgColor>
					<mBgColor>#1c1873</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(Your|[A-Z][a-z]+'s) (.+) (scratches|grazes|hits|injures|wounds|mauls|decimates|devastates|maims|SAVAGES|CRIPPLES|MUTILATES|DISEMBOWELS|\* DISMEMBERS \*|\* EVISCERATES \*|\* MASSACRES \*|\* PULVERIZES \*|\*\* DEMOLISHES \*\*|\*\* EXTIRPATES \*\*|\*\*\* OBLITERATES \*\*\*|\*\*\* ERADICATES \*\*\*|\*\*\* ANNIHILATES \*\*\*) (.+)'s .* \[(\d+)\][!.]\s+\[.+\]$</string>
						<string>^(Your|[A-Z][a-z]+'s) (.+) (scratches|grazes|hits|injures|wounds|mauls|decimates|devastates|maims|SAVAGES|CRIPPLES|MUTILATES|DISEMBOWELS|\* DISMEMBERS \*|\* EVISCERATES \*|\* MASSACRES \*|\* PULVERIZES \*|\*\* DEMOLISHES \*\*|\*\* EXTIRPATES \*\*|\*\*\* OBLITERATES \*\*\*|\*\*\* ERADICATES \*\*\*|\*\*\* ANNIHILATES \*\*\*) (.+) \[(\d+)\][!.]\s+\[.+\]$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>player hit</name>
					<script>-- The flying pages MUTILATE [64] Darion!  [ some cuts ]
-- A palace librarian's quick bite MUTILATES [66] Darion's body!  [ some cuts ]

-- An orcish palace servant's wild kick MUTILATES [57] your hand!

-- The boiling water * IMMOLATES * [116] you!


local subject = matches[3]
local amount = tonumber(matches[2])

if (subject == 'you' or subject == 'your') then
  subject = player.name
end

if (group.members and group.members[subject]) then

  local attackData = {
    subject = subject,
    amount = amount,
  }

  raiseEvent(common.events.COMBAT_PLAYER_HIT, attackData)
end



</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#133d0e</mFgColor>
					<mBgColor>#d9f413</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>\S+\s+\[(\d+)\]\s+(\w+?)['.! ]</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>sleep tracking</name>
					<script>-- Mohoonay casts sleep.
-- An ogre miner looks drowsy but quickly shrugs it off.

-- An ogre miner drops to the ground asleep.

-- A gnomish captain slips deeper into slumber.

-- Mohoonay casts sleep.
-- An ogre miner looks incredibly tired!
-- An ogre miner drops to the ground asleep.

if (combat.type and combat.type == 'spell' and combat.spell == 'sleep' and group.members[combat.dealer]) then

  local attackData = {
    subject = combat.dealer,
    damageType = combat.type,
    move = 'sleep - ' .. matches[3],
    mob = matches[2],
    damage = 0
  }

  combat.type = ''
    
  raiseEvent(common.events.COMBAT_ATTACK, attackData)

end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(.*) looks drowsy but quickly (shrugs) it off\.$</string>
						<string>^(.*) drops .* (asleep)\.$</string>
						<string>^(.*) slips (deeper) into slumber\.$</string>
						<string>^()(Nothing) happens\.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>improve-things</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>improve ice shie</name>
					<script>improves.improveLeech('ice shield')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>The ice crystals whirling around you stop and fall to the ground.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>improve displace</name>
					<script>improves.improveLeech('displace')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You are no longer displaced.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>improve ion shield</name>
					<script>improves.improveLeech('ion shield')
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Your shield of electricity sparks once and fades away.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>imp haste</name>
					<script>improves.improveLeech('haste')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Your movements slow and the world returns to normal speed.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>invulnerability</name>
					<script>improves.improveLeech('invulnerability')
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You feel more vulnerable to injury.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>mysic shield</name>
					<script>improves.improveLeech('mystic shield')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Your outline fades.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>hypermetabolism</name>
					<script>improves.improveLeech('hypermetabolism')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Your heart-rate decreases as your body loses energy.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>attacks (non casting)</name>
					<script>send(improves.getImproveSpell())</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Your (pierce|thrust|gore|stab|swipe|smash|swing|jab|kick)</string>
						<string>^You (miss|swing)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>ogre strength</name>
					<script>improves.improveLeech('ogre strength')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You feel yourself returning to normal strength.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>float</name>
					<script>improves.improveLeech('float')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You feel subject to gravity once more.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
		</TriggerGroup>
	</TriggerPackage>
	<TimerPackage>
		<Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>dont' time out!</name>
			<script>send('\n', false)</script>
			<command></command>
			<packageName></packageName>
			<time>00:01:00.000</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>stay hydrated</name>
			<script>send('drink soup')</script>
			<command></command>
			<packageName></packageName>
			<time>00:01:15.000</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>improve ticker</name>
			<script>cecho('\n&lt;white&gt;Improve - halftick\n')
improves.castSpell()
send('drink soup')</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:35.000</time>
		</Timer>
	</TimerPackage>
	<AliasPackage>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>power leveling</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>plev install</name>
				<script>-- backup your profile before we destroy it...
saveProfile()

-- uninstall the generic mapper
uninstallPackage("generic_mapper")

njs50plev = njs50plev or {}

njs50plev.finishInstall = function()

  common.initPlayer()

  tempTimer(2, function()

		saveGearSet('default')

    send('color columns 150')
    send('color lines 150')
    expandAlias("setOption Auto.Assist true")
    expandAlias("setOption Numeric true")
    expandAlias("setOption Numerical.Damage true")
    expandAlias("setOption Auto.Assist true")
    expandAlias("setOption Join.Fight true")
    expandAlias("setOption Show.Language false")
    send('opt autoscan 3')
    send('opt autoloot 3')
    send('opt room.info 1')


    -- set prompt

    send("prompt ?p' -- MORE -- '&lt;%f?f|@R%hhp@n @G%ee@n @B?m'[%mmv]'!m'%vmv'@n %gwm %xxp?l' %llhp' %d?b' %c'&gt;")

    -- setup aliases
    send('alias *ef eat food &amp; eat food &amp; drop all.food &amp; get 4*food')
    send('alias *dw drink ' .. player.vessel)
  end)

  tempTimer(5, function()
    cecho("\n\n&lt;green&gt;INSTALL: &lt;white&gt;Install complete?! - it might be a good idea to restart mudlet\n\n\n")
  end)

 end


-- download and install latest tfe mapper
local URL = "https://raw.githubusercontent.com/njs50/tfe-mapper/master/tfe-mapper.xml"
common.onNextEvent("sysDownloadDone", function (_, f)
  if not f:find("tfe-mapper", 1, true) then
    return
  end
  uninstallPackage("tfe-mapper")
  tempTimer(2, function()
    installPackage(f)
    os.remove(f)
    cecho("&lt;lime_green&gt;Package installed!\n")

    -- install map
    -- download and install latest tfe mapper
      local URL = "https://raw.githubusercontent.com/njs50/njs50-plev/master/njs50-map.dat"
      common.onNextEvent("sysDownloadDone", function (_, f)
        if not f:find("njs50-map", 1, true) then
          return
        end
        local loadOK = loadMap(f)
        if not loadOK then
         cecho("&lt;red&gt;INSTALL: &lt;white&gt;Couldn't load - was the mapper open? :(\n")
        else
          cecho("&lt;green&gt;INSTALL: &lt;white&gt;Loaded fine!\n")
        end
        os.remove(f)

        -- install dark theme
        local downloaded_package = function(a,b)
          if not b:find("DarkTheme",1,true)then return end
          installPackage(b)
          os.remove(b)

          njs50plev.finishInstall()

        end

        common.onNextEvent("sysDownloadDone", downloaded_package)

        downloadFile(getMudletHomeDir().."/DarkTheme.mpackage","https://forums.mudlet.org/download/file.php?id=1783&amp;sid=fb6b2766fa87fccdb1acffcd8cc9cf91")

      end)
      downloadFile(getMudletHomeDir()..(URL:ends("dat") and "/njs50-map.dat"), URL)
  end)

end)
downloadFile(getMudletHomeDir()..(URL:ends("xml") and "/tfe-mapper.xml" or "/tfe-mapper.zip"), URL)


</script>
				<command></command>
				<packageName></packageName>
				<regex>^plev install$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>plev update</name>
				<script>-- backup your profile before we destroy it...
saveProfile()

-- reinstall njs50-plev package
local URL = "https://raw.githubusercontent.com/njs50/njs50-plev/master/njs50-plev.xml"

common.onNextEvent("sysDownloadDone", function (_, f)
  if not f:find("njs50-plev", 1, true) then return end
  uninstallPackage("njs50-plev")
  tempTimer(2, function()
    installPackage(f)
    os.remove(f)
    cecho("&lt;lime_green&gt;njs50-plev updated!\n")
  end)
end)

downloadFile(getMudletHomeDir()..(URL:ends("xml") and "/njs50-plev.xml" or "/njs50-plev.zip"), URL)</script>
				<command></command>
				<packageName></packageName>
				<regex>^plev update$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>set optiion</name>
				<script>local option = matches[2]
local desiredVal = matches[3]


local kilTempTimedTrig = common.timedTempTrigger(1, 2, '^' .. option .. [[ set to (\S+)\.$]] , function()

  if (matches[2] ~= desiredVal) then
    cecho(' &lt;orange&gt;&lt;--- incorrect option value\n')
    send('opt ' .. option)
  else
    cecho(' &lt;green&gt;&lt;--- correct option value\n')
  end

end)

send('opt ' .. option)</script>
				<command></command>
				<packageName></packageName>
				<regex>^setOption (\S+) (true|false)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>plev commands</name>
				<script>
local returnModes = {before = true, after = true, with = true}

local damState = {
 ['perfect health'] = 1,
 ['slightly scratched'] = 0.95,
 ['few bruises'] = 0.85,
 ['some cuts'] = 0.75,
 ['several wounds'] = 0.65,
 ['badly wounded'] = 0.55,
 ['many nasty wounds'] = 0.45,
 ['bleeding freely'] = 0.35,
 ['covered in blood'] = 0.25,
 ['leaking guts'] = 0.15,
 ['mostly dead'] = 0.1,
 ['stunned'] = 0,
 ['incapacitated'] = 0,
 ['mortally wounded'] = 0,
 ['DEAD!'] = 0
}


local commands = {

  stop = function ()
    disableTrigger('sleep-murder')
    send('gt powerleveling is disabled')
  end,

  start = function ()
    enableTrigger('sleep-murder')
    send('gt powerleveling is enabled')
  end,

  ['dance-threshold'] = function ()

    player.dance_threshold = player.dance_threshold or damState['bleeding freely']

    local newState

    if (matches[3]:match([[^%d+$]])) then
      newState = tonumber(matches[3]) / 100
    elseif(damState[matches[3]] ~= nil) then
      newState = damState[matches[3]]
    else
      cecho('\n&lt;red&gt;njs50-plev: &lt;white&gt;unknwon damage state, use 0-100 or a string from help damage\n')
      return
    end

    player.dance_threshold = newState

    send('gt will now start the dance when a mob reaches ' .. tostring(player.dance_threshold * 100) .. '% hp')
    cecho('\n&lt;green&gt;njs50-plev: &lt;white&gt;current dancing once mob health reaches ' .. tostring(player.dance_threshold * 100) .. '%\n')

  end,

  ['dance-return'] = function ()

    if ( returnModes[matches[3]] ) then
      player.danceReturnMode = matches[3]
      cecho('\n&lt;green&gt;njs50-plev: &lt;white&gt;will send tank return command ' .. player.danceReturnMode .. ' kill command\n')
    else
      cecho('\n&lt;red&gt;njs50-plev: &lt;white&gt;unknwon return mode, valid modes are: before, with and after\n')
    end

  end,

}


commands[matches[2]]()</script>
				<command></command>
				<packageName></packageName>
				<regex>^plev (start|stop|dance-threshold|dance-return) ?(.*)$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>drop junk</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>sort halfling junk</name>
				<script>send('drop all.brown.pants, all.studd.leather, all.homespun.blue, all.bron.ham, all.steel.short, all.ragg.pant, all.simp.mug' ..
	 	'leath.journ, all.wood.shield, all.high.hard, all.wood.shield, all.leather.armor, all.wood.spear, all.wolf.skin')

send('drop all.banded.armor, all.cloth.robe, all.maple.staff, all.bronze.scale, all.meat.cleaver, all.iron.two-, all.bron.two-,' ..
		 'all.decrep.armor, all.steel.two-, all.hatchet, all.mug.simple, all.old.boot, all.leather.journal, short.ash.staff')

send('label saddleb as deadHalfies &amp; open deadH &amp; get all deadH &amp; drop deadH &amp; get all.leather.cord')

send('give all.silver.coin, all.copper.coin to mojune')</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort halfling junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>sort yeti junk</name>
				<script>send('drop all.yeti.foot')
		</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort yeti junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>^sort stonies junk$</name>
				<script>send('give all.thimb, all.rag, all.coin, all.yeti.pillow ' .. group.leader)
send('drop all.thick.deer.skin &amp; drop all.frying &amp; drop all.apron &amp; drop all.dress &amp; drop all.slab &amp; drop all.berries')</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort stonies junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>drop yeti junk</name>
				<script>send('drop all.yeti.foot,all.thick.yeti.hide,all.food &amp; get 5*food')

local dropJunk = "drop all.ringm,all.furred.steel.shield,all.hard leather,"..
	'all.low.boot,all.steel.scim,all.great.scim,all.furr.cloak,' ..
	"all.jag.longs,all.wide.belt,all.spik.helm,all.yeti.foot,all.studded.leather," ..
  "all.iron.longs"

send(dropJunk)</script>
				<command></command>
				<packageName></packageName>
				<regex>^drop yeti junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>drop durkang junk</name>
				<script>send('drop all.stud.leath,all.low.boot,all.horn.bronze,all.steel.ringm,' .. 
     'all.bronze.shorts,all.iron.shorts, all.steel.shorts,all.shatt.bottle,' ..
     'all.hard.leather,all.torch,all.silver.wristband,all.pickaxe, black.robe,' ..
     'dusty.ledger,all.huge.cleaver,ringed,all.troll.flesh')
</script>
				<command></command>
				<packageName></packageName>
				<regex>^drop durkang junk$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>Debug</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>show triggers</name>
				<script>displayTempTriggers()</script>
				<command></command>
				<packageName></packageName>
				<regex>^triggers$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>show timers</name>
				<script>displayTempTimers()</script>
				<command></command>
				<packageName></packageName>
				<regex>^timers$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>show event handlers</name>
				<script>displayEventHandlers()</script>
				<command></command>
				<packageName></packageName>
				<regex>^events$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>killAll</name>
				<script>display(tempTimers)
display(tempTriggers)

for id, val in pairs(tempTimers) do
	killTimer(id)
end

for id, val in pairs(tempTriggers) do
	killTrigger(id)
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^killAll$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>kill event</name>
				<script>killAnonymousEventHandler(tonumber(matches[2]))</script>
				<command></command>
				<packageName></packageName>
				<regex>^killEvent (\d+)$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>damage meter</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>dm</name>
				<script>local cmd = matches[2]
local param = matches[3]


local commands = {
	
	start = damageMeter.start,
	
	stop = damageMeter.stop,

    
	show = function (target)
   damageMeter.report(target)
	end,
  

}

local fn = commands[cmd]

if (fn) then
	fn(param)
else
  cecho('\n\n&lt;red&gt;DM: &lt;white&gt;error - unknown command ' .. cmd .. '\n')
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^dm (\S+) ?(.*)$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>gear swap</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>gear</name>
				<script>equipSet(matches[2])
</script>
				<command></command>
				<packageName></packageName>
				<regex>^gear (.*)</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>gear-partial</name>
				<script>equipPartial(matches[3])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(gear-partial|equip your) (.*)</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>gear-reset</name>
				<script>resetGear()</script>
				<command></command>
				<packageName></packageName>
				<regex>^(gear-reset|put your usual gear back on)</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>gear-save</name>
				<script>saveGearSet(matches[2])
</script>
				<command></command>
				<packageName></packageName>
				<regex>^gear-save (.*)</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>misc</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>display gates</name>
				<script>cecho('\n&lt;green&gt;Brithbarad &lt;white&gt;&gt; Outback')
cecho('\n&lt;green&gt;Chiiron &lt;white&gt;&gt; Wayward')
cecho('\n&lt;green&gt;Medienne &lt;white&gt;&gt; Knight')
cecho('\n&lt;green&gt;Kha-da &lt;white&gt;&gt; Cairn')
cecho('\n&lt;green&gt;Voaleth &lt;white&gt;&gt; Whisper')
cecho('\n&lt;green&gt;Vaasa &lt;white&gt;&gt; Blade')
cecho('\n&lt;green&gt;Pennan &lt;white&gt;&gt; Hollow')
cecho('\n&lt;green&gt;Narak &lt;white&gt;&gt; Corsair')
cecho('\n&lt;green&gt;Sos-kul &lt;white&gt;&gt; Fire')
cecho('\n&lt;green&gt;Orlumber &lt;white&gt;&gt; Midnight')
cecho('\n&lt;green&gt;Brembledon &lt;white&gt;&gt; Amber')</script>
				<command></command>
				<packageName></packageName>
				<regex>^gates$</regex>
			</Alias>
		</AliasGroup>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<Script isActive="yes" isFolder="no">
			<name>common</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

common = common or {}
player = player or {}
roomInfo = roomInfo or {}
group = group or {
	combat = false
}


common.events = {
	PARSED_PROMPT = 'COMMON::parsed_prompt',
	PARSED_EXITS = 'COMMON::parsed_room_exits',
	PARSED_SCORE = 'COMMON::parsed_score_page',
	PARSED_GROUP = 'COMMON::parsed_group_status',
	PARSED_AFFECTS = 'COMMON::parsed_player_affects',
	PARSED_INVENTORY = 'COMMON:parsed_inventory_contents',
	PARSED_PREPARED = 'COMMON:parsed_prepared_spells',
	PARSED_EQUIPMENT = 'COMMON:parsed_equipment',
	CHANGED_EQUIPMENT = 'COMMON:changed_equipment',
	MOVE_DETECTED = 'COMMON::move_detected',
	ROOM_CHANGED = 'COMMON::room_changed',
	COMBAT_ENDED = 'COMMON::combat_ended',
	COMBAT_STARTED = 'COMMON::combat_started',
  COMBAT_ATTACK = 'COMMON:: combat_attack',
  COMBAT_PLAYER_HIT = 'COMMON:: combat_player_hit',
	WALK_DONE = 'COMMON::speedwalk_completed',
	ROOM_CLEAR = 'COMMON::current_room_is_clear',
	PARRY_STATE_CHANGE = 'COMMON::parry_state_change',
}

common.tableHasValue =  function (tab, val)
  for index, value in ipairs(tab) do
    if tab[index] == val then
    	return true
    end
  end
  return false
end


common.tfeItemListAdd = function (list, item)

	local idx = 0
	local match = nil

	-- see if this value is already in the list
	for index, value in ipairs(list) do
		match = rex.match(value, '^(\\d+)?\\*?' .. item .. '$')
    if match ~= nil then
    	idx = index
			break
    end
  end

	--  if we found a match, see how many of this item are already in the list
	if (idx &gt; 0) then
		local count = 1
		if (match ~= false) then
			count = tonumber(match)
		end
		count = count + 1
		list[idx] = tostring(count) .. '*' .. item
	else -- this is a new item
		table.insert(list, item)
	end

	return list
end

common.reverseList = function(list)

	local i = 1
	local j = #list

	while i &lt; j do
		list[i], list[j] = list[j], list[i]
		i = i + 1
		j = j - 1
	end

	return list

end


common.setParryState = function (state, reason, callback, permanent)

	local cb = callback

	player.parryQueue = player.parryQueue or 0

  -- if we have queued parry changes defer until they have all happened
  if (player.parryQueue &gt; 0) then
    common.onNextEvent(common.events.PARRY_STATE_CHANGE, function (evt, args)
  		  common.setParryState(state, reason, callback, permanent)
    end)
    return
  end

	local currentState = player.parry

	if (player.parryRevertTimer) then
		killTimer(player.parryRevertTimer)
		player.parryRevertTimer = nil
	end


	-- if we need to swap opt parry
	if (currentState ~= state) then

  	-- if we are turning parry on, make sure we have a plan to turn it off again
  	if (not permanent and state) then
  		player.parryRevertTimer = tempTimer(15, function ()
  			if (player.parry) then
  				common.setParryState(false, 'opt parry has been on too long!')
  			end
  		end)
  	end

  	cecho('\n&lt;green&gt;PARRY: &lt;white&gt;setting  - ' .. tostring(state) .. ' - ' .. reason or '?' .. '\n')
  	send('opt parry')
		player.parryQueue = player.parryQueue + 1
    cecho('&lt;yellow&gt; &lt;-- parry queue -- (' .. player.parryQueue .. ')')

  	common.onNextEvent(common.events.PARRY_STATE_CHANGE, function (evt, args)
      cecho('\n&lt;green&gt;PARRY: &lt;white&gt;state change happened!\n')
  		if (cb) then cb() end
    end)

	else
		cecho('\n&lt;green&gt;PARRY: &lt;white&gt;setting  - ' .. tostring(state) .. ' - skipping as no change needed\n')
		if (cb) then cb() end
	end

end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>player.config</name>
			<packageName></packageName>
			<script>common = common or {}
player = player or {}
player.scripts = player.scripts or {}


player.defaultConfig = function ()

	player.bag = 'backpack.holding'
	player.pack = 'black.silk.bag'
  player.vessel = 'leather.waterskin'
  player.hasFoodBasket = false
	player.caster = false
	player.gearSet = 'default'
  player.autoAttack = function(target)
    send('+kill ' .. target)  
  end

end

common.wm = common.wm or {}
common.wm.gridEntries = common.wm.gridEntries or {};

common.resetWindows = function(event, x, y)

  if (common.topContainer) then
    local tch = common.topContainer.get_height()

    if (tch ~= common.wm.tc_height) then
          -- setBorderTop(tch)
      common.wm.tc_height = tch

      if (common.resizeTimer) then killTimer(common.resizeTimer) end

      common.resizeTimer = tempTimer(0.1, function()
        setBorderTop(common.wm.tc_height)
        setBorderLeft(200)
        common.resizeTimer = nil
      end)

    end
  else

    -- player is not yet init. resize once windows are setup
    tempTimer(1, function()
      common.resetWindows(event, x, y);
    end)
  end

end


if (common.resizeEventWatcher) then
  killAnonymousEventHandler(common.resizeEventWatcher)
  common.resizeEventWatcher = nil
end

common.resizeEventWatcher = registerAnonymousEventHandler("sysWindowResizeEvent", common.resetWindows)



common.addGridEntry = function()

  local idx = tostring(#common.wm.gridEntries)

	local thisGrid = Geyser.Container:new({
    name = "grid_entry_" .. idx,    -- give it a unique name here
		x=0,
		y= #common.wm.gridEntries * 100,
    width = "100%",
		height=100,
  }, common.leftContainer)


  local hpbar = Geyser.Gauge:new({
    name="hpbar-" .. idx,
    x=5, y=10,
    width=190, height=40,
  }, thisGrid)

  hpbar.front:setStyleSheet([[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #f04141, stop: 0.1 #ef2929, stop: 0.49 #cc0000, stop: 0.75 #a40000, stop: 1 #cc0000);
    border-top: 1px black solid;
    border-left: 1px black solid;
    border-bottom: 1px black solid;
    border-radius: 3;
    padding: 3px;
  ]])
  hpbar.back:setStyleSheet([[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #bd3333, stop: 0.1 #bd2020, stop: 0.49 #990000, stop: 0.75 #700000, stop: 1 #990000);
    border-radius: 3;
    padding: 3px;
  ]])

  hpbar.text:setStyleSheet([[
   qproperty-alignment: 'AlignCenter';
  ]])

  hpbar.text:setFontSize(20)

  local manabar = Geyser.Gauge:new({
    name="mpbar-" .. idx,
    x=5, y=50,
    width=190, height=30,
  }, thisGrid)


  manabar.front:setStyleSheet([[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #4141f0, stop: 0.1 #2929ef, stop: 0.49 #0000cc, stop: 0.75 #0000a4, stop: 1 #0000cc);
    border-top: 1px black solid;
    border-left: 1px black solid;
    border-bottom: 1px black solid;
    border-radius: 3;
    padding: 3px;
  ]])
  manabar.back:setStyleSheet([[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #3333bd, stop: 0.1 #2020bd, stop: 0.49 #000099, stop: 0.75 #000070, stop: 1 #000099);
    border-radius: 3;
    padding: 3px;
  ]])
  manabar.text:setStyleSheet([[
   qproperty-alignment: 'AlignCenter';
  ]])

  manabar.text:setFontSize(20)

  local movebar = Geyser.Gauge:new({
    name="mbbar-" .. idx,
    x=5, y=80,
    width=190, height=20,
  }, thisGrid)


  movebar.front:setStyleSheet([[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #41f041, stop: 0.1 #29ef29, stop: 0.49 #00cc00, stop: 0.75 #00a400, stop: 1 #00cc00);
    border-top: 1px black solid;
    border-left: 1px black solid;
    border-bottom: 1px black solid;
    border-radius: 3;
    padding: 3px;
  ]])
  movebar.back:setStyleSheet([[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #33bd33, stop: 0.1 #20bd20, stop: 0.49 #009900, stop: 0.75 #007000, stop: 1 #009900);
    border-radius: 3;
    padding: 3px;
  ]])
  movebar.text:setStyleSheet([[
   qproperty-alignment: 'AlignCenter';
  ]])

  movebar.text:setFontSize(14)

  table.insert(common.wm.gridEntries, {
    container = thisGrid,
    hpbar = hpbar,
    manabar = manabar,
    movebar = movebar
  })

end


common.updateGrid = function ()
 
 if (common.topContainer) then
    -- make sure we have one grid item per group member at least
    if (#common.wm.gridEntries &lt; group.memberCount) then
      for i = #common.wm.gridEntries, group.memberCount -1 do
        common.addGridEntry();
      end
    end
  
    -- hide any extra grid items
    if (#common.wm.gridEntries &gt; group.memberCount) then
      for i = group.memberCount + 1, #common.wm.gridEntries do
        common.wm.gridEntries[i].container:hide()
      end
    end  
      
    for idx, name in pairs(table.keys(group.members)) do
      -- display(idx,val)
      local data = group[name]
      local grid = common.wm.gridEntries[idx]
      
      grid.container:show()
      
      -- display(data)
      
      grid.hpbar:setValue(data.hp,data.hp_max, name .. ' : ' .. tostring(data.hp) .. 'hp')
      grid.manabar:setValue(data.mp, data.mp_max, tostring(data.mp) .. '/' .. tostring(data.mp_max))
      grid.movebar:setValue(math.min(data.moves, data.moves_max), data.moves_max)
    end 
  end
end



if (common.wm.groupWatcher) then
  killAnonymousEventHandler(common.wm.groupWatcher)
  common.wm.groupWatcher = nil
end


common.wm.groupWatcher = registerAnonymousEventHandler(common.events.PARSED_GROUP, common.updateGrid)




common.initPlayer = function ()

	echo('\n\nINITIAL STATUS CHECK\n\n')
  
  -- rest to defaults for init
  
	player.name = gmcp.Char.Score.name


	if not (player.scripts and player.scripts[player.name]) then
    echo('\nSetting  default player script for ' .. player.name .. '!\n')
    player.scripts[player.name] = player.defaultConfig
	end

		echo('\nRunning player script for ' .. player.name .. '!\n')
		player.scripts[player.name]()

	if (not common.topContainer) then

		-- init windows
    common.topContainer = Geyser.Container:new({
      name = "top_container",    -- give it a unique name here
			x=0,
			y=0,
      width = "100%",
			height="25%",
    })

    common.leftContainer = Geyser.Container:new({
      name = "left_container",    -- give it a unique name here
			x=0,
			y="25%",
      width = 200,
			height="75%",
    })

		common.mapContainer = Geyser.Container:new({
      name = "map_container",    -- give it a unique name here
			x=0,
			y=0,
      width = "40%",
			height="100%",
    }, common.topContainer) --

		common.chatContainer = Geyser.Container:new({
      name = "chat_container",    -- give it a unique name here
			x="40%",
			y=0,
      width = "60%",
			height="100%",
    }, common.topContainer)

				-- init windows
    common.mapper = Geyser.Mapper:new({
      name = "geyser_map",    -- give it a unique name here
			x=0,
			y=0,
      width = "100%",
			height="100%",
    }, common.mapContainer)

    common.chatConsole = Geyser.MiniConsole:new({
      name = "geyser_chat",    -- give it a unique name here
			x=0,
			y=0,
      width = "100%",
			height="100%",
			autoWrap = true,
      color = "black",
      scrollBar = true,
      fontSize = 14,
    }, common.chatContainer)

	end

  echo('\n\nloading gear sets. if it fails you should do luaSaveGearSet("default") to save a default set\n\n')
  loadSavedGearSets()


	send('score &amp; eq &amp; group &amp; inv &amp; typo &amp; prep')

end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>player.config.example.template</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

player = player or {}
player.scripts = player.scripts or {}

-- nb: must match exactly. i.e don't forget the capital letter
player.scripts.YOUR_NAME_HERE = function ()

	player.bag = 'bag.holding'
	player.pack = 'backpack.holding'
	player.reagentBag = 'bag.reagents'
	player.gearSet = 'default'
	player.vessel = 'leather.waterskin'
	player.caster = false
	player.hasFoodBasket = false
  player.useBerserk = false
  
  player.autoAttack = function(target)
    send('+kill ' .. target) -- .. ' &amp; berserk &amp; queue stand'  
  end

end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>swap</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

player = player or {}

player.swapItems = player.swapItems or {}
player.gearSets = player.gearSets or {}

common.conditions = {
  worthless = 0,
  damaged = 1,
  ["very worn"] = 2,
  worn = 3,
  ["very scratched"] = 4,
  scratched = 5,
  reasonable = 6,
  good = 7,
  ["very good"] = 8,
  excellent = 9,
  perfect = 10
}

function getLowestGearCondition (cb)
  common.onNextEvent(common.events.PARSED_EQUIPMENT, function()
    -- lua player.gear["right hand"].base.condition
    local lowestCondition = 11
    local lowestItem
    
    for slot, layers in pairs(player.gear) do
      for layer, item in pairs(layers) do
        if (common.conditions[item.condition] == nil) then
          cecho('\n\n&lt;red&gt;[GEAR]: &lt;white&gt; unknown gear condition: ' .. item.condition .. '\n\n')
        else
          if (common.conditions[item.condition] &lt; lowestCondition) then
            lowestCondition = common.conditions[item.condition]
            lowestItem = item
          end
        end
      end
    end
    -- display(lowestItem)
    -- display(player.gear)
    cb(lowestCondition)
  end)
  send('eq')
end


function equipSet(set, callback)
  if (player.gearSets[set]) then

  	player.gearSet = set
  	send('gs', true)
  	equipGearSet(set, function()
  		send('ps', false)
			if callback then callback() end
    end)

  else
  	cecho('\n&lt;red&gt;GEAR: &lt;white&gt;No set found matching: "' .. set .. '"\n')
  end
end

function equipPartial(set, callback)
  if (player.gearSets[set]) then
  	cecho('\n&lt;green&gt;GEAR: &lt;white&gt;Equip partial set: "' .. set .. '"\n')
  	send('gs', true)
  	equipGearSet(set, function()
  		send('ps', true)
			if callback then callback() end
    end, true)

  else
  	cecho('\n&lt;red&gt;GEAR: &lt;white&gt;No set found matching: "' .. set .. '"\n')
  end
end

function resetGear(callback)


  if (player.gearSets[player.gearSet]) then

  	cecho('\n&lt;green&gt;GEAR: &lt;white&gt;resetting gear to set: "' .. player.gearSet .. '"\n')
  	send('gs', true)

		equipGearSet(player.gearSet, function()
  		send('ps', true)
			if callback then callback() end
    end)

  else
  	cecho('\n&lt;red&gt;GEAR: &lt;white&gt;No set found matching: "' .. player.gearSet .. '"\n')
  end
end



function saveGearSet (name)

	common.onNextEvent(common.events.PARSED_EQUIPMENT, function()
  	table.save(getMudletHomeDir() .. "/gearsets.backup.dat", player.gearSets)
  	player.gearSets[name] = player.gear
  	table.save(getMudletHomeDir() .. "/gearsets.dat", player.gearSets)
	end)
	send('eq', false)

end

function loadSavedGearSets ()
	player.gearSets = {}

	local gearFile = getMudletHomeDir() .. "/gearsets.dat"

	local is_file = io.open(gearFile)

	if (is_file ~= nil) then
		table.load(gearFile, player.gearSets)
	end

end


function loadGearSetBackup ()
	player.gearSets = {}
	table.load(getMudletHomeDir() .. "/gearsets.backup.dat", player.gearSets)
end

-- functions below here are probably internal...

function equipGearSet (name, callback, partial)


	cecho('\n&lt;green&gt;Outfit: &lt;white&gt;equip gear set: ' .. name)

  if(player.equippingSet) then
		cecho('\n&lt;red&gt;Outfit: &lt;white&gt;waiting for prev gear change to complete before equiping ' .. name)

  	common.onNextEvent(common.events.CHANGED_EQUIPMENT, function()
			equipGearSet(name, callback, partial)
  	end)

    send('eq')

    timedTempTrigger(0.5, 1, '^You cannot do that while sleeping\.$', function ()
    	send('stand &amp; eq')
    end)

		return
	end


	player.equippingSet = true


	common.onNextEvent(common.events.PARSED_EQUIPMENT, function()

  	-- echo('\ncurrent gear established...\n')

		local newSet = player.gearSets[name]

		if (newSet == nil) then

			cecho('&lt;red&gt;Outfit Error: &lt;white&gt;set does not exist')
			if callback then callback() end

		else

			-- reset current swap list
			player.swapItems = {}

  		-- remove any items that have empty slots in new set
			if (not partial) then
    	  for slot, layers in pairs(player.gear) do
          for layer, item in pairs(layers) do
    				if (not (newSet[slot] and newSet[slot][layer])) then
  						-- echo('\nneed to remove ' .. item.item)
  						swapItems(item.item, '', slot, layer)
  					end
    			end
        end
			end

			-- swap any items different in the new set
			for slot, layers in pairs(newSet) do
				if (type(layers) == 'table') then -- in case junk like parsed gets in the data again
          for layer, item in pairs(layers) do
  					-- add any items in a layer that doesn't exist in current set
    				if (not (player.gear[slot] and player.gear[slot][layer])) then
  						-- echo('\nneed to add new slot ' .. item.item)
  						swapItems('', item.item, slot, layer)
  					elseif (player.gear[slot][layer].item ~= item.item)then
  						swapItems(player.gear[slot][layer].item, item.item, slot, layer)
  					end
    			end
				else
					-- not sure how parsing is still in there (too lazy to investigate atm)
					if (slot ~= 'parsing') then

						cecho('\n&lt;red&gt;GEAR ERROR: &lt;white&gt;invalid data!!! slot: ' .. slot)
					end
				end
      end


						-- must remove neck.over to change neck.base
			if (player.gear.neck and player.gear.neck.over and player.swapItems.neck and
				(player.swapItems.neck.base and not player.swapItems.neck.over)) then
				echo('\n\nADDING neck.over!!!\n\n')
				swapItems(player.gear.neck.over.item, player.gear.neck.over.item, 'neck', 'over')
			end


			-- must remove body.base to change body.under
			if (player.gear.body and player.gear.body.base and player.swapItems.body and
				(player.swapItems.body.under and not player.swapItems.body.base)) then
				-- echo('\n\nADDING body.base!!!\n\n')
				swapItems(player.gear.body.base.item, player.gear.body.base.item, 'body', 'base')
			end

			-- if changing any waist item then keyring needs to be removed/replaced
			if (player.gear.waist) then

				-- only need to remove keyring
				if (player.swapItems.waist and player.gear.waist.over and player.gear.waist.over.item:match('keyring') and not player.swapItems.waist.over) then
  				-- echo('\n\nADDING KEYRINGS!!!\n\n')
  				swapItems(player.gear.waist.over.item, player.gear.waist.over.item, 'waist', 'over')
				end

				if (player.swapItems.waist and player.gear.waist.top and player.gear.waist.top.item:match('keyring') and not player.swapItems.waist.top) then
  				-- echo('\n\nADDING KEYRINGS!!!\n\n')
  				swapItems(player.gear.waist.top.item, player.gear.waist.top.item, 'waist', 'top')
				end

			end

			-- make sure we aren't just switching left/right things

			local removeRedundantSwap = function (slot, layer)
					if (player.swapItems["left " .. slot] and player.swapItems["left " .. slot][layer] and
						player.swapItems["right " .. slot] and player.swapItems["right " .. slot][layer] and
						(player.swapItems["left " .. slot][layer].from == player.swapItems["right " .. slot][layer].to) and
  					(player.swapItems["left " .. slot][layer].to == player.swapItems["right " .. slot][layer].from)) then
  					-- remove redundant swap
  					cecho('\n&lt;green&gt;GEAR SWAP: &lt;white&gt;removed redundant swap (left/right ' .. slot .. '.' .. layer .. ')')
  					player.swapItems["left " .. slot][layer] = nil
  					player.swapItems["right " .. slot][layer] = nil
  			end
			end


			removeRedundantSwap('hand finger', 'over')
			removeRedundantSwap('hand finger', 'base')
			removeRedundantSwap('hand finger', 'top')
			removeRedundantSwap('wrist', 'base')
			removeRedundantSwap('wrist', 'over')


			local cb = function ()
				callback()
			end

			-- lets do it...
			performSwap(cb)

		end -- end check if this was a valid set

  end)

	send('eq', false)

end


function swapItems (to, from, slot, layer)

	-- cecho('&lt;green&gt;swap: &lt;white&gt;swap to ' .. to .. ' from ' .. from .. '\n')

	if (slot == nil) then
		cecho('&lt;red&gt;ERROR: &lt;white&gt;no slot provided on item swap ' .. to .. ' to ' .. from .. '\n')
	end

	local swap = {from=common.itemShorten(to), to=common.itemShorten(from)}

	player.swapItems[slot] = player.swapItems[slot] or {}

	if (player.swapItems[slot][layer]) then

		if (player.swapItems[slot][layer].to == swap.from) then
			swap.from = player.swapItems[slot][layer].from
		else
			cecho('Error: invalid item switch of items in slot ' .. slot)
			display(player.swapItems[slot][layer])
			display(swap)
		end

	end

	player.swapItems[slot][layer] = swap

end


function swapCommands (removeList, wearList)

	if(#wearList &gt; 0) then
		send('get ' .. table.concat(wearList, ',') .. ' from ' .. player.bag)
	end

	if(#removeList &gt; 0) then
		send('remove ' .. table.concat(removeList, ','))
	end

	if(#wearList &gt; 0) then
		send('wear ' .. table.concat(wearList, ','))
	end

	if(#removeList &gt; 0) then
		send('put ' .. table.concat(removeList, ',') .. ' in ' .. player.bag)
	end


end


local slots = {
  "right hand",
  "left hand",
  "left hand finger",
  "right hand finger",
  "right wrist",
  "left wrist",
  "head",
  "body",
  "nearby",
  "arms",
  "hands",
  "feet",
  "legs",
  "waist",
  "neck"
}


function performSwap (callback)

	local cb = callback

	local removeList = {}
	local wearList = {}

	local removeLength = 0
	local wearLength = 0

	local idx

	local layers = { 'bottom', 'under', 'base', 'over', 'top' }

  for k, slot in pairs(slots) do

    if (player.swapItems[slot]) then

      items = player.swapItems[slot]

  		for k, layer in pairs(layers) do
  		-- for layer, swap in pairs(items) do
  			local swap = items[layer]

  			if (items[layer]) then

    			if string.len(swap.from) &gt; 0 then
    				removeList = common.tfeItemListAdd(removeList, swap.from)
    				-- this is an approximation since if it's already in the list
    				-- we are only actually adding 2 (i.e 2*item)
    				removeLength = removeLength + string.len(swap.from)
    			end

    			if string.len(swap.to) &gt; 0 then

  				  wearList = common.tfeItemListAdd(wearList, swap.to)
    				-- this is an approximation since if it's already in the list
    				-- we are only actually adding 2 (i.e 2*item)
    				wearLength = wearLength + string.len(swap.to)
    			end

  			end -- check if layer is being swapped

  		end -- end layer loop


  		if (wearLength &gt; 150 or removeLength &gt; 150) then
  			-- gotta remove items in the reverse order (i.e top layer first)
  			swapCommands(common.reverseList(removeList), wearList)
  			removeList = {}
  			wearList = {}
  			removeLength = 0
  			wearLength = 0
  		end

  	end -- end slot if
  end -- slot loop

	-- display(wearList)
	-- display(removeList)

	if (wearLength &gt; 0 or removeLength &gt; 0) then
		-- gotta remove items in the reverse order (i.e top layer first)
		swapCommands(common.reverseList(removeList), wearList)
	end

	send('queue group &amp; queue eq', false)

	common.onNextEvent(common.events.PARSED_EQUIPMENT, function()
		player.equippingSet = nil
		if cb then cb() end
		raiseEvent(common.events.CHANGED_EQUIPMENT)
	end)

	player.swapItems = {}

end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>combat</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
combat = combat or {
	active = false,
	mobs = 0,
	clear_timer = nil,
	sleeping_mob = false
}


combat.startTimer = function ()

	if(combat.clear_timer) then
		cecho('&lt;yellow&gt;&lt;-- restarting room cler timer\n')
		combat.clearTimer()
	end

	combat.clear_timer = tempTimer(5, function ()
		-- raiseEvent(common.events.ROOM_CLEAR) -- this will be sent when a scan comes back with 0 targets
		combat.clear_timer = nil
		cecho('&lt;green&gt;&lt;-- CLEAR timer !!! \n')
		if (murder.enabled and not murder.speedwalking and player.position == 'standing') then
			send('queue level &amp; queue scan')
		end
	end, 'combat clear timer')
end

combat.clearTimer = function()
	if (combat.clear_timer) then
		killTimer(combat.clear_timer)
	end
	combat.clear_timer = nil
end

combat.reset = function()
	-- if (murder.enabled and not murder.speedwalking) then
	combat.startTimer()
	-- end
end

combat.extendRoomCheck = function ()

	if (combat.clear_timer) then
		cecho('&lt;green&gt;&lt;-- EXTEND ROOM CLEAR CHECK\n')
		combat.clearTimer()
  	combat.startTimer()
	end

end

combat.start = function()
	
  if (not combat.active) then
    combat.startTime = getEpoch()
		combat.active = true
		cecho(' &lt;white&gt;&lt;-- -=[ COMBAT ]=-')
		raiseEvent(common.events.COMBAT_STARTED)
    combat.clearTimer()
    -- extend the idle scanner if we are farming (should prob be done via an event)
	  murder.idleScanner()
	end

end

combat.finish = function ()
	
  if (combat.active) then
    combat.active = false
  	cecho(' &lt;white&gt; -=[ PEACE ]=-')
  	send('queue level &amp; queue scan')
  	raiseEvent(common.events.COMBAT_ENDED, getEpoch() - combat.startTime)
  	combat.startTimer()
    -- extend the idle scanner if we are farming (should prob be done via an event)
	  murder.idleScanner()  
  end

end


combat.checkScan = function ()

  -- display('checking scan', murder.exits)
  
  if (murder.exits.here == nil or murder.exits.here.targetCount == 0) then
    cecho('&lt;green&gt;&lt;-- CLEAR (scan)!!! \n')
    raiseEvent(common.events.ROOM_CLEAR)
  end

end



if (combat.eventWatcher) then
  killAnonymousEventHandler(combat.eventWatcher)
  combat.eventWatcher = nil
end

combat.eventWatcher = registerAnonymousEventHandler(tfe.events.ROOM_CHANGED, combat.reset)

if (combat.scanWatcher) then
  killAnonymousEventHandler(combat.scanWatcher)
  combat.scanWatcher = nil
end

combat.scanWatcher = registerAnonymousEventHandler(murder.events.SCAN_PROCESSED, combat.checkScan)</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>trigger helpers</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------


common.timedTempTrigger = function (timeout, maxTriggerCount, pattern, callback, failcallback)

	local fcb = failcallback
	local ocb = callback

	local cb = function ()
		fcb = nil;
		if (ocb) then
			ocb()
		end
	end


	local triggerId = tempRegexTrigger(pattern, cb, maxTriggerCount)

	local tempTimerId = tempTimer(timeout, function ()
		-- echo('\n -- killing temp timed trigger\n')
		killTrigger(triggerId)
		if (fcb) then
			fcb()
		end
	end, 'timed temp trigger')

	return {triggerId = triggerId, timerId = tempTimerId}

end

timedTempTrigger = common.timedTempTrigger


common.onNextEvent = function (evt, callback)

	if not evt then

		echo('no event defined!!!')
		error()

	end


	local handlerId = nil
	local cb2 = callback

	local cb = function (evt, args)
		-- kill the event handler now in case the event errors preventing it's destruction
		killAnonymousEventHandler(handlerId)
		-- cecho('\n&lt;blue&gt;self destructing handler: ' .. evt .. ' : ' .. tostring(handlerId) .. '\n')
		cb2(evt, args)
	end

	handlerId = registerAnonymousEventHandler(evt, cb, true)

	-- cecho('\n&lt;green&gt;registering self destruct event: ' .. evt .. ' : ' .. tostring(handlerId) .. '\n')

	return function ()
		-- cecho('\n&lt;orange&gt;destructing handler: ' .. evt .. ' : ' .. tostring(handlerId) .. '\n')
		killAnonymousEventHandler(handlerId)
	end

end

onNextEvent = common.onNextEvent

common.oneRoomExitTrig = function (direction, code)

  local tempTrigId = tempRegexTrigger('^You see no exit to the (' .. direction .. ')\.$', function ()
		code(matches[2])
	end, 1)

  echo(' &lt;- room sepecific trig: ' .. tostring(tempTrigId))

	-- need to dest these as the first room change will be entering the room where we
	-- want to watch for the event
	common.onNextEvent(tfe.events.ROOM_CHANGED, function ()
		-- got to wait for a prompt or else this will trigger on the same event as the first
		common.onNextEvent(common.events.PARSED_PROMPT, function ()
      common.onNextEvent(tfe.events.ROOM_CHANGED, function ()
      	echo('\n ^^ killed room specific trig : '  .. tostring(tempTrigId) .. '\n')
        killTrigger(tempTrigId)
      end)
		end)
	end)

end

oneRoomExitTrig = common.oneRoomExitTrig</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>team</name>
			<packageName></packageName>
			<script>common.includeInRollCalls = {
  Mojune = true,
  Mohoonay = true,
  Myrth = true,
  Grehild = true,
  Darion = true,
  Darius = true,
  Bimgore = true,
	Marial = true,
	Grackle = true,
  Raksha = true,
}

common.groupDo = function (command)
  send('gt time to ' .. command)
  for member in pairs(group.members) do
    if (not common.includeInRollCalls[member]) then
      send('tell ' .. member .. ' do ' .. command)
    end
  end
end


common.comeToMe = function (callback)

  if (group.memberCount == 1) then
    cecho('\n&lt;yellow&gt;COMMON: &lt;white&gt;skipping regroup due to only one party member\n\n')
    callback()
    return
  end


	local mcb = callback
	local roll = common.newRollCall(true)

	tempTimer(2, function ()

		local atTrig

		local preFetchState = mapper.paused

		mapper.paused = true

  	atTrig = tempRegexTrigger([[^.+ tells the group[^:]*: "(\w+) is now at (\d+)"]], function ()
  		if (tostring(tfe.roomInfo.vnum) == matches[3]) then

				roll[matches[2]] = true

				if (common.rollCheck(roll)) then
					mapper.paused = preFetchState
					send('gt all here - moving...')
  				killTrigger(atTrig)
  				mcb()
				end

			else
				send('mutter')
				send('gt ' .. matches[2] .. ' go to ' .. tostring(tfe.roomInfo.vnum))
			end

  	end)

		send('gt meet at ' .. tostring(tfe.roomInfo.vnum))


	end, 'comeToMe')

end

common.collectFollowers = function (callback)

	if (not murder.paused) then
		murder.pause()
	end


	local roll = common.newRollCall(true)

	send('stand &amp; remove blanket')

	local outStandingResponses = group.memberCount - 1

	local onAllResponded = function ()

  	for key, value in pairs(roll) do
  		if (value ~= true) then
  			cecho('\n\n&lt;red&gt;MURDER: &lt;white&gt;' .. key .. ' is lost at ' .. tostring(value) .. '\n')
				tfe.gotoRoom(value, function()
          tempTimer(3, function()
					 common.collectFollowers(callback)
           end, 'finding next follower?')
				end)
				return
  		end
  	end

		-- if we got to here then everyone is here already
		cecho('\n\n&lt;green&gt;MURDER: &lt;white&gt;everyone is collected now!\n')
		if (murder.paused) then
  		murder.resume()
  	end
		callback()

	end


	tempRegexTrigger([[^.+ tells the group[^:]*: "(\w+) is at (\d+)"]], function ()

		local vnum = tonumber(matches[3])

		if (tfe.roomInfo.vnum == vnum) then
			roll[matches[2]] = true
		else
			roll[matches[2]] = vnum
		end

		outStandingResponses = outStandingResponses - 1

		if (outStandingResponses == 0) then
			onAllResponded()
		end

	end, outStandingResponses)

	send('gt where are you?')

end


common.fixConditions = function (callback)

	if (not murder.paused) then
		murder.pause()
	end

	local roll = common.newRollCall(false)

	local healthyCheckId = tempRegexTrigger([[^.+ reports? group status: "healthy - (\w+)"]], function ()
		local vic = matches[2]
		if (vic == 'You') then vic = player.name end
		roll[matches[2]] = true
	end)

	send('gstatus condition report')

	tempTimer(5, function ()

		killTrigger(healthyCheckId)

		if common.rollCheck(roll) then
			send('gstatus all healthy')
			if (murder.paused) then
    		murder.resume()
    	end
  		callback()
		else
			send('gstatus not yet healthy enough... retrying')
			tempTimer(10, function()
				common.fixConditions(callback)
			end, 'waiting for cures before checking conditions')
		end

	end)

end


common.newRollCall = function (excludeSelf)

	local roll = {}



	for name, value in pairs(group.members) do
    if (common.includeInRollCalls[name]) then
		  roll[name] = false
    end
	end

	if (excludeSelf) then
		roll[player.name] = true
	end

	return roll

end

common.rollCheck = function(roll)

	for key, value in pairs(roll) do
		if (not value) then
			return false
		end
	end
	return true

end



common.sendPlayer = function (player, rnum, callback)

	local ncb = callback
	tempRegexTrigger([[^.+ tells the group[^:]*: "]] .. player .. [[ is now at ]] .. tostring(rnum) .. [["]], function ()
		ncb()
	end, 1)

	send('gt ' .. player .. ' go to ' .. tostring(rnum))

end

common.groupOnReady = function (cb)

	local grcb = cb

	local rct

	local roll = common.newRollCall(false)


	local readyCheck = function ()
		if (common.rollCheck(roll)) then -- group members
			killTrigger(rct)
  		if (grcb) then
  			grcb()
  		end
		end
	end

	rct = tempRegexTrigger([[^.* (tells the|tell your) group[^:]*: "ready \((.*)\)"]], function ()
		roll[matches[3]] = true
		readyCheck()
	end)

end

common.groupPrepIfUnder = function (mana, heals, cb)

	local pfcb = cb

	common.groupOnReady(function ()
		send('gt Going!!!')
		if (pfcb) then
			pfcb()
		end
	end)

	send('gt prep full if less than ' .. tostring(heals) .. ' cure criticals')
	send('gt get full if under ' .. tostring(mana) .. '% mana')

end

common.groupPrepFree = function (cb)

	local pfcb = cb

  if (group.memberCount == 1) then
    cecho('\n&lt;yellow&gt;COMMON: &lt;white&gt;skipping group prep full due to only one party member\n\n')
    player.prepFull(pfcb)
    return
  end

	common.groupOnReady(function ()
		send('gt going')
		if (pfcb) then
			pfcb()
		end
	end)

	send('gt pfree')

end


common.groupPrepFull = function (cb)

	local pfcb = cb

  if (group.memberCount == 1) then
    cecho('\n&lt;yellow&gt;COMMON: &lt;white&gt;skipping group prep full due to only one party member\n\n')
    player.prepFull(pfcb)
    return
  end

	common.groupOnReady(function ()
		send('gt going')
		if (pfcb) then
			pfcb()
		end
	end)

	send('gt get full')

end
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>debug helpers</name>
			<packageName></packageName>
			<script>-- preserve functions we are about to decorate
oKillTimer = oKillTimer or killTimer
oTempTimer = oTempTimer or tempTimer
oTempRegexTrigger = oTempRegexTrigger or tempRegexTrigger
oTempTrigger = oTempTrigger or tempTrigger

oRaiseEvent = oRaiseEvent or raiseEvent
oRegisterAnonymousEventHandler = oRegisterAnonymousEventHandler or registerAnonymousEventHandler
oKillAnonymousEventHandler = oKillAnonymousEventHandler or killAnonymousEventHandler


eventHandlers = eventHandlers or {}

function registerAnonymousEventHandler(evt, fn, selfDestruct)

	local thisData = {
		handlerId = 0,
		thisEvt = evt,
		lcb = fn,
	}

  local callback

	if (type(thisData.lcb) == 'string') then
  		callback =thisData.lcb
			cecho('\n&lt;red&gt;EVENT: &lt;white&gt;event handler defined as string - ' .. thisData.lcb .. ' : ' .. '\n')
	else
		callback = function (...)
    		local cb = thisData.lcb
    		-- cecho('\n&lt;green&gt;EVENT: &lt;white&gt;event handler triggered - ' .. tostring(thisData.handlerId) .. ' : ' .. thisData.thisEvt .. '\n')
				-- display(arg)
    		return cb(unpack(arg))
    	end
	end

	thisData.handlerId = oRegisterAnonymousEventHandler(evt, callback, selfDestruct)
	eventHandlers[thisData.handlerId] = evt

	return thisData.handlerId

end

function killAnonymousEventHandler(id)

	if (eventHandlers[id] ~= nil) then
		-- cecho('\n&lt;green&gt;EVENT: &lt;white&gt;killed handler - ' .. tostring(id) .. ' : ' .. eventHandlers[id] .. '\n')
		eventHandlers[id] = nil
	else
		-- cecho('\n&lt;red&gt;TIMER: &lt;white&gt;attempted to kill missing event handler - ' .. id .. '\n')
	end

	return oKillAnonymousEventHandler(id)

end


-- allow us to track raised events
function raiseEvent(...)
	-- cecho('\n&lt;green&gt;EVENT: &lt;white&gt;raised - ' .. arg[1] .. '\n')
	return oRaiseEvent(unpack(arg))
end

function displayEventHandlers()
	display(eventHandlers)
end


-- triggers

local oKillTrigger = oKillTrigger or killTrigger
tempTriggers = tempTriggers or {}



local wrapTrigger = function (triggerCommand)

	local oCommand = triggerCommand

	return function (regex, code, expireAfter)

  	local trigId = nil
  	local oCode = code
  	local expires = expireAfter

  	local newCode = function (...)

			if (tempTriggers[trigId]) then
      		tempTriggers[trigId].calls = tempTriggers[trigId].calls + 1
      		if (tempTriggers[trigId].calls == expires) then
    	  			tempTriggers[trigId] = nil
      			-- cecho('\n&lt;orange&gt;trigger died of natural causes - ' .. trigId .. ' : ' .. regex .. '\n')
      		end
			end

  		return oCode(...)
  	end

  	trigId = oCommand(regex, newCode, expires)

  	tempTriggers[trigId] = tempTriggers[trigId] or { calls = 0, regex = regex }

  	return trigId
  end


end



tempRegexTrigger = wrapTrigger(oTempRegexTrigger)
tempTrigger = wrapTrigger(oTempTrigger)

killTrigger = function(id)
	if (tempTriggers[id] ) then
		tempTriggers[id] = nil
	end
	return oKillTrigger(id)
end

displayTempTriggers = function()
	display(tempTriggers)
end


-- timers



tempTimers = tempTimers or {}

tempTimer = function(seconds, code, description)

	local timerId

	local oCode = code

	local decoratedCode = function (...)
		-- cecho('\n&lt;green&gt;TIMER: &lt;white&gt;timer ran - ' .. tostring(timerId)  .. ' : ' .. (tempTimers[timerId] or '???') .. '\n')
		-- display(tempTimers)
    -- rabies. next to check if oCode is a string and eval it or something lke that. bleh
		tempTimers[timerId] = nil
    if (type(oCode) == 'string') then
      cecho('\n\nERROR in timer code, not a function: ' .. oCode .. '\n\n')
    end

		oCode(...)
	end

	timerId = oTempTimer(seconds, decoratedCode)

	tempTimers[timerId] = (description or 'mystery timer') .. ' - ' .. tostring(seconds) .. ' seconds'

	-- cecho('\n&lt;green&gt;TIMER: &lt;white&gt;timer setup - ' .. tostring(timerId) .. ' : ' .. tempTimers[timerId] .. '\n')

	return timerId

end


killTimer = function(timerId)

	if (tempTimers[timerId] ) then
  	-- cecho('\n&lt;orange&gt;TIMER: &lt;white&gt;killed with fire - ' .. timerId .. ' : ' .. tempTimers[timerId] .. '\n')
  	tempTimers[timerId] = nil
  	oKillTimer(timerId)
	else
		cecho('\n&lt;red&gt;TIMER: &lt;white&gt;attempted to kill missing timer - ' .. timerId .. '\n')
	end
end

displayTempTimers = function()
	display(tempTimers)
end




</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>formatters</name>
			<packageName></packageName>
			<script>
common.consoleMessage = function(console, message, statusColor)

  local color = 'green'

  if (statusColor) then
    color = statusColor
  end

  console:cecho('&lt;' .. color .. '&gt;' .. getTime(true, "hh:mm:ss") .. ': &lt;white&gt;' .. message .. "\n")
end




common.formatElapsedTime = function (time)

	local ts = '';

	if (not time) then
		return '0 seconds'
	end

	local hrs = 0
	local mins = 0
	local secs = 0

	if (time &gt;= 3600) then
		hrs = math.floor(time / 3600)
		time = time - (hrs * 3600)
		ts = ts .. tostring(hrs) .. ' hrs, '
	end


	if (time &gt;= 60 or hrs &gt; 0) then
		mins = math.floor(time / 60)
		time = time - (mins * 60)
		ts = ts .. tostring(mins) .. ' mins, '
	end

	secs = math.floor(time)
	time = time - secs
	ts = ts .. tostring(secs) .. ' seconds'


	return ts

end


common.getNumber = function (text)

	local wordToNumberData = {
  	a = 1,
  	an = 1,
  	the = 1,
		one = 1,
		two = 2,
		three = 3,
		four = 4,
		five = 5,
		six = 6,
		seven = 7,
		eight = 8,
		nine = 9,
		ten = 10,
		eleven = 11,
		twelve = 12,
		thrirteen = 13,
		fourteen = 14,
	}

	local numTxt = rex.match(text, [[^\S+]])

	if (numTxt) then
		return wordToNumberData[string.lower(numTxt)] or 1
	else
		-- either it's more than 14 or a proper noun. i.e Stinky (your mount
		return 1
	end

end


common.dotCase = function(string)

	if (not string or string == '') then
		return ''
	end
	return rex.gsub(string, [[\b(the|or|an|a|of|with|and|A|An|The) ]], ''):gsub(' ', '.')
end


common.itemSanitize = function(string)

	if (not string or string == '') then
		return ''
	end



	string = rex.gsub(string, [[(enchanted |empty, |flaming, frost-covered |flaming |labeled |empty |\s\+\d)]], '')

  if (string ~= 'frost-covered ring') then
    string = rex.gsub(string, [[frost-covered ]], '')
  end

  return string

end

common.itemShorten = function(item)

  return rex.gsub(
		rex.gsub(common.dotCase(common.itemSanitize(item)),"'(.*)'",'%1'),
		'([^.][^.][^.][^.]?)[^.]+',
		'%1'
	)

end

common.commaCase = function (str)
    local extra = #str%3
    if string.sub(str,1,1) == "-" then
        if extra == 0 then
            extra = 3
        else
            extra = extra + 1
        end
    end
    local result = ""
    if extra &gt; 0 then
        result = string.sub(str,1,extra)
        str = string.sub(str,extra+1)
    end
    for w in string.gmatch(str,"%d%d%d") do
        result = result .. "," .. w
    end
    return result:gsub([[^,?]],'')
end



common.toMurderString = function (victim)

	-- remove any articles etc
	victim = rex.gsub(victim, [[\b(a|an|the|good|evil|The|one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen)\s]], '')

	-- turn elves back into elf, dwarves etc
	victim = rex.gsub(victim, [[ves$]], 'f')

	-- turn women back to womans
	victim = rex.gsub(victim, [[women\b]], 'woman')

	-- drop i from end (plurals like homonculi
  local ignoreTerminalI = {
    yeti = true,
    ['mammoth yeti'] = true,
  }

  if (not ignoreTerminalI[victim]) then
	 victim = rex.gsub(victim, [[i\b]], '')
  end



	 -- turn mercenaries back into mercanary
	victim = rex.gsub(victim, [[ies$]], 'y')

	-- dump any s's or es's on the end of a plural
	-- west : two greater cyclopses, vs a greater cyclops
	-- drudges should go to drudge tho...
	if (rex.find(victim, [[ses\b]])) then
		victim = rex.gsub(victim, [[ses\b]], 's')
	elseif (rex.find(victim, [[es\b]])) then
		victim = rex.gsub(victim, [[es\b]], 'e')
	else
		victim = rex.gsub(victim, [[('?s'?)\b]], '')
	end

	-- dump any random commas
	victim = rex.gsub(victim, [[,]], '')

	-- kill any parts less than 3 charaters

	victim = rex.gsub(victim, [[(^|\.|\s)\S\S?(\s|\.|$)]], '%1%2')

	-- kill any extra whitepsace or multiple .'s
	victim = rex.gsub(victim, [[(\s\s+|\.\.+)]], ' ')
	victim = string.trim(victim)

	-- kill any . at start or end.
	victim = rex.gsub(victim, [[^\.]], '')
	victim = rex.gsub(victim, [[\.$]], '')

	return victim

end
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>status checks / prep</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

common.getAffects =  function (cb)
	common.onNextEvent(common.events.PARSED_AFFECTS, function (evt, affects)
		cb(affects)
	end)
	send('affects')
end

common.onClear = function(action)
	common.onNextEvent(common.events.ROOM_CLEAR, action)
end


common.checkShields = function (cbGood, cbBad)


  -- Affect                                            Source
  --
  -- ------                                            ------
  -- You sense a divine protection.                    leech: a male vyan
  -- You feel righteous.                               leech: a male vyan

	local affectWatcher = nil

	local tempAffects = false
	local affectCount = 0

	local okayTempAffects = {
		['You feel sick!'] = true,
		['Your battlemind is divinely focused.'] = true,
		['You are embraced by earthen protection.'] = true,
	}

	common.getAffects( function (affects)



		for affect, source in pairs(affects) do




  		if (source == 'temporary') then
  			-- earthen protection is always tempporary
  			if not okayTempAffects[affect] then
  				cecho('&lt;white&gt;--== &lt;red&gt;expiring : ' .. affect .. ' &lt;white&gt; =-\n')
  				tempAffects = true
  			end

  		end
  		affectCount = affectCount + 1

		end

		if (tempAffects) then
			cecho('\n&lt;red&gt;WARNING: &lt;white&gt;Affects Checked!, some shields will expire!\n')
			if (cbBad) then
				cbBad(player.affects)
			end
		else
			cecho('\n&lt;green&gt;Affects Checked!, ' .. tostring(affectCount) .. ' affects are good\n')
			if (cbGood) then
				cbGood(player.affects)
			end
		end

	end)


end
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>check resources</name>
			<packageName></packageName>
			<script>
common.updateStatus = function(callback)
  common.onNextEvent(common.events.PARSED_GROUP, function ()
  	callback()
  end)
	send('group')
end

common.checkFull = function(callback)
	common.checkResources(player.hp_max, player.mp_max, player.moves_max, callback)
end


common.onOffsetReady = function(lessHp, lessMp, lessMoves, callback)

	common.checkResources(player.hp_max - lessHp, player.mp_max - lessMp, player.moves_max - lessMoves, function(readyStatus)
		if(readyStatus) then
			callback()
		else
			tempTimer(10, function ()
				common.onOffsetReady(lessHp, lessMp, lessMoves, callback)
			end, 'on offset ready')
		end
	end)

end


common.onManaReady = function(mana, callback)

	common.checkResources(0, mana, 0, function(readyStatus)
		if(readyStatus) then
			callback()
		else
			tempTimer(10, function ()
				common.onManaReady(mana, callback)
			end, 'on mana ready')
		end
	end)

end


common.checkResources = function(hp, mp, moves, callback)
	common.updateStatus( function ()

		if (player.hp &gt;= hp and player.mp &gt;= mp and player.moves &gt;= moves) then
			echo('\n\n .. READY TO KILL\n')
			callback(true)
		else
			echo('\n\n .. sleep more little tank\n')
			callback(false)
		end
	end)
end


common.onFull = function (callback)

	common.checkFull( function(readyStatus)
		if(readyStatus) then
			callback()
		else
			common.checkFullTimer = tempTimer(10, function ()
				common.checkFullTimer = nil
				common.onFull(callback)
			end, 'on full')
		end
	end)


end
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>conversions from old code</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------

mapper = mapper or {}
murder = murder or {}

murder.tankState = murder.tankState or 'here'

mapper.gotoRoom = function(rnum, callback)
  tfe.gotoRoom(rnum, {callback = callback})
end


murder.idleScanner = function ()

	murder.clearIdleScanTimer()

	if (murder.enabled and not murder.speedwalking) then
  	cecho('\n&lt;green&gt;MURDER: &lt;white&gt;started idle scan timer!\n')
  	murder.idleTimer = tempTimer(10, function ()
  		cecho('\n&lt;orange&gt;MURDER: &lt;white&gt;scannign due to idle for 10s!\n')
  		send('typo &amp; scan')
  		murder.idleScanner()
  	end, 'murder idle timer')
	end

end

murder.clearIdleScanTimer = function()
	if (murder.idleTimer) then
		cecho('\n&lt;green&gt;MURDER: &lt;white&gt;cleared existing idle scan timer!\n')
  	killTimer(murder.idleTimer)
  	murder.idleTimer = nil
	end
end
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>combat.hit</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------

combat = combat or {}

combat.hit = function(evt, attackData)

  -- deleteLine()
  cecho('&lt;green&gt;ATK:&lt;white&gt; ' .. attackData.subject .. ' : ' .. attackData.damage)

  -- display(attackData)
end</script>
			<eventHandlerList>
				<string>COMMON:: combat_attack</string>
			</eventHandlerList>
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>tfe.char_fighting</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------

tfe = tfe or {}

tfe.char_fighting = function ()

  local fighting = gmcp.Char.Fighting or {}

  local count = 0

  for mob, state in pairs(gmcp.Char.Fighting) do
    count = count + 1
  end
  
  combat.mobs = count
  
  if (count == 0 and combat.active) then
    combat.finshDelayTimer = tempTimer(1, function()
      combat.finish()
      combat.finshDelayTimer = nil
    end)
  elseif (count &gt; 0 and not combat.active) then
    if (combat.finshDelayTimer ~= nil) then
      killTimer(combat.finshDelayTimer)
      combat.finshDelayTimer = nil
    end 
    combat.start()
  end

end</script>
			<eventHandlerList>
				<string>gmcp.Char.Fighting</string>
			</eventHandlerList>
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>improves</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------

improves = improves or {}

improves.castQueue = improves.castQueue or {}

improves.fillerSpell = 'filler'

improves.castFillerLastTick = true

improves.queueSpell = function(spell)
	table.insert(improves.castQueue, spell)
end


improves.setFiller = function (spell)
	improves.fillerSpell  = spell
end



improves.castSpell = function ()

	if (#improves.castQueue == 0) then

		cecho('\n\n -= ' .. improves.fillerSpell .. ' =-\n\n')
		send(improves.fillerSpell)
		improves.castFillerLastTick = true

	else

		if (improves.castFillerLastTick) then

			improves.castFillerLastTick = false
			cecho('\n\n -= holding filler for real spell next tick =-\n\n')

		else

			local spell = table.remove(improves.castQueue, 1)
			improves.castFillerLastTick = true
			cecho('\n\n -= ' .. spell .. ' =-\n\n')
			send(spell)

		end

	end

end

improves.defaultMageList = {
  'shock',
  'burning hands',
  'chilling touch',
  'corrosive touch',
  'fireball',
  'freeze',
  'lightning bolt',
  -- 'sleep',
  'acid blast',
  -- 'mists of sleep',
  'chain lightning',
  'ice storm',
  'flame strike',
  'acid storm',
  'arc lightning',
  'ice lance',
  'conflagration'
}

improves.spellList = improves.spellList or improves.defaultMageList

improves.setImproveList = function (improveList)
  improves.spellList = improveList
end

improves.improveLeech = function (spell)
  if (player.skills[spell] &lt; 10) then
    improves.queueSpell('cast ' .. spell .. ' &amp; queue leech ' .. spell)
  else
    cecho('\n\n&lt;green&gt; ' .. spell .. ' is maxxed, hooray!\n')
  end
end

improves.getImproveSpell = function ()

  if (#improves.spellList == 0) then
    return ''
  end

  player.impAttempt = player.impAttempt or 0

  player.impAttempt = (player.impAttempt % #improves.spellList) + 1

  local spell = improves.spellList[player.impAttempt]

  if (player.skills == nil) then
    send('abil all')
  else
    -- remove this maxxed out or unlearned spell and return the next one in the list
    if (player.skills[spell] == nil or player.skills[spell] &gt;= 10 or player.skills[spell] == 0) then
      cecho('\n&lt;yellow&gt;removing ' .. spell .. ' from impprove list\n')
      table.remove(improves.spellList, player.impAttempt)
      return improves.getImproveSpell()
    end
  end

  return 'cast ' .. spell

end</script>
			<eventHandlerList />
		</Script>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>gmcp-group</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>gcmp healer</name>
				<packageName></packageName>
				<script>common = common or {}


local convertRecord = function (record)
  return {
    mp_max = record.maxen,
    mp = record.en,
    moves_max = record.maxmv,
    hp = record.hp,
    hp_max = record.maxhp,
    moves = record.mv
  }
end



common.updateFromGMCP = function()

  -- skip if gmcp is not fully init
  if (not gmcp.Char.Score) then
    return
  end

  if (common.updateGMCPTimer ~= nil) then
    -- cecho('&lt;yellow&gt; &lt;-- (update already pending)')
    return
  end
    
  
    
  common.updateGMCPTimer = tempTimer(0.1, function()
      
    local playerStats = convertRecord(gmcp.Char.Vitals)
    
    group.lowest_moves = gmcp.Group.minmv
    
    group.memberCount = 1
    group.members = {[gmcp.Char.Score.name] = true}
  
    group[gmcp.Char.Score.name] = playerStats
    
    for stat, val in pairs(playerStats) do
      player[stat] = val
    end
    
    
    for name, stats in pairs(gmcp.Group.members) do
      group.memberCount = group.memberCount + 1
      group.members[name] = true
      group[name] = convertRecord(stats)
    end
  
    raiseEvent(common.events.PARSED_GROUP);
    common.updateGMCPTimer = nil;
    -- cecho('\n&lt;green&gt;GROUP: &lt;white&gt;data updated!!\n')
  end)
  -- cecho('&lt;orange&gt; &lt;-- update queued...\n')
  
end


-- 
-- healer.reducePlayerHp = function(subject, amount)
  -- 
  -- group[subject].hp = group[subject].hp - amount
  -- 
  -- -- if the player is us...
  -- if (player.name == subject) then
    -- player.hp = player.hp - amount
  -- end
  -- 
  -- cecho('&lt;red&gt;HP: &lt;white&gt;' .. subject .. ': ' .. tostring(group[subject].hp))
  -- 
  -- healer.check_player_health(subject)
  -- 
-- end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>common.groupUpdateGMCP</name>
				<packageName></packageName>
				<script>
common.groupUpdateGMCP = function ()

  -- cecho('&lt;green&gt; &lt;-- group updated ')
  common.updateFromGMCP()

end</script>
				<eventHandlerList>
					<string>gmcp.Group</string>
				</eventHandlerList>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>common.playerUpdateGMCP</name>
				<packageName></packageName>
				<script> -- display(gmcp.Group)
 
common.playerUpdateGMCP = function ()
  -- cecho('&lt;green&gt; &lt;-- player updated ')
  common.updateFromGMCP()
end</script>
				<eventHandlerList>
					<string>gmcp.Char.Vitals</string>
				</eventHandlerList>
			</Script>
			<Script isActive="no" isFolder="no">
				<name>common.playerHitEvent</name>
				<packageName></packageName>
				<script>common.playerHitEvent = function (evt, data)

  -- healer.reducePlayerHp(data.subject, data.amount)

end</script>
				<eventHandlerList>
					<string>COMMON:: combat_player_hit</string>
				</eventHandlerList>
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Damage Meter</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>damage meter</name>
				<packageName></packageName>
				<script>damageMeter = damageMeter or {}

damageMeter.start = function ()

  if (damageMeter.combatEndWatcher) then
    killAnonymousEventHandler(damageMeter.combatEndWatcher)
    damageMeter.combatEndWatcher = nil
  end
  
  damageMeter.combatEndWatcher = registerAnonymousEventHandler(common.events.COMBAT_ENDED, damageMeter.combatTimer)


  damageMeter.reset()
  damageMeter.startTime = getEpoch()
  damageMeter.recording = true
  damageMeter.combatTime = 0
end

damageMeter.stop = function ()
  damageMeter.stopTime = getEpoch()
  damageMeter.recording = false
end

local updateDamageRecord = function(record, amount) -- , type
  record.count = record.count or 0
  record.count = record.count + 1
  record.amount = record.amount or 0
  record.amount = record.amount + amount
  -- record.spells = record.spells or {}
  
  -- if (type) then
    -- record.type = type
  -- end
  -- i don't think we need to keep this...
  -- record.amounts = record.amounts or {}
  -- table.insert(record.amounts, amount)
end

damageMeter.record = function (dealer, amount, target, type, spell)

  -- echo(' &lt;- ' .. type .. ' ' .. dealer .. ' : ' .. tostring(amount))
  -- deleteLine()
  
  -- if (type == 'no-damage') then
    -- cecho('\n\n&lt;green&gt;[DAMAGE METER] &lt;white&gt;non damage hit ' .. spell .. '\n\n')
  -- end
  
  if (damageMeter.recording) then
  
    damageMeter.byMember[dealer] = damageMeter.byMember[dealer] or {}
  
    local record = damageMeter.byMember[dealer]
  
    -- record.spell = record.spell or {}
    record.type = record.type or {}

    record.type[type] = record.type[type] or {}
    record.type[type].spells = record.type[type].spells or {}
    record.type[type].spells[spell] = record.type[type].spells[spell] or {}
    
    -- record.spell[spell] = record.spell[spell] or {}
  
    updateDamageRecord(record.type[type], amount)
    updateDamageRecord(record.type[type].spells[spell], amount)
    
    -- updateDamageRecord(record.spell[spell], amount, type)
  
  end

end

damageMeter.reset = function ()
  damageMeter.recording = false
  damageMeter.stopTime = nil
  damageMeter.byMember = {}
  -- damageMember.byTarget = {}
end

damageMeter.report = function(target)

  if (target and group.members[target]) then
    damageMeter.reportPlayer(target)
    return
  end
  
  
  -- 
  -- testMaker = demonnic.TableMaker:new()
  -- -- Though by itself, it won't really do much. So let's add a few columns to it
  -- testMaker:addColumn({name = "col1", width = 15, textColor = "&lt;orange&gt;"})
  -- testMaker:addColumn({name = "col2", width = 20, textColor = "&lt;green&gt;"})
  -- testMaker:addColumn({name = "col3", width = 30, textColor = "&lt;purple&gt;"})
  -- -- These are fairly minimal format options, but are enough for our demonstration purposes. 
  -- -- So now we've described the formatting for our table, let's add some information to display and print it out.
  -- testMaker:addRow({"row 1 col 1", "row 1 col 2", "row 1 col 3"})
  -- testMaker:addRow({"row 2 col 1", "row 2 col 2", "row 2 col 3"})
  -- testMaker:addRow({"row 3 col 1", "row 3 col 2", "row 3 col 3"})
  -- cecho(testMaker:assemble())
  
  local time = damageMeter.combatTime or 1
  local elapsedTime = (damageMeter.stopTime or getEpoch()) - damageMeter.startTime
  
  cecho('\n\n&lt;green&gt;Damage\n')
  cecho('&lt;white&gt;Combat Time: ' .. common.formatElapsedTime(time) .. '\n')
  cecho('&lt;white&gt;Elapsed Time: ' .. common.formatElapsedTime(elapsedTime) .. '\n\n')
  
  for member, cats in pairs(damageMeter.byMember) do
    
    local total = 0
    
    for dt, stats in pairs(cats.type) do
      total = total + stats.amount
    end
    
    local dps = math.floor(100 * total / time) / 100
    
    cecho(
      demonnic:cfText(
        member, 
        {
          alignment = "left", 
          width = 15, 
          spacer = ".", 
          inside = true, 
          textColor = "&lt;green&gt;"
        }
      ) ..
      demonnic:fText(
        tostring(dps), 
        {
          alignment = "right", 
          width = 10, 
          spacer = ".", 
          textColor = "&lt;white&gt;"
        }
      ) ..
      ' dps\n'
    ) 
  end
  
  if (target and target == 'all') then
    for player, data in pairs(damageMeter.byMember) do
      damageMeter.reportPlayer(player)
    end
  end
  
end

damageMeter.reportPlayer = function(player)
  -- 


  local time = damageMeter.combatTime or 1
  local elapsedTime = (damageMeter.stopTime or getEpoch()) - damageMeter.startTime
  
  local total = 0
    
  for dt, stats in pairs(damageMeter.byMember[player].type) do
    total = total + stats.amount
  end
  
  
  cecho('\n\n&lt;green&gt;Damage by ' .. player .. '\n')
  cecho('&lt;white&gt;Combat Time: ' .. common.formatElapsedTime(time) .. '\n')
  cecho('&lt;white&gt;Elapsed Time: ' .. common.formatElapsedTime(elapsedTime) .. '\n')
  cecho('&lt;white&gt;Damage output: ' .. tostring(math.floor(100 * total / time) / 100) .. ' dps\n\n')
  
  
  if (damageMeter.byMember[player].type.spell) then
    damageMeter.reportByType('spell', damageMeter.byMember[player].type.spell, player)
  end
  
  if (damageMeter.byMember[player].type.melee) then
    damageMeter.reportByType('melee damage', damageMeter.byMember[player].type.melee, player)
  end
  
  if (damageMeter.byMember[player].type.proc) then
    damageMeter.reportByType('procs', damageMeter.byMember[player].type.proc, player)
  end
  
  if (damageMeter.byMember[player].type['no-damage']) then
    damageMeter.reportByType('non damage', damageMeter.byMember[player].type['no-damage'], player)
  end

end

damageMeter.reportByType = function(type, rollup, player)

  local data = rollup.spells

  -- 
  testMaker = demonnic.TableMaker:new({
    edgeCharacter = '|'
  })
  
  local meleeHits = 1
  
  if (damageMeter.byMember[player].type.melee) then
    meleeHits = damageMeter.byMember[player].type.melee.count or 1
  end
  
 
  local time = damageMeter.combatTime or 1

  local dataKeys = table.keys(data)
  
  if (type == 'non damage') then
    testMaker:addColumn({name = type, width = 25, textColor = "&lt;green&gt;"})
    testMaker:addColumn({name = "count", width = 10, textColor = "&lt;white&gt;"})
    testMaker:addColumn({name = "% melee", width = 20, textColor = "&lt;purple&gt;"})
    table.sort(dataKeys, function(a,b) return data[a].count &gt; data[b].count end)
  else
    testMaker:addColumn({name = type, width = 25, textColor = "&lt;green&gt;"})
    testMaker:addColumn({name = "average", width = 10, textColor = "&lt;white&gt;"})
    testMaker:addColumn({name = "count", width = 10, textColor = "&lt;white&gt;"})
    testMaker:addColumn({name = "dps", width = 10, textColor = "&lt;purple&gt;"})
    table.sort(dataKeys, function(a,b) return data[a].amount &gt; data[b].amount end)
  end
  
  for idx, spell in ipairs(dataKeys) do
  
    local stats = data[spell]
    
    local avg = math.floor(10 * stats.amount / stats.count) / 10
    local dps = math.floor(100 * stats.amount / time) / 100
    
    local pctMelee = math.floor(10000 * stats.count / meleeHits)  / 100
    
    if (type == 'non damage') then
      if (spell == 'fall down') then 
        local chargeCt = damageMeter.byMember[player].type.melee.spells.charge.count or 0
        chargeCt = chargeCt + stats.count
        pctMelee = math.floor(10000 * stats.count / chargeCt) / 100
        testMaker:addRow({'charge: ' .. spell, tostring(stats.count), tostring(pctMelee) .. '%'})
      else 
        testMaker:addRow({spell, tostring(stats.count), tostring(pctMelee) .. '%'})
      end
    else
      testMaker:addRow({spell, tostring(avg), tostring(stats.count), tostring(dps)})
    end
    
  end
      
  if (type ~= 'non damage') then
    testMaker:addRow({
      'total', 
      tostring(math.floor(10 * rollup.amount / rollup.count) / 10), 
      tostring(rollup.count), tostring(math.floor(100 * rollup.amount / time) / 100)
    })
  end
  
  cecho(testMaker:assemble() .. '\n\n')

end

damageMeter.combatTimer = function(evt, duration) 
  damageMeter.combatTime = damageMeter.combatTime + duration
end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>damageMeter.hit</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------

damageMeter = damageMeter or {}

damageMeter.hit = function(evt, attackData)
  if (damageMeter.recording) then
    damageMeter.record(attackData.subject, attackData.damage, attackData.mob, attackData.damageType, attackData.move)
  end
end</script>
				<eventHandlerList>
					<string>COMMON:: combat_attack</string>
				</eventHandlerList>
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>auto assist</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>auto_assist</name>
				<packageName></packageName>
				<script>combat = combat or {}
player = player or {}

combat.assistOffCooldown = true

</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>combat.auto_assist_on_attack</name>
				<packageName></packageName>
				<script>

combat.auto_assist_on_attack = function (evt, attackData)

  if ( group.leader and 
     player.name ~= group.leader and 
     attackData.subject == group.leader and 
     combat.assistOffCooldown == true and 
     combat.active ~= true
  ) then
    
    combat.assistOffCooldown = false    
    -- enable assist again after 1 second (prevent excessive spam before gmcp combat starts)
    tempTimer(2, function () 
      combat.assistOffCooldown = true
    end)

    local target = common.dotCase(common.toMurderString(attackData.mob))
    
    player.autoAttack(target)
    
  end
  
end
</script>
				<eventHandlerList>
					<string>COMMON:: combat_attack</string>
				</eventHandlerList>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>combat.auto_assist_on_room_change</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
combat.auto_assist_on_room_change = function ()

  combat.assistOffCooldown = true
  
end</script>
				<eventHandlerList>
					<string>tfe mapper: room found</string>
				</eventHandlerList>
			</Script>
		</ScriptGroup>
		<Script isActive="yes" isFolder="no">
			<name>last script (to trigger dependencies!)</name>
			<packageName></packageName>
			<script>raiseEvent('njs50PlevLoaded')</script>
			<eventHandlerList />
		</Script>
	</ScriptPackage>
	<KeyPackage />
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
